
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model StaffUser
 * 
 */
export type StaffUser = $Result.DefaultSelection<Prisma.$StaffUserPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Opportunity
 * 
 */
export type Opportunity = $Result.DefaultSelection<Prisma.$OpportunityPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Quotation
 * 
 */
export type Quotation = $Result.DefaultSelection<Prisma.$QuotationPayload>
/**
 * Model QuoteItem
 * 
 */
export type QuoteItem = $Result.DefaultSelection<Prisma.$QuoteItemPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model Shipment
 * 
 */
export type Shipment = $Result.DefaultSelection<Prisma.$ShipmentPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Communication
 * 
 */
export type Communication = $Result.DefaultSelection<Prisma.$CommunicationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const OpportunityStatus: {
  OPEN: 'OPEN',
  QUALIFIED: 'QUALIFIED',
  PROPOSAL_SENT: 'PROPOSAL_SENT',
  NEGOTIATION: 'NEGOTIATION',
  WON: 'WON',
  LOST: 'LOST',
  ON_HOLD: 'ON_HOLD'
};

export type OpportunityStatus = (typeof OpportunityStatus)[keyof typeof OpportunityStatus]


export const QuotationStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type QuotationStatus = (typeof QuotationStatus)[keyof typeof QuotationStatus]


export const OrderStatus: {
  PENDING_CONFIRMATION: 'PENDING_CONFIRMATION',
  CONFIRMED: 'CONFIRMED',
  PROCESSING: 'PROCESSING',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  OVERDUE: 'OVERDUE',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const ShipmentStatus: {
  PENDING: 'PENDING',
  IN_TRANSIT: 'IN_TRANSIT',
  DELIVERED: 'DELIVERED',
  DELAYED: 'DELAYED',
  FAILED: 'FAILED'
};

export type ShipmentStatus = (typeof ShipmentStatus)[keyof typeof ShipmentStatus]


export const ProjectStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const TaskStatus: {
  Pending: 'Pending',
  InProgress: 'InProgress',
  Completed: 'Completed',
  Canceled: 'Canceled'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Currency: {
  BHD: 'BHD',
  USD: 'USD',
  EUR: 'EUR',
  GBP: 'GBP',
  AED: 'AED'
};

export type Currency = (typeof Currency)[keyof typeof Currency]


export const CommunicationType: {
  EMAIL: 'EMAIL',
  CALL: 'CALL',
  NOTE: 'NOTE',
  MEETING: 'MEETING'
};

export type CommunicationType = (typeof CommunicationType)[keyof typeof CommunicationType]


export const CommunicationDirection: {
  INBOUND: 'INBOUND',
  OUTBOUND: 'OUTBOUND',
  INTERNAL: 'INTERNAL'
};

export type CommunicationDirection = (typeof CommunicationDirection)[keyof typeof CommunicationDirection]

}

export type OpportunityStatus = $Enums.OpportunityStatus

export const OpportunityStatus: typeof $Enums.OpportunityStatus

export type QuotationStatus = $Enums.QuotationStatus

export const QuotationStatus: typeof $Enums.QuotationStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type ShipmentStatus = $Enums.ShipmentStatus

export const ShipmentStatus: typeof $Enums.ShipmentStatus

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Currency = $Enums.Currency

export const Currency: typeof $Enums.Currency

export type CommunicationType = $Enums.CommunicationType

export const CommunicationType: typeof $Enums.CommunicationType

export type CommunicationDirection = $Enums.CommunicationDirection

export const CommunicationDirection: typeof $Enums.CommunicationDirection

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more StaffUsers
 * const staffUsers = await prisma.staffUser.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more StaffUsers
   * const staffUsers = await prisma.staffUser.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.staffUser`: Exposes CRUD operations for the **StaffUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffUsers
    * const staffUsers = await prisma.staffUser.findMany()
    * ```
    */
  get staffUser(): Prisma.StaffUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Opportunities
    * const opportunities = await prisma.opportunity.findMany()
    * ```
    */
  get opportunity(): Prisma.OpportunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotation`: Exposes CRUD operations for the **Quotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotations
    * const quotations = await prisma.quotation.findMany()
    * ```
    */
  get quotation(): Prisma.QuotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quoteItem`: Exposes CRUD operations for the **QuoteItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteItems
    * const quoteItems = await prisma.quoteItem.findMany()
    * ```
    */
  get quoteItem(): Prisma.QuoteItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shipment`: Exposes CRUD operations for the **Shipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shipments
    * const shipments = await prisma.shipment.findMany()
    * ```
    */
  get shipment(): Prisma.ShipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communication`: Exposes CRUD operations for the **Communication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communications
    * const communications = await prisma.communication.findMany()
    * ```
    */
  get communication(): Prisma.CommunicationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    StaffUser: 'StaffUser',
    Task: 'Task',
    Customer: 'Customer',
    Opportunity: 'Opportunity',
    Project: 'Project',
    Quotation: 'Quotation',
    QuoteItem: 'QuoteItem',
    Order: 'Order',
    PurchaseOrder: 'PurchaseOrder',
    Shipment: 'Shipment',
    Payment: 'Payment',
    Document: 'Document',
    Communication: 'Communication'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "staffUser" | "task" | "customer" | "opportunity" | "project" | "quotation" | "quoteItem" | "order" | "purchaseOrder" | "shipment" | "payment" | "document" | "communication"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      StaffUser: {
        payload: Prisma.$StaffUserPayload<ExtArgs>
        fields: Prisma.StaffUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>
          }
          findFirst: {
            args: Prisma.StaffUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>
          }
          findMany: {
            args: Prisma.StaffUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>[]
          }
          create: {
            args: Prisma.StaffUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>
          }
          createMany: {
            args: Prisma.StaffUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>[]
          }
          delete: {
            args: Prisma.StaffUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>
          }
          update: {
            args: Prisma.StaffUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>
          }
          deleteMany: {
            args: Prisma.StaffUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>[]
          }
          upsert: {
            args: Prisma.StaffUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffUserPayload>
          }
          aggregate: {
            args: Prisma.StaffUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffUser>
          }
          groupBy: {
            args: Prisma.StaffUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffUserCountArgs<ExtArgs>
            result: $Utils.Optional<StaffUserCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Opportunity: {
        payload: Prisma.$OpportunityPayload<ExtArgs>
        fields: Prisma.OpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findFirst: {
            args: Prisma.OpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findMany: {
            args: Prisma.OpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          create: {
            args: Prisma.OpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          createMany: {
            args: Prisma.OpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          delete: {
            args: Prisma.OpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          update: {
            args: Prisma.OpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpportunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          upsert: {
            args: Prisma.OpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          aggregate: {
            args: Prisma.OpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunity>
          }
          groupBy: {
            args: Prisma.OpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Quotation: {
        payload: Prisma.$QuotationPayload<ExtArgs>
        fields: Prisma.QuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findFirst: {
            args: Prisma.QuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findMany: {
            args: Prisma.QuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          create: {
            args: Prisma.QuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          createMany: {
            args: Prisma.QuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          delete: {
            args: Prisma.QuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          update: {
            args: Prisma.QuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          deleteMany: {
            args: Prisma.QuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          upsert: {
            args: Prisma.QuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          aggregate: {
            args: Prisma.QuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotation>
          }
          groupBy: {
            args: Prisma.QuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationCountAggregateOutputType> | number
          }
        }
      }
      QuoteItem: {
        payload: Prisma.$QuoteItemPayload<ExtArgs>
        fields: Prisma.QuoteItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          findFirst: {
            args: Prisma.QuoteItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          findMany: {
            args: Prisma.QuoteItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          create: {
            args: Prisma.QuoteItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          createMany: {
            args: Prisma.QuoteItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          delete: {
            args: Prisma.QuoteItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          update: {
            args: Prisma.QuoteItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          deleteMany: {
            args: Prisma.QuoteItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          upsert: {
            args: Prisma.QuoteItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          aggregate: {
            args: Prisma.QuoteItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteItem>
          }
          groupBy: {
            args: Prisma.QuoteItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteItemCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      Shipment: {
        payload: Prisma.$ShipmentPayload<ExtArgs>
        fields: Prisma.ShipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findFirst: {
            args: Prisma.ShipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          findMany: {
            args: Prisma.ShipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          create: {
            args: Prisma.ShipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          createMany: {
            args: Prisma.ShipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          delete: {
            args: Prisma.ShipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          update: {
            args: Prisma.ShipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          deleteMany: {
            args: Prisma.ShipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>[]
          }
          upsert: {
            args: Prisma.ShipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShipmentPayload>
          }
          aggregate: {
            args: Prisma.ShipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShipment>
          }
          groupBy: {
            args: Prisma.ShipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShipmentCountArgs<ExtArgs>
            result: $Utils.Optional<ShipmentCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Communication: {
        payload: Prisma.$CommunicationPayload<ExtArgs>
        fields: Prisma.CommunicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          findFirst: {
            args: Prisma.CommunicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          findMany: {
            args: Prisma.CommunicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          create: {
            args: Prisma.CommunicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          createMany: {
            args: Prisma.CommunicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          delete: {
            args: Prisma.CommunicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          update: {
            args: Prisma.CommunicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          deleteMany: {
            args: Prisma.CommunicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          upsert: {
            args: Prisma.CommunicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          aggregate: {
            args: Prisma.CommunicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunication>
          }
          groupBy: {
            args: Prisma.CommunicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunicationCountArgs<ExtArgs>
            result: $Utils.Optional<CommunicationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    staffUser?: StaffUserOmit
    task?: TaskOmit
    customer?: CustomerOmit
    opportunity?: OpportunityOmit
    project?: ProjectOmit
    quotation?: QuotationOmit
    quoteItem?: QuoteItemOmit
    order?: OrderOmit
    purchaseOrder?: PurchaseOrderOmit
    shipment?: ShipmentOmit
    payment?: PaymentOmit
    document?: DocumentOmit
    communication?: CommunicationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StaffUserCountOutputType
   */

  export type StaffUserCountOutputType = {
    createdOpportunities: number
    updatedOpportunities: number
    createdQuotations: number
    updatedQuotations: number
    createdOrders: number
    updatedOrders: number
    createdShipments: number
    updatedShipments: number
    createdPayments: number
    updatedPayments: number
    approvedQuotations: number
    assignedTasks: number
    loggedCommunications: number
    managedProjects: number
    memberOfProjects: number
  }

  export type StaffUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdOpportunities?: boolean | StaffUserCountOutputTypeCountCreatedOpportunitiesArgs
    updatedOpportunities?: boolean | StaffUserCountOutputTypeCountUpdatedOpportunitiesArgs
    createdQuotations?: boolean | StaffUserCountOutputTypeCountCreatedQuotationsArgs
    updatedQuotations?: boolean | StaffUserCountOutputTypeCountUpdatedQuotationsArgs
    createdOrders?: boolean | StaffUserCountOutputTypeCountCreatedOrdersArgs
    updatedOrders?: boolean | StaffUserCountOutputTypeCountUpdatedOrdersArgs
    createdShipments?: boolean | StaffUserCountOutputTypeCountCreatedShipmentsArgs
    updatedShipments?: boolean | StaffUserCountOutputTypeCountUpdatedShipmentsArgs
    createdPayments?: boolean | StaffUserCountOutputTypeCountCreatedPaymentsArgs
    updatedPayments?: boolean | StaffUserCountOutputTypeCountUpdatedPaymentsArgs
    approvedQuotations?: boolean | StaffUserCountOutputTypeCountApprovedQuotationsArgs
    assignedTasks?: boolean | StaffUserCountOutputTypeCountAssignedTasksArgs
    loggedCommunications?: boolean | StaffUserCountOutputTypeCountLoggedCommunicationsArgs
    managedProjects?: boolean | StaffUserCountOutputTypeCountManagedProjectsArgs
    memberOfProjects?: boolean | StaffUserCountOutputTypeCountMemberOfProjectsArgs
  }

  // Custom InputTypes
  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUserCountOutputType
     */
    select?: StaffUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountCreatedOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountUpdatedOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountCreatedQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountUpdatedQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountCreatedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountUpdatedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountCreatedShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountUpdatedShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountCreatedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountUpdatedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountApprovedQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountLoggedCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountManagedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * StaffUserCountOutputType without action
   */
  export type StaffUserCountOutputTypeCountMemberOfProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    opportunities: number
    projects: number
    communications: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunities?: boolean | CustomerCountOutputTypeCountOpportunitiesArgs
    projects?: boolean | CustomerCountOutputTypeCountProjectsArgs
    communications?: boolean | CustomerCountOutputTypeCountCommunicationsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }


  /**
   * Count Type OpportunityCountOutputType
   */

  export type OpportunityCountOutputType = {
    quotations: number
    orders: number
    documents: number
    communications: number
  }

  export type OpportunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotations?: boolean | OpportunityCountOutputTypeCountQuotationsArgs
    orders?: boolean | OpportunityCountOutputTypeCountOrdersArgs
    documents?: boolean | OpportunityCountOutputTypeCountDocumentsArgs
    communications?: boolean | OpportunityCountOutputTypeCountCommunicationsArgs
  }

  // Custom InputTypes
  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityCountOutputType
     */
    select?: OpportunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    teamMembers: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMembers?: boolean | ProjectCountOutputTypeCountTeamMembersArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffUserWhereInput
  }


  /**
   * Count Type QuotationCountOutputType
   */

  export type QuotationCountOutputType = {
    items: number
    documents: number
    communications: number
  }

  export type QuotationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | QuotationCountOutputTypeCountItemsArgs
    documents?: boolean | QuotationCountOutputTypeCountDocumentsArgs
    communications?: boolean | QuotationCountOutputTypeCountCommunicationsArgs
  }

  // Custom InputTypes
  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotationCountOutputType
     */
    select?: QuotationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * QuotationCountOutputType without action
   */
  export type QuotationCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    shipments: number
    payments: number
    documents: number
    communications: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shipments?: boolean | OrderCountOutputTypeCountShipmentsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
    documents?: boolean | OrderCountOutputTypeCountDocumentsArgs
    communications?: boolean | OrderCountOutputTypeCountCommunicationsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    documents: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PurchaseOrderCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type ShipmentCountOutputType
   */

  export type ShipmentCountOutputType = {
    payments: number
    documents: number
  }

  export type ShipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | ShipmentCountOutputTypeCountPaymentsArgs
    documents?: boolean | ShipmentCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShipmentCountOutputType
     */
    select?: ShipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ShipmentCountOutputType without action
   */
  export type ShipmentCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    documents: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PaymentCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model StaffUser
   */

  export type AggregateStaffUser = {
    _count: StaffUserCountAggregateOutputType | null
    _min: StaffUserMinAggregateOutputType | null
    _max: StaffUserMaxAggregateOutputType | null
  }

  export type StaffUserMinAggregateOutputType = {
    staffId: string | null
    name: string | null
    email: string | null
    designation: string | null
    contactNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffUserMaxAggregateOutputType = {
    staffId: string | null
    name: string | null
    email: string | null
    designation: string | null
    contactNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffUserCountAggregateOutputType = {
    staffId: number
    name: number
    email: number
    designation: number
    contactNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffUserMinAggregateInputType = {
    staffId?: true
    name?: true
    email?: true
    designation?: true
    contactNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffUserMaxAggregateInputType = {
    staffId?: true
    name?: true
    email?: true
    designation?: true
    contactNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffUserCountAggregateInputType = {
    staffId?: true
    name?: true
    email?: true
    designation?: true
    contactNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffUser to aggregate.
     */
    where?: StaffUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffUsers to fetch.
     */
    orderBy?: StaffUserOrderByWithRelationInput | StaffUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffUsers
    **/
    _count?: true | StaffUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffUserMaxAggregateInputType
  }

  export type GetStaffUserAggregateType<T extends StaffUserAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffUser[P]>
      : GetScalarType<T[P], AggregateStaffUser[P]>
  }




  export type StaffUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffUserWhereInput
    orderBy?: StaffUserOrderByWithAggregationInput | StaffUserOrderByWithAggregationInput[]
    by: StaffUserScalarFieldEnum[] | StaffUserScalarFieldEnum
    having?: StaffUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffUserCountAggregateInputType | true
    _min?: StaffUserMinAggregateInputType
    _max?: StaffUserMaxAggregateInputType
  }

  export type StaffUserGroupByOutputType = {
    staffId: string
    name: string
    email: string
    designation: string
    contactNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: StaffUserCountAggregateOutputType | null
    _min: StaffUserMinAggregateOutputType | null
    _max: StaffUserMaxAggregateOutputType | null
  }

  type GetStaffUserGroupByPayload<T extends StaffUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffUserGroupByOutputType[P]>
            : GetScalarType<T[P], StaffUserGroupByOutputType[P]>
        }
      >
    >


  export type StaffUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staffId?: boolean
    name?: boolean
    email?: boolean
    designation?: boolean
    contactNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdOpportunities?: boolean | StaffUser$createdOpportunitiesArgs<ExtArgs>
    updatedOpportunities?: boolean | StaffUser$updatedOpportunitiesArgs<ExtArgs>
    createdQuotations?: boolean | StaffUser$createdQuotationsArgs<ExtArgs>
    updatedQuotations?: boolean | StaffUser$updatedQuotationsArgs<ExtArgs>
    createdOrders?: boolean | StaffUser$createdOrdersArgs<ExtArgs>
    updatedOrders?: boolean | StaffUser$updatedOrdersArgs<ExtArgs>
    createdShipments?: boolean | StaffUser$createdShipmentsArgs<ExtArgs>
    updatedShipments?: boolean | StaffUser$updatedShipmentsArgs<ExtArgs>
    createdPayments?: boolean | StaffUser$createdPaymentsArgs<ExtArgs>
    updatedPayments?: boolean | StaffUser$updatedPaymentsArgs<ExtArgs>
    approvedQuotations?: boolean | StaffUser$approvedQuotationsArgs<ExtArgs>
    assignedTasks?: boolean | StaffUser$assignedTasksArgs<ExtArgs>
    loggedCommunications?: boolean | StaffUser$loggedCommunicationsArgs<ExtArgs>
    managedProjects?: boolean | StaffUser$managedProjectsArgs<ExtArgs>
    memberOfProjects?: boolean | StaffUser$memberOfProjectsArgs<ExtArgs>
    _count?: boolean | StaffUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffUser"]>

  export type StaffUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staffId?: boolean
    name?: boolean
    email?: boolean
    designation?: boolean
    contactNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staffUser"]>

  export type StaffUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staffId?: boolean
    name?: boolean
    email?: boolean
    designation?: boolean
    contactNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staffUser"]>

  export type StaffUserSelectScalar = {
    staffId?: boolean
    name?: boolean
    email?: boolean
    designation?: boolean
    contactNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"staffId" | "name" | "email" | "designation" | "contactNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["staffUser"]>
  export type StaffUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdOpportunities?: boolean | StaffUser$createdOpportunitiesArgs<ExtArgs>
    updatedOpportunities?: boolean | StaffUser$updatedOpportunitiesArgs<ExtArgs>
    createdQuotations?: boolean | StaffUser$createdQuotationsArgs<ExtArgs>
    updatedQuotations?: boolean | StaffUser$updatedQuotationsArgs<ExtArgs>
    createdOrders?: boolean | StaffUser$createdOrdersArgs<ExtArgs>
    updatedOrders?: boolean | StaffUser$updatedOrdersArgs<ExtArgs>
    createdShipments?: boolean | StaffUser$createdShipmentsArgs<ExtArgs>
    updatedShipments?: boolean | StaffUser$updatedShipmentsArgs<ExtArgs>
    createdPayments?: boolean | StaffUser$createdPaymentsArgs<ExtArgs>
    updatedPayments?: boolean | StaffUser$updatedPaymentsArgs<ExtArgs>
    approvedQuotations?: boolean | StaffUser$approvedQuotationsArgs<ExtArgs>
    assignedTasks?: boolean | StaffUser$assignedTasksArgs<ExtArgs>
    loggedCommunications?: boolean | StaffUser$loggedCommunicationsArgs<ExtArgs>
    managedProjects?: boolean | StaffUser$managedProjectsArgs<ExtArgs>
    memberOfProjects?: boolean | StaffUser$memberOfProjectsArgs<ExtArgs>
    _count?: boolean | StaffUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StaffUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StaffUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffUser"
    objects: {
      createdOpportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      updatedOpportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      createdQuotations: Prisma.$QuotationPayload<ExtArgs>[]
      updatedQuotations: Prisma.$QuotationPayload<ExtArgs>[]
      createdOrders: Prisma.$OrderPayload<ExtArgs>[]
      updatedOrders: Prisma.$OrderPayload<ExtArgs>[]
      createdShipments: Prisma.$ShipmentPayload<ExtArgs>[]
      updatedShipments: Prisma.$ShipmentPayload<ExtArgs>[]
      createdPayments: Prisma.$PaymentPayload<ExtArgs>[]
      updatedPayments: Prisma.$PaymentPayload<ExtArgs>[]
      approvedQuotations: Prisma.$QuotationPayload<ExtArgs>[]
      assignedTasks: Prisma.$TaskPayload<ExtArgs>[]
      loggedCommunications: Prisma.$CommunicationPayload<ExtArgs>[]
      managedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      memberOfProjects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      staffId: string
      name: string
      email: string
      designation: string
      contactNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staffUser"]>
    composites: {}
  }

  type StaffUserGetPayload<S extends boolean | null | undefined | StaffUserDefaultArgs> = $Result.GetResult<Prisma.$StaffUserPayload, S>

  type StaffUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffUserCountAggregateInputType | true
    }

  export interface StaffUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffUser'], meta: { name: 'StaffUser' } }
    /**
     * Find zero or one StaffUser that matches the filter.
     * @param {StaffUserFindUniqueArgs} args - Arguments to find a StaffUser
     * @example
     * // Get one StaffUser
     * const staffUser = await prisma.staffUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffUserFindUniqueArgs>(args: SelectSubset<T, StaffUserFindUniqueArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffUserFindUniqueOrThrowArgs} args - Arguments to find a StaffUser
     * @example
     * // Get one StaffUser
     * const staffUser = await prisma.staffUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffUserFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserFindFirstArgs} args - Arguments to find a StaffUser
     * @example
     * // Get one StaffUser
     * const staffUser = await prisma.staffUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffUserFindFirstArgs>(args?: SelectSubset<T, StaffUserFindFirstArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserFindFirstOrThrowArgs} args - Arguments to find a StaffUser
     * @example
     * // Get one StaffUser
     * const staffUser = await prisma.staffUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffUserFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffUsers
     * const staffUsers = await prisma.staffUser.findMany()
     * 
     * // Get first 10 StaffUsers
     * const staffUsers = await prisma.staffUser.findMany({ take: 10 })
     * 
     * // Only select the `staffId`
     * const staffUserWithStaffIdOnly = await prisma.staffUser.findMany({ select: { staffId: true } })
     * 
     */
    findMany<T extends StaffUserFindManyArgs>(args?: SelectSubset<T, StaffUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffUser.
     * @param {StaffUserCreateArgs} args - Arguments to create a StaffUser.
     * @example
     * // Create one StaffUser
     * const StaffUser = await prisma.staffUser.create({
     *   data: {
     *     // ... data to create a StaffUser
     *   }
     * })
     * 
     */
    create<T extends StaffUserCreateArgs>(args: SelectSubset<T, StaffUserCreateArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffUsers.
     * @param {StaffUserCreateManyArgs} args - Arguments to create many StaffUsers.
     * @example
     * // Create many StaffUsers
     * const staffUser = await prisma.staffUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffUserCreateManyArgs>(args?: SelectSubset<T, StaffUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffUsers and returns the data saved in the database.
     * @param {StaffUserCreateManyAndReturnArgs} args - Arguments to create many StaffUsers.
     * @example
     * // Create many StaffUsers
     * const staffUser = await prisma.staffUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffUsers and only return the `staffId`
     * const staffUserWithStaffIdOnly = await prisma.staffUser.createManyAndReturn({
     *   select: { staffId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffUserCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffUser.
     * @param {StaffUserDeleteArgs} args - Arguments to delete one StaffUser.
     * @example
     * // Delete one StaffUser
     * const StaffUser = await prisma.staffUser.delete({
     *   where: {
     *     // ... filter to delete one StaffUser
     *   }
     * })
     * 
     */
    delete<T extends StaffUserDeleteArgs>(args: SelectSubset<T, StaffUserDeleteArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffUser.
     * @param {StaffUserUpdateArgs} args - Arguments to update one StaffUser.
     * @example
     * // Update one StaffUser
     * const staffUser = await prisma.staffUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUserUpdateArgs>(args: SelectSubset<T, StaffUserUpdateArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffUsers.
     * @param {StaffUserDeleteManyArgs} args - Arguments to filter StaffUsers to delete.
     * @example
     * // Delete a few StaffUsers
     * const { count } = await prisma.staffUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffUserDeleteManyArgs>(args?: SelectSubset<T, StaffUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffUsers
     * const staffUser = await prisma.staffUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUserUpdateManyArgs>(args: SelectSubset<T, StaffUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffUsers and returns the data updated in the database.
     * @param {StaffUserUpdateManyAndReturnArgs} args - Arguments to update many StaffUsers.
     * @example
     * // Update many StaffUsers
     * const staffUser = await prisma.staffUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffUsers and only return the `staffId`
     * const staffUserWithStaffIdOnly = await prisma.staffUser.updateManyAndReturn({
     *   select: { staffId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUserUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffUser.
     * @param {StaffUserUpsertArgs} args - Arguments to update or create a StaffUser.
     * @example
     * // Update or create a StaffUser
     * const staffUser = await prisma.staffUser.upsert({
     *   create: {
     *     // ... data to create a StaffUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffUser we want to update
     *   }
     * })
     */
    upsert<T extends StaffUserUpsertArgs>(args: SelectSubset<T, StaffUserUpsertArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserCountArgs} args - Arguments to filter StaffUsers to count.
     * @example
     * // Count the number of StaffUsers
     * const count = await prisma.staffUser.count({
     *   where: {
     *     // ... the filter for the StaffUsers we want to count
     *   }
     * })
    **/
    count<T extends StaffUserCountArgs>(
      args?: Subset<T, StaffUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffUserAggregateArgs>(args: Subset<T, StaffUserAggregateArgs>): Prisma.PrismaPromise<GetStaffUserAggregateType<T>>

    /**
     * Group by StaffUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffUserGroupByArgs['orderBy'] }
        : { orderBy?: StaffUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffUser model
   */
  readonly fields: StaffUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdOpportunities<T extends StaffUser$createdOpportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$createdOpportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedOpportunities<T extends StaffUser$updatedOpportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$updatedOpportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdQuotations<T extends StaffUser$createdQuotationsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$createdQuotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedQuotations<T extends StaffUser$updatedQuotationsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$updatedQuotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdOrders<T extends StaffUser$createdOrdersArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$createdOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedOrders<T extends StaffUser$updatedOrdersArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$updatedOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdShipments<T extends StaffUser$createdShipmentsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$createdShipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedShipments<T extends StaffUser$updatedShipmentsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$updatedShipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdPayments<T extends StaffUser$createdPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$createdPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedPayments<T extends StaffUser$updatedPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$updatedPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedQuotations<T extends StaffUser$approvedQuotationsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$approvedQuotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTasks<T extends StaffUser$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loggedCommunications<T extends StaffUser$loggedCommunicationsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$loggedCommunicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    managedProjects<T extends StaffUser$managedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$managedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberOfProjects<T extends StaffUser$memberOfProjectsArgs<ExtArgs> = {}>(args?: Subset<T, StaffUser$memberOfProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffUser model
   */
  interface StaffUserFieldRefs {
    readonly staffId: FieldRef<"StaffUser", 'String'>
    readonly name: FieldRef<"StaffUser", 'String'>
    readonly email: FieldRef<"StaffUser", 'String'>
    readonly designation: FieldRef<"StaffUser", 'String'>
    readonly contactNumber: FieldRef<"StaffUser", 'String'>
    readonly createdAt: FieldRef<"StaffUser", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffUser findUnique
   */
  export type StaffUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * Filter, which StaffUser to fetch.
     */
    where: StaffUserWhereUniqueInput
  }

  /**
   * StaffUser findUniqueOrThrow
   */
  export type StaffUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * Filter, which StaffUser to fetch.
     */
    where: StaffUserWhereUniqueInput
  }

  /**
   * StaffUser findFirst
   */
  export type StaffUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * Filter, which StaffUser to fetch.
     */
    where?: StaffUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffUsers to fetch.
     */
    orderBy?: StaffUserOrderByWithRelationInput | StaffUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffUsers.
     */
    cursor?: StaffUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffUsers.
     */
    distinct?: StaffUserScalarFieldEnum | StaffUserScalarFieldEnum[]
  }

  /**
   * StaffUser findFirstOrThrow
   */
  export type StaffUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * Filter, which StaffUser to fetch.
     */
    where?: StaffUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffUsers to fetch.
     */
    orderBy?: StaffUserOrderByWithRelationInput | StaffUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffUsers.
     */
    cursor?: StaffUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffUsers.
     */
    distinct?: StaffUserScalarFieldEnum | StaffUserScalarFieldEnum[]
  }

  /**
   * StaffUser findMany
   */
  export type StaffUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * Filter, which StaffUsers to fetch.
     */
    where?: StaffUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffUsers to fetch.
     */
    orderBy?: StaffUserOrderByWithRelationInput | StaffUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffUsers.
     */
    cursor?: StaffUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffUsers.
     */
    skip?: number
    distinct?: StaffUserScalarFieldEnum | StaffUserScalarFieldEnum[]
  }

  /**
   * StaffUser create
   */
  export type StaffUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffUser.
     */
    data: XOR<StaffUserCreateInput, StaffUserUncheckedCreateInput>
  }

  /**
   * StaffUser createMany
   */
  export type StaffUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffUsers.
     */
    data: StaffUserCreateManyInput | StaffUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffUser createManyAndReturn
   */
  export type StaffUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * The data used to create many StaffUsers.
     */
    data: StaffUserCreateManyInput | StaffUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffUser update
   */
  export type StaffUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffUser.
     */
    data: XOR<StaffUserUpdateInput, StaffUserUncheckedUpdateInput>
    /**
     * Choose, which StaffUser to update.
     */
    where: StaffUserWhereUniqueInput
  }

  /**
   * StaffUser updateMany
   */
  export type StaffUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffUsers.
     */
    data: XOR<StaffUserUpdateManyMutationInput, StaffUserUncheckedUpdateManyInput>
    /**
     * Filter which StaffUsers to update
     */
    where?: StaffUserWhereInput
    /**
     * Limit how many StaffUsers to update.
     */
    limit?: number
  }

  /**
   * StaffUser updateManyAndReturn
   */
  export type StaffUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * The data used to update StaffUsers.
     */
    data: XOR<StaffUserUpdateManyMutationInput, StaffUserUncheckedUpdateManyInput>
    /**
     * Filter which StaffUsers to update
     */
    where?: StaffUserWhereInput
    /**
     * Limit how many StaffUsers to update.
     */
    limit?: number
  }

  /**
   * StaffUser upsert
   */
  export type StaffUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffUser to update in case it exists.
     */
    where: StaffUserWhereUniqueInput
    /**
     * In case the StaffUser found by the `where` argument doesn't exist, create a new StaffUser with this data.
     */
    create: XOR<StaffUserCreateInput, StaffUserUncheckedCreateInput>
    /**
     * In case the StaffUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUserUpdateInput, StaffUserUncheckedUpdateInput>
  }

  /**
   * StaffUser delete
   */
  export type StaffUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    /**
     * Filter which StaffUser to delete.
     */
    where: StaffUserWhereUniqueInput
  }

  /**
   * StaffUser deleteMany
   */
  export type StaffUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffUsers to delete
     */
    where?: StaffUserWhereInput
    /**
     * Limit how many StaffUsers to delete.
     */
    limit?: number
  }

  /**
   * StaffUser.createdOpportunities
   */
  export type StaffUser$createdOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * StaffUser.updatedOpportunities
   */
  export type StaffUser$updatedOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * StaffUser.createdQuotations
   */
  export type StaffUser$createdQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * StaffUser.updatedQuotations
   */
  export type StaffUser$updatedQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * StaffUser.createdOrders
   */
  export type StaffUser$createdOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * StaffUser.updatedOrders
   */
  export type StaffUser$updatedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * StaffUser.createdShipments
   */
  export type StaffUser$createdShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * StaffUser.updatedShipments
   */
  export type StaffUser$updatedShipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * StaffUser.createdPayments
   */
  export type StaffUser$createdPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * StaffUser.updatedPayments
   */
  export type StaffUser$updatedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * StaffUser.approvedQuotations
   */
  export type StaffUser$approvedQuotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * StaffUser.assignedTasks
   */
  export type StaffUser$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * StaffUser.loggedCommunications
   */
  export type StaffUser$loggedCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * StaffUser.managedProjects
   */
  export type StaffUser$managedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * StaffUser.memberOfProjects
   */
  export type StaffUser$memberOfProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * StaffUser without action
   */
  export type StaffUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedUserId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedUserId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    dueDate: number
    createdAt: number
    updatedAt: number
    assignedUserId: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    assignedUserId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    assignedUserId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    assignedUserId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.TaskStatus
    dueDate: Date | null
    createdAt: Date
    updatedAt: Date
    assignedUserId: string | null
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUserId?: boolean
    assignedUser?: boolean | Task$assignedUserArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUserId?: boolean
    assignedUser?: boolean | Task$assignedUserArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUserId?: boolean
    assignedUser?: boolean | Task$assignedUserArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUserId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "dueDate" | "createdAt" | "updatedAt" | "assignedUserId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUser?: boolean | Task$assignedUserArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUser?: boolean | Task$assignedUserArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedUser?: boolean | Task$assignedUserArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      assignedUser: Prisma.$StaffUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.TaskStatus
      dueDate: Date | null
      createdAt: Date
      updatedAt: Date
      assignedUserId: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedUser<T extends Task$assignedUserArgs<ExtArgs> = {}>(args?: Subset<T, Task$assignedUserArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly assignedUserId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.assignedUser
   */
  export type Task$assignedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    where?: StaffUserWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    cid: string | null
    customerType: string | null
    businessName: string | null
    salutation: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    address: string | null
    currency: $Enums.Currency | null
    gstin: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    cid: string | null
    customerType: string | null
    businessName: string | null
    salutation: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    address: string | null
    currency: $Enums.Currency | null
    gstin: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    cid: number
    customerType: number
    businessName: number
    salutation: number
    firstName: number
    lastName: number
    phone: number
    email: number
    address: number
    currency: number
    gstin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    cid?: true
    customerType?: true
    businessName?: true
    salutation?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    currency?: true
    gstin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    cid?: true
    customerType?: true
    businessName?: true
    salutation?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    currency?: true
    gstin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    cid?: true
    customerType?: true
    businessName?: true
    salutation?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    currency?: true
    gstin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    cid: string
    customerType: string
    businessName: string
    salutation: string | null
    firstName: string
    lastName: string
    phone: string | null
    email: string | null
    address: string | null
    currency: $Enums.Currency
    gstin: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cid?: boolean
    customerType?: boolean
    businessName?: boolean
    salutation?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    currency?: boolean
    gstin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunities?: boolean | Customer$opportunitiesArgs<ExtArgs>
    projects?: boolean | Customer$projectsArgs<ExtArgs>
    communications?: boolean | Customer$communicationsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cid?: boolean
    customerType?: boolean
    businessName?: boolean
    salutation?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    currency?: boolean
    gstin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cid?: boolean
    customerType?: boolean
    businessName?: boolean
    salutation?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    currency?: boolean
    gstin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    cid?: boolean
    customerType?: boolean
    businessName?: boolean
    salutation?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    currency?: boolean
    gstin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cid" | "customerType" | "businessName" | "salutation" | "firstName" | "lastName" | "phone" | "email" | "address" | "currency" | "gstin" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunities?: boolean | Customer$opportunitiesArgs<ExtArgs>
    projects?: boolean | Customer$projectsArgs<ExtArgs>
    communications?: boolean | Customer$communicationsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cid: string
      customerType: string
      businessName: string
      salutation: string | null
      firstName: string
      lastName: string
      phone: string | null
      email: string | null
      address: string | null
      currency: $Enums.Currency
      gstin: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunities<T extends Customer$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Customer$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communications<T extends Customer$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly cid: FieldRef<"Customer", 'String'>
    readonly customerType: FieldRef<"Customer", 'String'>
    readonly businessName: FieldRef<"Customer", 'String'>
    readonly salutation: FieldRef<"Customer", 'String'>
    readonly firstName: FieldRef<"Customer", 'String'>
    readonly lastName: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly currency: FieldRef<"Customer", 'Currency'>
    readonly gstin: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.opportunities
   */
  export type Customer$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Customer.projects
   */
  export type Customer$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Customer.communications
   */
  export type Customer$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Opportunity
   */

  export type AggregateOpportunity = {
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  export type OpportunityAvgAggregateOutputType = {
    value: number | null
  }

  export type OpportunitySumAggregateOutputType = {
    value: number | null
  }

  export type OpportunityMinAggregateOutputType = {
    id: string | null
    oppRef: string | null
    title: string | null
    status: $Enums.OpportunityStatus | null
    value: number | null
    currency: $Enums.Currency | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
    createdById: string | null
    updatedById: string | null
  }

  export type OpportunityMaxAggregateOutputType = {
    id: string | null
    oppRef: string | null
    title: string | null
    status: $Enums.OpportunityStatus | null
    value: number | null
    currency: $Enums.Currency | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
    createdById: string | null
    updatedById: string | null
  }

  export type OpportunityCountAggregateOutputType = {
    id: number
    oppRef: number
    title: number
    status: number
    value: number
    currency: number
    description: number
    createdAt: number
    updatedAt: number
    customerId: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type OpportunityAvgAggregateInputType = {
    value?: true
  }

  export type OpportunitySumAggregateInputType = {
    value?: true
  }

  export type OpportunityMinAggregateInputType = {
    id?: true
    oppRef?: true
    title?: true
    status?: true
    value?: true
    currency?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    createdById?: true
    updatedById?: true
  }

  export type OpportunityMaxAggregateInputType = {
    id?: true
    oppRef?: true
    title?: true
    status?: true
    value?: true
    currency?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    createdById?: true
    updatedById?: true
  }

  export type OpportunityCountAggregateInputType = {
    id?: true
    oppRef?: true
    title?: true
    status?: true
    value?: true
    currency?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type OpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunity to aggregate.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Opportunities
    **/
    _count?: true | OpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityMaxAggregateInputType
  }

  export type GetOpportunityAggregateType<T extends OpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunity[P]>
      : GetScalarType<T[P], AggregateOpportunity[P]>
  }




  export type OpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithAggregationInput | OpportunityOrderByWithAggregationInput[]
    by: OpportunityScalarFieldEnum[] | OpportunityScalarFieldEnum
    having?: OpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityCountAggregateInputType | true
    _avg?: OpportunityAvgAggregateInputType
    _sum?: OpportunitySumAggregateInputType
    _min?: OpportunityMinAggregateInputType
    _max?: OpportunityMaxAggregateInputType
  }

  export type OpportunityGroupByOutputType = {
    id: string
    oppRef: string
    title: string
    status: $Enums.OpportunityStatus
    value: number
    currency: $Enums.Currency
    description: string | null
    createdAt: Date
    updatedAt: Date
    customerId: string
    createdById: string
    updatedById: string
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  type GetOpportunityGroupByPayload<T extends OpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    oppRef?: boolean
    title?: boolean
    status?: boolean
    value?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    createdById?: boolean
    updatedById?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    quotations?: boolean | Opportunity$quotationsArgs<ExtArgs>
    orders?: boolean | Opportunity$ordersArgs<ExtArgs>
    documents?: boolean | Opportunity$documentsArgs<ExtArgs>
    communications?: boolean | Opportunity$communicationsArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    oppRef?: boolean
    title?: boolean
    status?: boolean
    value?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    createdById?: boolean
    updatedById?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    oppRef?: boolean
    title?: boolean
    status?: boolean
    value?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    createdById?: boolean
    updatedById?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectScalar = {
    id?: boolean
    oppRef?: boolean
    title?: boolean
    status?: boolean
    value?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type OpportunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "oppRef" | "title" | "status" | "value" | "currency" | "description" | "createdAt" | "updatedAt" | "customerId" | "createdById" | "updatedById", ExtArgs["result"]["opportunity"]>
  export type OpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    quotations?: boolean | Opportunity$quotationsArgs<ExtArgs>
    orders?: boolean | Opportunity$ordersArgs<ExtArgs>
    documents?: boolean | Opportunity$documentsArgs<ExtArgs>
    communications?: boolean | Opportunity$communicationsArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
  }

  export type $OpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Opportunity"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      createdBy: Prisma.$StaffUserPayload<ExtArgs>
      updatedBy: Prisma.$StaffUserPayload<ExtArgs>
      quotations: Prisma.$QuotationPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      oppRef: string
      title: string
      status: $Enums.OpportunityStatus
      value: number
      currency: $Enums.Currency
      description: string | null
      createdAt: Date
      updatedAt: Date
      customerId: string
      createdById: string
      updatedById: string
    }, ExtArgs["result"]["opportunity"]>
    composites: {}
  }

  type OpportunityGetPayload<S extends boolean | null | undefined | OpportunityDefaultArgs> = $Result.GetResult<Prisma.$OpportunityPayload, S>

  type OpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpportunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpportunityCountAggregateInputType | true
    }

  export interface OpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Opportunity'], meta: { name: 'Opportunity' } }
    /**
     * Find zero or one Opportunity that matches the filter.
     * @param {OpportunityFindUniqueArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityFindUniqueArgs>(args: SelectSubset<T, OpportunityFindUniqueArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Opportunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpportunityFindUniqueOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Opportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityFindFirstArgs>(args?: SelectSubset<T, OpportunityFindFirstArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Opportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Opportunities
     * const opportunities = await prisma.opportunity.findMany()
     * 
     * // Get first 10 Opportunities
     * const opportunities = await prisma.opportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityFindManyArgs>(args?: SelectSubset<T, OpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Opportunity.
     * @param {OpportunityCreateArgs} args - Arguments to create a Opportunity.
     * @example
     * // Create one Opportunity
     * const Opportunity = await prisma.opportunity.create({
     *   data: {
     *     // ... data to create a Opportunity
     *   }
     * })
     * 
     */
    create<T extends OpportunityCreateArgs>(args: SelectSubset<T, OpportunityCreateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Opportunities.
     * @param {OpportunityCreateManyArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityCreateManyArgs>(args?: SelectSubset<T, OpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Opportunities and returns the data saved in the database.
     * @param {OpportunityCreateManyAndReturnArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Opportunity.
     * @param {OpportunityDeleteArgs} args - Arguments to delete one Opportunity.
     * @example
     * // Delete one Opportunity
     * const Opportunity = await prisma.opportunity.delete({
     *   where: {
     *     // ... filter to delete one Opportunity
     *   }
     * })
     * 
     */
    delete<T extends OpportunityDeleteArgs>(args: SelectSubset<T, OpportunityDeleteArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Opportunity.
     * @param {OpportunityUpdateArgs} args - Arguments to update one Opportunity.
     * @example
     * // Update one Opportunity
     * const opportunity = await prisma.opportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityUpdateArgs>(args: SelectSubset<T, OpportunityUpdateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Opportunities.
     * @param {OpportunityDeleteManyArgs} args - Arguments to filter Opportunities to delete.
     * @example
     * // Delete a few Opportunities
     * const { count } = await prisma.opportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityDeleteManyArgs>(args?: SelectSubset<T, OpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityUpdateManyArgs>(args: SelectSubset<T, OpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities and returns the data updated in the database.
     * @param {OpportunityUpdateManyAndReturnArgs} args - Arguments to update many Opportunities.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpportunityUpdateManyAndReturnArgs>(args: SelectSubset<T, OpportunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Opportunity.
     * @param {OpportunityUpsertArgs} args - Arguments to update or create a Opportunity.
     * @example
     * // Update or create a Opportunity
     * const opportunity = await prisma.opportunity.upsert({
     *   create: {
     *     // ... data to create a Opportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Opportunity we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityUpsertArgs>(args: SelectSubset<T, OpportunityUpsertArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityCountArgs} args - Arguments to filter Opportunities to count.
     * @example
     * // Count the number of Opportunities
     * const count = await prisma.opportunity.count({
     *   where: {
     *     // ... the filter for the Opportunities we want to count
     *   }
     * })
    **/
    count<T extends OpportunityCountArgs>(
      args?: Subset<T, OpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityAggregateArgs>(args: Subset<T, OpportunityAggregateArgs>): Prisma.PrismaPromise<GetOpportunityAggregateType<T>>

    /**
     * Group by Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Opportunity model
   */
  readonly fields: OpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Opportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quotations<T extends Opportunity$quotationsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$quotationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Opportunity$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Opportunity$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communications<T extends Opportunity$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Opportunity model
   */
  interface OpportunityFieldRefs {
    readonly id: FieldRef<"Opportunity", 'String'>
    readonly oppRef: FieldRef<"Opportunity", 'String'>
    readonly title: FieldRef<"Opportunity", 'String'>
    readonly status: FieldRef<"Opportunity", 'OpportunityStatus'>
    readonly value: FieldRef<"Opportunity", 'Float'>
    readonly currency: FieldRef<"Opportunity", 'Currency'>
    readonly description: FieldRef<"Opportunity", 'String'>
    readonly createdAt: FieldRef<"Opportunity", 'DateTime'>
    readonly updatedAt: FieldRef<"Opportunity", 'DateTime'>
    readonly customerId: FieldRef<"Opportunity", 'String'>
    readonly createdById: FieldRef<"Opportunity", 'String'>
    readonly updatedById: FieldRef<"Opportunity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Opportunity findUnique
   */
  export type OpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findUniqueOrThrow
   */
  export type OpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity findFirst
   */
  export type OpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findFirstOrThrow
   */
  export type OpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity findMany
   */
  export type OpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunities to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Opportunity create
   */
  export type OpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Opportunity.
     */
    data: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
  }

  /**
   * Opportunity createMany
   */
  export type OpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity createManyAndReturn
   */
  export type OpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity update
   */
  export type OpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Opportunity.
     */
    data: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    /**
     * Choose, which Opportunity to update.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity updateMany
   */
  export type OpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
  }

  /**
   * Opportunity updateManyAndReturn
   */
  export type OpportunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity upsert
   */
  export type OpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Opportunity to update in case it exists.
     */
    where: OpportunityWhereUniqueInput
    /**
     * In case the Opportunity found by the `where` argument doesn't exist, create a new Opportunity with this data.
     */
    create: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    /**
     * In case the Opportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
  }

  /**
   * Opportunity delete
   */
  export type OpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter which Opportunity to delete.
     */
    where: OpportunityWhereUniqueInput
  }

  /**
   * Opportunity deleteMany
   */
  export type OpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunities to delete
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to delete.
     */
    limit?: number
  }

  /**
   * Opportunity.quotations
   */
  export type Opportunity$quotationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    cursor?: QuotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Opportunity.orders
   */
  export type Opportunity$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Opportunity.documents
   */
  export type Opportunity$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Opportunity.communications
   */
  export type Opportunity$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Opportunity without action
   */
  export type OpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
    projectManagerId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
    projectManagerId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    customerId: number
    projectManagerId: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    projectManagerId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    projectManagerId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    projectManagerId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.ProjectStatus
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    customerId: string
    projectManagerId: string | null
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    projectManagerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
    teamMembers?: boolean | Project$teamMembersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    projectManagerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    projectManagerId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    projectManagerId?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "customerId" | "projectManagerId", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
    teamMembers?: boolean | Project$teamMembersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      projectManager: Prisma.$StaffUserPayload<ExtArgs> | null
      teamMembers: Prisma.$StaffUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.ProjectStatus
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      customerId: string
      projectManagerId: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectManager<T extends Project$projectManagerArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectManagerArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teamMembers<T extends Project$teamMembersArgs<ExtArgs> = {}>(args?: Subset<T, Project$teamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly customerId: FieldRef<"Project", 'String'>
    readonly projectManagerId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.projectManager
   */
  export type Project$projectManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    where?: StaffUserWhereInput
  }

  /**
   * Project.teamMembers
   */
  export type Project$teamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    where?: StaffUserWhereInput
    orderBy?: StaffUserOrderByWithRelationInput | StaffUserOrderByWithRelationInput[]
    cursor?: StaffUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffUserScalarFieldEnum | StaffUserScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Quotation
   */

  export type AggregateQuotation = {
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  export type QuotationAvgAggregateOutputType = {
    revision: number | null
    fxRate: number | null
    totalCost: number | null
    markupPercent: number | null
    insurancePercent: number | null
    financeCharge: number | null
    subtotal: number | null
    vatPercent: number | null
    totalWithVAT: number | null
    profitMarginBHD: number | null
    fxGain: number | null
  }

  export type QuotationSumAggregateOutputType = {
    revision: number | null
    fxRate: number | null
    totalCost: number | null
    markupPercent: number | null
    insurancePercent: number | null
    financeCharge: number | null
    subtotal: number | null
    vatPercent: number | null
    totalWithVAT: number | null
    profitMarginBHD: number | null
    fxGain: number | null
  }

  export type QuotationMinAggregateOutputType = {
    id: string | null
    quoteRef: string | null
    revision: number | null
    status: $Enums.QuotationStatus | null
    currency: $Enums.Currency | null
    fxRate: number | null
    totalCost: number | null
    markupPercent: number | null
    insurancePercent: number | null
    financeCharge: number | null
    subtotal: number | null
    vatPercent: number | null
    totalWithVAT: number | null
    profitMarginBHD: number | null
    fxGain: number | null
    validUntil: Date | null
    paymentTerms: string | null
    deliveryTerms: string | null
    expectedDeliveryDate: Date | null
    marginApprovalPopup: boolean | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    opportunityId: string | null
  }

  export type QuotationMaxAggregateOutputType = {
    id: string | null
    quoteRef: string | null
    revision: number | null
    status: $Enums.QuotationStatus | null
    currency: $Enums.Currency | null
    fxRate: number | null
    totalCost: number | null
    markupPercent: number | null
    insurancePercent: number | null
    financeCharge: number | null
    subtotal: number | null
    vatPercent: number | null
    totalWithVAT: number | null
    profitMarginBHD: number | null
    fxGain: number | null
    validUntil: Date | null
    paymentTerms: string | null
    deliveryTerms: string | null
    expectedDeliveryDate: Date | null
    marginApprovalPopup: boolean | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    opportunityId: string | null
  }

  export type QuotationCountAggregateOutputType = {
    id: number
    quoteRef: number
    revision: number
    status: number
    currency: number
    fxRate: number
    totalCost: number
    markupPercent: number
    insurancePercent: number
    financeCharge: number
    subtotal: number
    vatPercent: number
    totalWithVAT: number
    profitMarginBHD: number
    fxGain: number
    validUntil: number
    paymentTerms: number
    deliveryTerms: number
    expectedDeliveryDate: number
    marginApprovalPopup: number
    approvedById: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    opportunityId: number
    _all: number
  }


  export type QuotationAvgAggregateInputType = {
    revision?: true
    fxRate?: true
    totalCost?: true
    markupPercent?: true
    insurancePercent?: true
    financeCharge?: true
    subtotal?: true
    vatPercent?: true
    totalWithVAT?: true
    profitMarginBHD?: true
    fxGain?: true
  }

  export type QuotationSumAggregateInputType = {
    revision?: true
    fxRate?: true
    totalCost?: true
    markupPercent?: true
    insurancePercent?: true
    financeCharge?: true
    subtotal?: true
    vatPercent?: true
    totalWithVAT?: true
    profitMarginBHD?: true
    fxGain?: true
  }

  export type QuotationMinAggregateInputType = {
    id?: true
    quoteRef?: true
    revision?: true
    status?: true
    currency?: true
    fxRate?: true
    totalCost?: true
    markupPercent?: true
    insurancePercent?: true
    financeCharge?: true
    subtotal?: true
    vatPercent?: true
    totalWithVAT?: true
    profitMarginBHD?: true
    fxGain?: true
    validUntil?: true
    paymentTerms?: true
    deliveryTerms?: true
    expectedDeliveryDate?: true
    marginApprovalPopup?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    opportunityId?: true
  }

  export type QuotationMaxAggregateInputType = {
    id?: true
    quoteRef?: true
    revision?: true
    status?: true
    currency?: true
    fxRate?: true
    totalCost?: true
    markupPercent?: true
    insurancePercent?: true
    financeCharge?: true
    subtotal?: true
    vatPercent?: true
    totalWithVAT?: true
    profitMarginBHD?: true
    fxGain?: true
    validUntil?: true
    paymentTerms?: true
    deliveryTerms?: true
    expectedDeliveryDate?: true
    marginApprovalPopup?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    opportunityId?: true
  }

  export type QuotationCountAggregateInputType = {
    id?: true
    quoteRef?: true
    revision?: true
    status?: true
    currency?: true
    fxRate?: true
    totalCost?: true
    markupPercent?: true
    insurancePercent?: true
    financeCharge?: true
    subtotal?: true
    vatPercent?: true
    totalWithVAT?: true
    profitMarginBHD?: true
    fxGain?: true
    validUntil?: true
    paymentTerms?: true
    deliveryTerms?: true
    expectedDeliveryDate?: true
    marginApprovalPopup?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    opportunityId?: true
    _all?: true
  }

  export type QuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotation to aggregate.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotations
    **/
    _count?: true | QuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationMaxAggregateInputType
  }

  export type GetQuotationAggregateType<T extends QuotationAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotation[P]>
      : GetScalarType<T[P], AggregateQuotation[P]>
  }




  export type QuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithAggregationInput | QuotationOrderByWithAggregationInput[]
    by: QuotationScalarFieldEnum[] | QuotationScalarFieldEnum
    having?: QuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationCountAggregateInputType | true
    _avg?: QuotationAvgAggregateInputType
    _sum?: QuotationSumAggregateInputType
    _min?: QuotationMinAggregateInputType
    _max?: QuotationMaxAggregateInputType
  }

  export type QuotationGroupByOutputType = {
    id: string
    quoteRef: string
    revision: number
    status: $Enums.QuotationStatus
    currency: $Enums.Currency
    fxRate: number
    totalCost: number
    markupPercent: number
    insurancePercent: number
    financeCharge: number
    subtotal: number
    vatPercent: number
    totalWithVAT: number
    profitMarginBHD: number
    fxGain: number | null
    validUntil: Date
    paymentTerms: string | null
    deliveryTerms: string | null
    expectedDeliveryDate: Date | null
    marginApprovalPopup: boolean
    approvedById: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    updatedById: string
    opportunityId: string
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  type GetQuotationGroupByPayload<T extends QuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationGroupByOutputType[P]>
        }
      >
    >


  export type QuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteRef?: boolean
    revision?: boolean
    status?: boolean
    currency?: boolean
    fxRate?: boolean
    totalCost?: boolean
    markupPercent?: boolean
    insurancePercent?: boolean
    financeCharge?: boolean
    subtotal?: boolean
    vatPercent?: boolean
    totalWithVAT?: boolean
    profitMarginBHD?: boolean
    fxGain?: boolean
    validUntil?: boolean
    paymentTerms?: boolean
    deliveryTerms?: boolean
    expectedDeliveryDate?: boolean
    marginApprovalPopup?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    opportunityId?: boolean
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    items?: boolean | Quotation$itemsArgs<ExtArgs>
    order?: boolean | Quotation$orderArgs<ExtArgs>
    documents?: boolean | Quotation$documentsArgs<ExtArgs>
    communications?: boolean | Quotation$communicationsArgs<ExtArgs>
    _count?: boolean | QuotationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteRef?: boolean
    revision?: boolean
    status?: boolean
    currency?: boolean
    fxRate?: boolean
    totalCost?: boolean
    markupPercent?: boolean
    insurancePercent?: boolean
    financeCharge?: boolean
    subtotal?: boolean
    vatPercent?: boolean
    totalWithVAT?: boolean
    profitMarginBHD?: boolean
    fxGain?: boolean
    validUntil?: boolean
    paymentTerms?: boolean
    deliveryTerms?: boolean
    expectedDeliveryDate?: boolean
    marginApprovalPopup?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    opportunityId?: boolean
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quoteRef?: boolean
    revision?: boolean
    status?: boolean
    currency?: boolean
    fxRate?: boolean
    totalCost?: boolean
    markupPercent?: boolean
    insurancePercent?: boolean
    financeCharge?: boolean
    subtotal?: boolean
    vatPercent?: boolean
    totalWithVAT?: boolean
    profitMarginBHD?: boolean
    fxGain?: boolean
    validUntil?: boolean
    paymentTerms?: boolean
    deliveryTerms?: boolean
    expectedDeliveryDate?: boolean
    marginApprovalPopup?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    opportunityId?: boolean
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectScalar = {
    id?: boolean
    quoteRef?: boolean
    revision?: boolean
    status?: boolean
    currency?: boolean
    fxRate?: boolean
    totalCost?: boolean
    markupPercent?: boolean
    insurancePercent?: boolean
    financeCharge?: boolean
    subtotal?: boolean
    vatPercent?: boolean
    totalWithVAT?: boolean
    profitMarginBHD?: boolean
    fxGain?: boolean
    validUntil?: boolean
    paymentTerms?: boolean
    deliveryTerms?: boolean
    expectedDeliveryDate?: boolean
    marginApprovalPopup?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    opportunityId?: boolean
  }

  export type QuotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quoteRef" | "revision" | "status" | "currency" | "fxRate" | "totalCost" | "markupPercent" | "insurancePercent" | "financeCharge" | "subtotal" | "vatPercent" | "totalWithVAT" | "profitMarginBHD" | "fxGain" | "validUntil" | "paymentTerms" | "deliveryTerms" | "expectedDeliveryDate" | "marginApprovalPopup" | "approvedById" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "opportunityId", ExtArgs["result"]["quotation"]>
  export type QuotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    items?: boolean | Quotation$itemsArgs<ExtArgs>
    order?: boolean | Quotation$orderArgs<ExtArgs>
    documents?: boolean | Quotation$documentsArgs<ExtArgs>
    communications?: boolean | Quotation$communicationsArgs<ExtArgs>
    _count?: boolean | QuotationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type QuotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvedBy?: boolean | Quotation$approvedByArgs<ExtArgs>
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $QuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quotation"
    objects: {
      approvedBy: Prisma.$StaffUserPayload<ExtArgs> | null
      createdBy: Prisma.$StaffUserPayload<ExtArgs>
      updatedBy: Prisma.$StaffUserPayload<ExtArgs>
      opportunity: Prisma.$OpportunityPayload<ExtArgs>
      items: Prisma.$QuoteItemPayload<ExtArgs>[]
      order: Prisma.$OrderPayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quoteRef: string
      revision: number
      status: $Enums.QuotationStatus
      currency: $Enums.Currency
      fxRate: number
      totalCost: number
      markupPercent: number
      insurancePercent: number
      financeCharge: number
      subtotal: number
      vatPercent: number
      totalWithVAT: number
      profitMarginBHD: number
      fxGain: number | null
      validUntil: Date
      paymentTerms: string | null
      deliveryTerms: string | null
      expectedDeliveryDate: Date | null
      marginApprovalPopup: boolean
      approvedById: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string
      updatedById: string
      opportunityId: string
    }, ExtArgs["result"]["quotation"]>
    composites: {}
  }

  type QuotationGetPayload<S extends boolean | null | undefined | QuotationDefaultArgs> = $Result.GetResult<Prisma.$QuotationPayload, S>

  type QuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationCountAggregateInputType | true
    }

  export interface QuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quotation'], meta: { name: 'Quotation' } }
    /**
     * Find zero or one Quotation that matches the filter.
     * @param {QuotationFindUniqueArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationFindUniqueArgs>(args: SelectSubset<T, QuotationFindUniqueArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationFindUniqueOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationFindFirstArgs>(args?: SelectSubset<T, QuotationFindFirstArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotations
     * const quotations = await prisma.quotation.findMany()
     * 
     * // Get first 10 Quotations
     * const quotations = await prisma.quotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationWithIdOnly = await prisma.quotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationFindManyArgs>(args?: SelectSubset<T, QuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quotation.
     * @param {QuotationCreateArgs} args - Arguments to create a Quotation.
     * @example
     * // Create one Quotation
     * const Quotation = await prisma.quotation.create({
     *   data: {
     *     // ... data to create a Quotation
     *   }
     * })
     * 
     */
    create<T extends QuotationCreateArgs>(args: SelectSubset<T, QuotationCreateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotations.
     * @param {QuotationCreateManyArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationCreateManyArgs>(args?: SelectSubset<T, QuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotations and returns the data saved in the database.
     * @param {QuotationCreateManyAndReturnArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quotation.
     * @param {QuotationDeleteArgs} args - Arguments to delete one Quotation.
     * @example
     * // Delete one Quotation
     * const Quotation = await prisma.quotation.delete({
     *   where: {
     *     // ... filter to delete one Quotation
     *   }
     * })
     * 
     */
    delete<T extends QuotationDeleteArgs>(args: SelectSubset<T, QuotationDeleteArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quotation.
     * @param {QuotationUpdateArgs} args - Arguments to update one Quotation.
     * @example
     * // Update one Quotation
     * const quotation = await prisma.quotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationUpdateArgs>(args: SelectSubset<T, QuotationUpdateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotations.
     * @param {QuotationDeleteManyArgs} args - Arguments to filter Quotations to delete.
     * @example
     * // Delete a few Quotations
     * const { count } = await prisma.quotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationDeleteManyArgs>(args?: SelectSubset<T, QuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationUpdateManyArgs>(args: SelectSubset<T, QuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations and returns the data updated in the database.
     * @param {QuotationUpdateManyAndReturnArgs} args - Arguments to update many Quotations.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotationUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quotation.
     * @param {QuotationUpsertArgs} args - Arguments to update or create a Quotation.
     * @example
     * // Update or create a Quotation
     * const quotation = await prisma.quotation.upsert({
     *   create: {
     *     // ... data to create a Quotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation we want to update
     *   }
     * })
     */
    upsert<T extends QuotationUpsertArgs>(args: SelectSubset<T, QuotationUpsertArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationCountArgs} args - Arguments to filter Quotations to count.
     * @example
     * // Count the number of Quotations
     * const count = await prisma.quotation.count({
     *   where: {
     *     // ... the filter for the Quotations we want to count
     *   }
     * })
    **/
    count<T extends QuotationCountArgs>(
      args?: Subset<T, QuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationAggregateArgs>(args: Subset<T, QuotationAggregateArgs>): Prisma.PrismaPromise<GetQuotationAggregateType<T>>

    /**
     * Group by Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationGroupByArgs['orderBy'] }
        : { orderBy?: QuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quotation model
   */
  readonly fields: QuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approvedBy<T extends Quotation$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$approvedByArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Quotation$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    order<T extends Quotation$orderArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends Quotation$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communications<T extends Quotation$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, Quotation$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quotation model
   */
  interface QuotationFieldRefs {
    readonly id: FieldRef<"Quotation", 'String'>
    readonly quoteRef: FieldRef<"Quotation", 'String'>
    readonly revision: FieldRef<"Quotation", 'Int'>
    readonly status: FieldRef<"Quotation", 'QuotationStatus'>
    readonly currency: FieldRef<"Quotation", 'Currency'>
    readonly fxRate: FieldRef<"Quotation", 'Float'>
    readonly totalCost: FieldRef<"Quotation", 'Float'>
    readonly markupPercent: FieldRef<"Quotation", 'Float'>
    readonly insurancePercent: FieldRef<"Quotation", 'Float'>
    readonly financeCharge: FieldRef<"Quotation", 'Float'>
    readonly subtotal: FieldRef<"Quotation", 'Float'>
    readonly vatPercent: FieldRef<"Quotation", 'Float'>
    readonly totalWithVAT: FieldRef<"Quotation", 'Float'>
    readonly profitMarginBHD: FieldRef<"Quotation", 'Float'>
    readonly fxGain: FieldRef<"Quotation", 'Float'>
    readonly validUntil: FieldRef<"Quotation", 'DateTime'>
    readonly paymentTerms: FieldRef<"Quotation", 'String'>
    readonly deliveryTerms: FieldRef<"Quotation", 'String'>
    readonly expectedDeliveryDate: FieldRef<"Quotation", 'DateTime'>
    readonly marginApprovalPopup: FieldRef<"Quotation", 'Boolean'>
    readonly approvedById: FieldRef<"Quotation", 'String'>
    readonly createdAt: FieldRef<"Quotation", 'DateTime'>
    readonly updatedAt: FieldRef<"Quotation", 'DateTime'>
    readonly createdById: FieldRef<"Quotation", 'String'>
    readonly updatedById: FieldRef<"Quotation", 'String'>
    readonly opportunityId: FieldRef<"Quotation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Quotation findUnique
   */
  export type QuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findUniqueOrThrow
   */
  export type QuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findFirst
   */
  export type QuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findFirstOrThrow
   */
  export type QuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findMany
   */
  export type QuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotations to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation create
   */
  export type QuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to create a Quotation.
     */
    data: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
  }

  /**
   * Quotation createMany
   */
  export type QuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quotation createManyAndReturn
   */
  export type QuotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation update
   */
  export type QuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to update a Quotation.
     */
    data: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
    /**
     * Choose, which Quotation to update.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation updateMany
   */
  export type QuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
  }

  /**
   * Quotation updateManyAndReturn
   */
  export type QuotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation upsert
   */
  export type QuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The filter to search for the Quotation to update in case it exists.
     */
    where: QuotationWhereUniqueInput
    /**
     * In case the Quotation found by the `where` argument doesn't exist, create a new Quotation with this data.
     */
    create: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
    /**
     * In case the Quotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
  }

  /**
   * Quotation delete
   */
  export type QuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter which Quotation to delete.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation deleteMany
   */
  export type QuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotations to delete
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to delete.
     */
    limit?: number
  }

  /**
   * Quotation.approvedBy
   */
  export type Quotation$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    where?: StaffUserWhereInput
  }

  /**
   * Quotation.items
   */
  export type Quotation$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    cursor?: QuoteItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * Quotation.order
   */
  export type Quotation$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Quotation.documents
   */
  export type Quotation$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Quotation.communications
   */
  export type Quotation$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Quotation without action
   */
  export type QuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
  }


  /**
   * Model QuoteItem
   */

  export type AggregateQuoteItem = {
    _count: QuoteItemCountAggregateOutputType | null
    _avg: QuoteItemAvgAggregateOutputType | null
    _sum: QuoteItemSumAggregateOutputType | null
    _min: QuoteItemMinAggregateOutputType | null
    _max: QuoteItemMaxAggregateOutputType | null
  }

  export type QuoteItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    unitCost: number | null
    totalCost: number | null
  }

  export type QuoteItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    unitCost: number | null
    totalCost: number | null
  }

  export type QuoteItemMinAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    unitCost: number | null
    totalCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
    quotationId: string | null
  }

  export type QuoteItemMaxAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    totalPrice: number | null
    unitCost: number | null
    totalCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
    quotationId: string | null
  }

  export type QuoteItemCountAggregateOutputType = {
    id: number
    description: number
    quantity: number
    unitPrice: number
    totalPrice: number
    unitCost: number
    totalCost: number
    createdAt: number
    updatedAt: number
    quotationId: number
    _all: number
  }


  export type QuoteItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    unitCost?: true
    totalCost?: true
  }

  export type QuoteItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    unitCost?: true
    totalCost?: true
  }

  export type QuoteItemMinAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    unitCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    quotationId?: true
  }

  export type QuoteItemMaxAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    unitCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    quotationId?: true
  }

  export type QuoteItemCountAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    unitCost?: true
    totalCost?: true
    createdAt?: true
    updatedAt?: true
    quotationId?: true
    _all?: true
  }

  export type QuoteItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteItem to aggregate.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteItems
    **/
    _count?: true | QuoteItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteItemMaxAggregateInputType
  }

  export type GetQuoteItemAggregateType<T extends QuoteItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteItem[P]>
      : GetScalarType<T[P], AggregateQuoteItem[P]>
  }




  export type QuoteItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithAggregationInput | QuoteItemOrderByWithAggregationInput[]
    by: QuoteItemScalarFieldEnum[] | QuoteItemScalarFieldEnum
    having?: QuoteItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteItemCountAggregateInputType | true
    _avg?: QuoteItemAvgAggregateInputType
    _sum?: QuoteItemSumAggregateInputType
    _min?: QuoteItemMinAggregateInputType
    _max?: QuoteItemMaxAggregateInputType
  }

  export type QuoteItemGroupByOutputType = {
    id: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    unitCost: number
    totalCost: number
    createdAt: Date
    updatedAt: Date
    quotationId: string
    _count: QuoteItemCountAggregateOutputType | null
    _avg: QuoteItemAvgAggregateOutputType | null
    _sum: QuoteItemSumAggregateOutputType | null
    _min: QuoteItemMinAggregateOutputType | null
    _max: QuoteItemMaxAggregateOutputType | null
  }

  type GetQuoteItemGroupByPayload<T extends QuoteItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteItemGroupByOutputType[P]>
        }
      >
    >


  export type QuoteItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    unitCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotationId?: boolean
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    unitCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotationId?: boolean
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    unitCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotationId?: boolean
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectScalar = {
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    unitCost?: boolean
    totalCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotationId?: boolean
  }

  export type QuoteItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "quantity" | "unitPrice" | "totalPrice" | "unitCost" | "totalCost" | "createdAt" | "updatedAt" | "quotationId", ExtArgs["result"]["quoteItem"]>
  export type QuoteItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }
  export type QuoteItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }
  export type QuoteItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }

  export type $QuoteItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteItem"
    objects: {
      quotation: Prisma.$QuotationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      quantity: number
      unitPrice: number
      totalPrice: number
      unitCost: number
      totalCost: number
      createdAt: Date
      updatedAt: Date
      quotationId: string
    }, ExtArgs["result"]["quoteItem"]>
    composites: {}
  }

  type QuoteItemGetPayload<S extends boolean | null | undefined | QuoteItemDefaultArgs> = $Result.GetResult<Prisma.$QuoteItemPayload, S>

  type QuoteItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteItemCountAggregateInputType | true
    }

  export interface QuoteItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteItem'], meta: { name: 'QuoteItem' } }
    /**
     * Find zero or one QuoteItem that matches the filter.
     * @param {QuoteItemFindUniqueArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteItemFindUniqueArgs>(args: SelectSubset<T, QuoteItemFindUniqueArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuoteItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteItemFindUniqueOrThrowArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindFirstArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteItemFindFirstArgs>(args?: SelectSubset<T, QuoteItemFindFirstArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindFirstOrThrowArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuoteItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteItems
     * const quoteItems = await prisma.quoteItem.findMany()
     * 
     * // Get first 10 QuoteItems
     * const quoteItems = await prisma.quoteItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteItemFindManyArgs>(args?: SelectSubset<T, QuoteItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuoteItem.
     * @param {QuoteItemCreateArgs} args - Arguments to create a QuoteItem.
     * @example
     * // Create one QuoteItem
     * const QuoteItem = await prisma.quoteItem.create({
     *   data: {
     *     // ... data to create a QuoteItem
     *   }
     * })
     * 
     */
    create<T extends QuoteItemCreateArgs>(args: SelectSubset<T, QuoteItemCreateArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuoteItems.
     * @param {QuoteItemCreateManyArgs} args - Arguments to create many QuoteItems.
     * @example
     * // Create many QuoteItems
     * const quoteItem = await prisma.quoteItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteItemCreateManyArgs>(args?: SelectSubset<T, QuoteItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteItems and returns the data saved in the database.
     * @param {QuoteItemCreateManyAndReturnArgs} args - Arguments to create many QuoteItems.
     * @example
     * // Create many QuoteItems
     * const quoteItem = await prisma.quoteItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteItems and only return the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuoteItem.
     * @param {QuoteItemDeleteArgs} args - Arguments to delete one QuoteItem.
     * @example
     * // Delete one QuoteItem
     * const QuoteItem = await prisma.quoteItem.delete({
     *   where: {
     *     // ... filter to delete one QuoteItem
     *   }
     * })
     * 
     */
    delete<T extends QuoteItemDeleteArgs>(args: SelectSubset<T, QuoteItemDeleteArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuoteItem.
     * @param {QuoteItemUpdateArgs} args - Arguments to update one QuoteItem.
     * @example
     * // Update one QuoteItem
     * const quoteItem = await prisma.quoteItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteItemUpdateArgs>(args: SelectSubset<T, QuoteItemUpdateArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuoteItems.
     * @param {QuoteItemDeleteManyArgs} args - Arguments to filter QuoteItems to delete.
     * @example
     * // Delete a few QuoteItems
     * const { count } = await prisma.quoteItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteItemDeleteManyArgs>(args?: SelectSubset<T, QuoteItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteItems
     * const quoteItem = await prisma.quoteItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteItemUpdateManyArgs>(args: SelectSubset<T, QuoteItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteItems and returns the data updated in the database.
     * @param {QuoteItemUpdateManyAndReturnArgs} args - Arguments to update many QuoteItems.
     * @example
     * // Update many QuoteItems
     * const quoteItem = await prisma.quoteItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuoteItems and only return the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuoteItem.
     * @param {QuoteItemUpsertArgs} args - Arguments to update or create a QuoteItem.
     * @example
     * // Update or create a QuoteItem
     * const quoteItem = await prisma.quoteItem.upsert({
     *   create: {
     *     // ... data to create a QuoteItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteItem we want to update
     *   }
     * })
     */
    upsert<T extends QuoteItemUpsertArgs>(args: SelectSubset<T, QuoteItemUpsertArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemCountArgs} args - Arguments to filter QuoteItems to count.
     * @example
     * // Count the number of QuoteItems
     * const count = await prisma.quoteItem.count({
     *   where: {
     *     // ... the filter for the QuoteItems we want to count
     *   }
     * })
    **/
    count<T extends QuoteItemCountArgs>(
      args?: Subset<T, QuoteItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteItemAggregateArgs>(args: Subset<T, QuoteItemAggregateArgs>): Prisma.PrismaPromise<GetQuoteItemAggregateType<T>>

    /**
     * Group by QuoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteItemGroupByArgs['orderBy'] }
        : { orderBy?: QuoteItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteItem model
   */
  readonly fields: QuoteItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quotation<T extends QuotationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationDefaultArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteItem model
   */
  interface QuoteItemFieldRefs {
    readonly id: FieldRef<"QuoteItem", 'String'>
    readonly description: FieldRef<"QuoteItem", 'String'>
    readonly quantity: FieldRef<"QuoteItem", 'Int'>
    readonly unitPrice: FieldRef<"QuoteItem", 'Float'>
    readonly totalPrice: FieldRef<"QuoteItem", 'Float'>
    readonly unitCost: FieldRef<"QuoteItem", 'Float'>
    readonly totalCost: FieldRef<"QuoteItem", 'Float'>
    readonly createdAt: FieldRef<"QuoteItem", 'DateTime'>
    readonly updatedAt: FieldRef<"QuoteItem", 'DateTime'>
    readonly quotationId: FieldRef<"QuoteItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuoteItem findUnique
   */
  export type QuoteItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem findUniqueOrThrow
   */
  export type QuoteItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem findFirst
   */
  export type QuoteItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteItems.
     */
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem findFirstOrThrow
   */
  export type QuoteItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteItems.
     */
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem findMany
   */
  export type QuoteItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItems to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem create
   */
  export type QuoteItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteItem.
     */
    data: XOR<QuoteItemCreateInput, QuoteItemUncheckedCreateInput>
  }

  /**
   * QuoteItem createMany
   */
  export type QuoteItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteItems.
     */
    data: QuoteItemCreateManyInput | QuoteItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteItem createManyAndReturn
   */
  export type QuoteItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * The data used to create many QuoteItems.
     */
    data: QuoteItemCreateManyInput | QuoteItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteItem update
   */
  export type QuoteItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteItem.
     */
    data: XOR<QuoteItemUpdateInput, QuoteItemUncheckedUpdateInput>
    /**
     * Choose, which QuoteItem to update.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem updateMany
   */
  export type QuoteItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteItems.
     */
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteItems to update
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to update.
     */
    limit?: number
  }

  /**
   * QuoteItem updateManyAndReturn
   */
  export type QuoteItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * The data used to update QuoteItems.
     */
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteItems to update
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteItem upsert
   */
  export type QuoteItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteItem to update in case it exists.
     */
    where: QuoteItemWhereUniqueInput
    /**
     * In case the QuoteItem found by the `where` argument doesn't exist, create a new QuoteItem with this data.
     */
    create: XOR<QuoteItemCreateInput, QuoteItemUncheckedCreateInput>
    /**
     * In case the QuoteItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteItemUpdateInput, QuoteItemUncheckedUpdateInput>
  }

  /**
   * QuoteItem delete
   */
  export type QuoteItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter which QuoteItem to delete.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem deleteMany
   */
  export type QuoteItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteItems to delete
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to delete.
     */
    limit?: number
  }

  /**
   * QuoteItem without action
   */
  export type QuoteItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalValue: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalValue: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderRef: string | null
    status: $Enums.OrderStatus | null
    orderDate: Date | null
    totalValue: number | null
    currency: $Enums.Currency | null
    expectedDeliveryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    opportunityId: string | null
    quotationId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderRef: string | null
    status: $Enums.OrderStatus | null
    orderDate: Date | null
    totalValue: number | null
    currency: $Enums.Currency | null
    expectedDeliveryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    opportunityId: string | null
    quotationId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderRef: number
    status: number
    orderDate: number
    totalValue: number
    currency: number
    expectedDeliveryDate: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    opportunityId: number
    quotationId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalValue?: true
  }

  export type OrderSumAggregateInputType = {
    totalValue?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderRef?: true
    status?: true
    orderDate?: true
    totalValue?: true
    currency?: true
    expectedDeliveryDate?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    opportunityId?: true
    quotationId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderRef?: true
    status?: true
    orderDate?: true
    totalValue?: true
    currency?: true
    expectedDeliveryDate?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    opportunityId?: true
    quotationId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderRef?: true
    status?: true
    orderDate?: true
    totalValue?: true
    currency?: true
    expectedDeliveryDate?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    opportunityId?: true
    quotationId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderRef: string
    status: $Enums.OrderStatus
    orderDate: Date
    totalValue: number
    currency: $Enums.Currency
    expectedDeliveryDate: Date | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    updatedById: string
    opportunityId: string
    quotationId: string
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderRef?: boolean
    status?: boolean
    orderDate?: boolean
    totalValue?: boolean
    currency?: boolean
    expectedDeliveryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | Order$purchaseOrderArgs<ExtArgs>
    shipments?: boolean | Order$shipmentsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    documents?: boolean | Order$documentsArgs<ExtArgs>
    communications?: boolean | Order$communicationsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderRef?: boolean
    status?: boolean
    orderDate?: boolean
    totalValue?: boolean
    currency?: boolean
    expectedDeliveryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderRef?: boolean
    status?: boolean
    orderDate?: boolean
    totalValue?: boolean
    currency?: boolean
    expectedDeliveryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderRef?: boolean
    status?: boolean
    orderDate?: boolean
    totalValue?: boolean
    currency?: boolean
    expectedDeliveryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    opportunityId?: boolean
    quotationId?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderRef" | "status" | "orderDate" | "totalValue" | "currency" | "expectedDeliveryDate" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "opportunityId" | "quotationId", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
    purchaseOrder?: boolean | Order$purchaseOrderArgs<ExtArgs>
    shipments?: boolean | Order$shipmentsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    documents?: boolean | Order$documentsArgs<ExtArgs>
    communications?: boolean | Order$communicationsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    quotation?: boolean | QuotationDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      createdBy: Prisma.$StaffUserPayload<ExtArgs>
      updatedBy: Prisma.$StaffUserPayload<ExtArgs>
      opportunity: Prisma.$OpportunityPayload<ExtArgs>
      quotation: Prisma.$QuotationPayload<ExtArgs>
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      shipments: Prisma.$ShipmentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderRef: string
      status: $Enums.OrderStatus
      orderDate: Date
      totalValue: number
      currency: $Enums.Currency
      expectedDeliveryDate: Date | null
      createdAt: Date
      updatedAt: Date
      createdById: string
      updatedById: string
      opportunityId: string
      quotationId: string
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quotation<T extends QuotationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuotationDefaultArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrder<T extends Order$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Order$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shipments<T extends Order$shipmentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$shipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Order$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communications<T extends Order$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, Order$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderRef: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly orderDate: FieldRef<"Order", 'DateTime'>
    readonly totalValue: FieldRef<"Order", 'Float'>
    readonly currency: FieldRef<"Order", 'Currency'>
    readonly expectedDeliveryDate: FieldRef<"Order", 'DateTime'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly createdById: FieldRef<"Order", 'String'>
    readonly updatedById: FieldRef<"Order", 'String'>
    readonly opportunityId: FieldRef<"Order", 'String'>
    readonly quotationId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.purchaseOrder
   */
  export type Order$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * Order.shipments
   */
  export type Order$shipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    cursor?: ShipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order.documents
   */
  export type Order$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Order.communications
   */
  export type Order$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    totalValue: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    totalValue: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    poRef: string | null
    issueDate: Date | null
    supplier: string | null
    totalValue: number | null
    currency: $Enums.Currency | null
    createdAt: Date | null
    updatedAt: Date | null
    orderId: string | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    poRef: string | null
    issueDate: Date | null
    supplier: string | null
    totalValue: number | null
    currency: $Enums.Currency | null
    createdAt: Date | null
    updatedAt: Date | null
    orderId: string | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    poRef: number
    issueDate: number
    supplier: number
    totalValue: number
    currency: number
    createdAt: number
    updatedAt: number
    orderId: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    totalValue?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    totalValue?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    poRef?: true
    issueDate?: true
    supplier?: true
    totalValue?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    poRef?: true
    issueDate?: true
    supplier?: true
    totalValue?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    poRef?: true
    issueDate?: true
    supplier?: true
    totalValue?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    poRef: string
    issueDate: Date
    supplier: string
    totalValue: number
    currency: $Enums.Currency
    createdAt: Date
    updatedAt: Date
    orderId: string
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poRef?: boolean
    issueDate?: boolean
    supplier?: boolean
    totalValue?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    documents?: boolean | PurchaseOrder$documentsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poRef?: boolean
    issueDate?: boolean
    supplier?: boolean
    totalValue?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poRef?: boolean
    issueDate?: boolean
    supplier?: boolean
    totalValue?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    poRef?: boolean
    issueDate?: boolean
    supplier?: boolean
    totalValue?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poRef" | "issueDate" | "supplier" | "totalValue" | "currency" | "createdAt" | "updatedAt" | "orderId", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    documents?: boolean | PurchaseOrder$documentsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      poRef: string
      issueDate: Date
      supplier: string
      totalValue: number
      currency: $Enums.Currency
      createdAt: Date
      updatedAt: Date
      orderId: string
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends PurchaseOrder$documentsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly poRef: FieldRef<"PurchaseOrder", 'String'>
    readonly issueDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly supplier: FieldRef<"PurchaseOrder", 'String'>
    readonly totalValue: FieldRef<"PurchaseOrder", 'Float'>
    readonly currency: FieldRef<"PurchaseOrder", 'Currency'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly orderId: FieldRef<"PurchaseOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.documents
   */
  export type PurchaseOrder$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model Shipment
   */

  export type AggregateShipment = {
    _count: ShipmentCountAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  export type ShipmentMinAggregateOutputType = {
    id: string | null
    shipmentRef: string | null
    status: $Enums.ShipmentStatus | null
    trackingNumber: string | null
    carrier: string | null
    shippedOn: Date | null
    expectedDeliveryDate: Date | null
    actualShipmentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    orderId: string | null
  }

  export type ShipmentMaxAggregateOutputType = {
    id: string | null
    shipmentRef: string | null
    status: $Enums.ShipmentStatus | null
    trackingNumber: string | null
    carrier: string | null
    shippedOn: Date | null
    expectedDeliveryDate: Date | null
    actualShipmentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    orderId: string | null
  }

  export type ShipmentCountAggregateOutputType = {
    id: number
    shipmentRef: number
    status: number
    trackingNumber: number
    carrier: number
    shippedOn: number
    expectedDeliveryDate: number
    actualShipmentDate: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    orderId: number
    _all: number
  }


  export type ShipmentMinAggregateInputType = {
    id?: true
    shipmentRef?: true
    status?: true
    trackingNumber?: true
    carrier?: true
    shippedOn?: true
    expectedDeliveryDate?: true
    actualShipmentDate?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    orderId?: true
  }

  export type ShipmentMaxAggregateInputType = {
    id?: true
    shipmentRef?: true
    status?: true
    trackingNumber?: true
    carrier?: true
    shippedOn?: true
    expectedDeliveryDate?: true
    actualShipmentDate?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    orderId?: true
  }

  export type ShipmentCountAggregateInputType = {
    id?: true
    shipmentRef?: true
    status?: true
    trackingNumber?: true
    carrier?: true
    shippedOn?: true
    expectedDeliveryDate?: true
    actualShipmentDate?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    orderId?: true
    _all?: true
  }

  export type ShipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipment to aggregate.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shipments
    **/
    _count?: true | ShipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipmentMaxAggregateInputType
  }

  export type GetShipmentAggregateType<T extends ShipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateShipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShipment[P]>
      : GetScalarType<T[P], AggregateShipment[P]>
  }




  export type ShipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShipmentWhereInput
    orderBy?: ShipmentOrderByWithAggregationInput | ShipmentOrderByWithAggregationInput[]
    by: ShipmentScalarFieldEnum[] | ShipmentScalarFieldEnum
    having?: ShipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipmentCountAggregateInputType | true
    _min?: ShipmentMinAggregateInputType
    _max?: ShipmentMaxAggregateInputType
  }

  export type ShipmentGroupByOutputType = {
    id: string
    shipmentRef: string
    status: $Enums.ShipmentStatus
    trackingNumber: string | null
    carrier: string | null
    shippedOn: Date | null
    expectedDeliveryDate: Date | null
    actualShipmentDate: Date | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    updatedById: string
    orderId: string
    _count: ShipmentCountAggregateOutputType | null
    _min: ShipmentMinAggregateOutputType | null
    _max: ShipmentMaxAggregateOutputType | null
  }

  type GetShipmentGroupByPayload<T extends ShipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
            : GetScalarType<T[P], ShipmentGroupByOutputType[P]>
        }
      >
    >


  export type ShipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentRef?: boolean
    status?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    shippedOn?: boolean
    expectedDeliveryDate?: boolean
    actualShipmentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    orderId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    payments?: boolean | Shipment$paymentsArgs<ExtArgs>
    documents?: boolean | Shipment$documentsArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentRef?: boolean
    status?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    shippedOn?: boolean
    expectedDeliveryDate?: boolean
    actualShipmentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    orderId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shipmentRef?: boolean
    status?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    shippedOn?: boolean
    expectedDeliveryDate?: boolean
    actualShipmentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    orderId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shipment"]>

  export type ShipmentSelectScalar = {
    id?: boolean
    shipmentRef?: boolean
    status?: boolean
    trackingNumber?: boolean
    carrier?: boolean
    shippedOn?: boolean
    expectedDeliveryDate?: boolean
    actualShipmentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    orderId?: boolean
  }

  export type ShipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shipmentRef" | "status" | "trackingNumber" | "carrier" | "shippedOn" | "expectedDeliveryDate" | "actualShipmentDate" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "orderId", ExtArgs["result"]["shipment"]>
  export type ShipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    payments?: boolean | Shipment$paymentsArgs<ExtArgs>
    documents?: boolean | Shipment$documentsArgs<ExtArgs>
    _count?: boolean | ShipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type ShipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $ShipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shipment"
    objects: {
      createdBy: Prisma.$StaffUserPayload<ExtArgs>
      updatedBy: Prisma.$StaffUserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shipmentRef: string
      status: $Enums.ShipmentStatus
      trackingNumber: string | null
      carrier: string | null
      shippedOn: Date | null
      expectedDeliveryDate: Date | null
      actualShipmentDate: Date | null
      createdAt: Date
      updatedAt: Date
      createdById: string
      updatedById: string
      orderId: string
    }, ExtArgs["result"]["shipment"]>
    composites: {}
  }

  type ShipmentGetPayload<S extends boolean | null | undefined | ShipmentDefaultArgs> = $Result.GetResult<Prisma.$ShipmentPayload, S>

  type ShipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShipmentCountAggregateInputType | true
    }

  export interface ShipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shipment'], meta: { name: 'Shipment' } }
    /**
     * Find zero or one Shipment that matches the filter.
     * @param {ShipmentFindUniqueArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShipmentFindUniqueArgs>(args: SelectSubset<T, ShipmentFindUniqueArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShipmentFindUniqueOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShipmentFindFirstArgs>(args?: SelectSubset<T, ShipmentFindFirstArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindFirstOrThrowArgs} args - Arguments to find a Shipment
     * @example
     * // Get one Shipment
     * const shipment = await prisma.shipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shipments
     * const shipments = await prisma.shipment.findMany()
     * 
     * // Get first 10 Shipments
     * const shipments = await prisma.shipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipmentWithIdOnly = await prisma.shipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShipmentFindManyArgs>(args?: SelectSubset<T, ShipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shipment.
     * @param {ShipmentCreateArgs} args - Arguments to create a Shipment.
     * @example
     * // Create one Shipment
     * const Shipment = await prisma.shipment.create({
     *   data: {
     *     // ... data to create a Shipment
     *   }
     * })
     * 
     */
    create<T extends ShipmentCreateArgs>(args: SelectSubset<T, ShipmentCreateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shipments.
     * @param {ShipmentCreateManyArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShipmentCreateManyArgs>(args?: SelectSubset<T, ShipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shipments and returns the data saved in the database.
     * @param {ShipmentCreateManyAndReturnArgs} args - Arguments to create many Shipments.
     * @example
     * // Create many Shipments
     * const shipment = await prisma.shipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shipments and only return the `id`
     * const shipmentWithIdOnly = await prisma.shipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ShipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shipment.
     * @param {ShipmentDeleteArgs} args - Arguments to delete one Shipment.
     * @example
     * // Delete one Shipment
     * const Shipment = await prisma.shipment.delete({
     *   where: {
     *     // ... filter to delete one Shipment
     *   }
     * })
     * 
     */
    delete<T extends ShipmentDeleteArgs>(args: SelectSubset<T, ShipmentDeleteArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shipment.
     * @param {ShipmentUpdateArgs} args - Arguments to update one Shipment.
     * @example
     * // Update one Shipment
     * const shipment = await prisma.shipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShipmentUpdateArgs>(args: SelectSubset<T, ShipmentUpdateArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shipments.
     * @param {ShipmentDeleteManyArgs} args - Arguments to filter Shipments to delete.
     * @example
     * // Delete a few Shipments
     * const { count } = await prisma.shipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShipmentDeleteManyArgs>(args?: SelectSubset<T, ShipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShipmentUpdateManyArgs>(args: SelectSubset<T, ShipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shipments and returns the data updated in the database.
     * @param {ShipmentUpdateManyAndReturnArgs} args - Arguments to update many Shipments.
     * @example
     * // Update many Shipments
     * const shipment = await prisma.shipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shipments and only return the `id`
     * const shipmentWithIdOnly = await prisma.shipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ShipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shipment.
     * @param {ShipmentUpsertArgs} args - Arguments to update or create a Shipment.
     * @example
     * // Update or create a Shipment
     * const shipment = await prisma.shipment.upsert({
     *   create: {
     *     // ... data to create a Shipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shipment we want to update
     *   }
     * })
     */
    upsert<T extends ShipmentUpsertArgs>(args: SelectSubset<T, ShipmentUpsertArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentCountArgs} args - Arguments to filter Shipments to count.
     * @example
     * // Count the number of Shipments
     * const count = await prisma.shipment.count({
     *   where: {
     *     // ... the filter for the Shipments we want to count
     *   }
     * })
    **/
    count<T extends ShipmentCountArgs>(
      args?: Subset<T, ShipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipmentAggregateArgs>(args: Subset<T, ShipmentAggregateArgs>): Prisma.PrismaPromise<GetShipmentAggregateType<T>>

    /**
     * Group by Shipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShipmentGroupByArgs['orderBy'] }
        : { orderBy?: ShipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shipment model
   */
  readonly fields: ShipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Shipment$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Shipment$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Shipment$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shipment model
   */
  interface ShipmentFieldRefs {
    readonly id: FieldRef<"Shipment", 'String'>
    readonly shipmentRef: FieldRef<"Shipment", 'String'>
    readonly status: FieldRef<"Shipment", 'ShipmentStatus'>
    readonly trackingNumber: FieldRef<"Shipment", 'String'>
    readonly carrier: FieldRef<"Shipment", 'String'>
    readonly shippedOn: FieldRef<"Shipment", 'DateTime'>
    readonly expectedDeliveryDate: FieldRef<"Shipment", 'DateTime'>
    readonly actualShipmentDate: FieldRef<"Shipment", 'DateTime'>
    readonly createdAt: FieldRef<"Shipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Shipment", 'DateTime'>
    readonly createdById: FieldRef<"Shipment", 'String'>
    readonly updatedById: FieldRef<"Shipment", 'String'>
    readonly orderId: FieldRef<"Shipment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Shipment findUnique
   */
  export type ShipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findUniqueOrThrow
   */
  export type ShipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment findFirst
   */
  export type ShipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findFirstOrThrow
   */
  export type ShipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipment to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shipments.
     */
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment findMany
   */
  export type ShipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter, which Shipments to fetch.
     */
    where?: ShipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shipments to fetch.
     */
    orderBy?: ShipmentOrderByWithRelationInput | ShipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shipments.
     */
    cursor?: ShipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shipments.
     */
    skip?: number
    distinct?: ShipmentScalarFieldEnum | ShipmentScalarFieldEnum[]
  }

  /**
   * Shipment create
   */
  export type ShipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Shipment.
     */
    data: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
  }

  /**
   * Shipment createMany
   */
  export type ShipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shipment createManyAndReturn
   */
  export type ShipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Shipments.
     */
    data: ShipmentCreateManyInput | ShipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipment update
   */
  export type ShipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Shipment.
     */
    data: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
    /**
     * Choose, which Shipment to update.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment updateMany
   */
  export type ShipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to update.
     */
    limit?: number
  }

  /**
   * Shipment updateManyAndReturn
   */
  export type ShipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * The data used to update Shipments.
     */
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyInput>
    /**
     * Filter which Shipments to update
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shipment upsert
   */
  export type ShipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Shipment to update in case it exists.
     */
    where: ShipmentWhereUniqueInput
    /**
     * In case the Shipment found by the `where` argument doesn't exist, create a new Shipment with this data.
     */
    create: XOR<ShipmentCreateInput, ShipmentUncheckedCreateInput>
    /**
     * In case the Shipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShipmentUpdateInput, ShipmentUncheckedUpdateInput>
  }

  /**
   * Shipment delete
   */
  export type ShipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    /**
     * Filter which Shipment to delete.
     */
    where: ShipmentWhereUniqueInput
  }

  /**
   * Shipment deleteMany
   */
  export type ShipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shipments to delete
     */
    where?: ShipmentWhereInput
    /**
     * Limit how many Shipments to delete.
     */
    limit?: number
  }

  /**
   * Shipment.payments
   */
  export type Shipment$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Shipment.documents
   */
  export type Shipment$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Shipment without action
   */
  export type ShipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    paymentRef: string | null
    amount: number | null
    currency: $Enums.Currency | null
    paymentMethod: string | null
    status: $Enums.PaymentStatus | null
    paymentDate: Date | null
    paymentReceivedOn: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    orderId: string | null
    shipmentId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    paymentRef: string | null
    amount: number | null
    currency: $Enums.Currency | null
    paymentMethod: string | null
    status: $Enums.PaymentStatus | null
    paymentDate: Date | null
    paymentReceivedOn: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    updatedById: string | null
    orderId: string | null
    shipmentId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    paymentRef: number
    amount: number
    currency: number
    paymentMethod: number
    status: number
    paymentDate: number
    paymentReceivedOn: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    orderId: number
    shipmentId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    paymentRef?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    paymentDate?: true
    paymentReceivedOn?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    orderId?: true
    shipmentId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    paymentRef?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    paymentDate?: true
    paymentReceivedOn?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    orderId?: true
    shipmentId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    paymentRef?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    status?: true
    paymentDate?: true
    paymentReceivedOn?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    orderId?: true
    shipmentId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    paymentRef: string
    amount: number
    currency: $Enums.Currency
    paymentMethod: string
    status: $Enums.PaymentStatus
    paymentDate: Date
    paymentReceivedOn: Date | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    updatedById: string
    orderId: string
    shipmentId: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentRef?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    paymentDate?: boolean
    paymentReceivedOn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    orderId?: boolean
    shipmentId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    shipment?: boolean | Payment$shipmentArgs<ExtArgs>
    documents?: boolean | Payment$documentsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentRef?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    paymentDate?: boolean
    paymentReceivedOn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    orderId?: boolean
    shipmentId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    shipment?: boolean | Payment$shipmentArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentRef?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    paymentDate?: boolean
    paymentReceivedOn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    orderId?: boolean
    shipmentId?: boolean
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    shipment?: boolean | Payment$shipmentArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    paymentRef?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    status?: boolean
    paymentDate?: boolean
    paymentReceivedOn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    orderId?: boolean
    shipmentId?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentRef" | "amount" | "currency" | "paymentMethod" | "status" | "paymentDate" | "paymentReceivedOn" | "createdAt" | "updatedAt" | "createdById" | "updatedById" | "orderId" | "shipmentId", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    shipment?: boolean | Payment$shipmentArgs<ExtArgs>
    documents?: boolean | Payment$documentsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    shipment?: boolean | Payment$shipmentArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    updatedBy?: boolean | StaffUserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    shipment?: boolean | Payment$shipmentArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      createdBy: Prisma.$StaffUserPayload<ExtArgs>
      updatedBy: Prisma.$StaffUserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      shipment: Prisma.$ShipmentPayload<ExtArgs> | null
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentRef: string
      amount: number
      currency: $Enums.Currency
      paymentMethod: string
      status: $Enums.PaymentStatus
      paymentDate: Date
      paymentReceivedOn: Date | null
      createdAt: Date
      updatedAt: Date
      createdById: string
      updatedById: string
      orderId: string
      shipmentId: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends StaffUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffUserDefaultArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shipment<T extends Payment$shipmentArgs<ExtArgs> = {}>(args?: Subset<T, Payment$shipmentArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    documents<T extends Payment$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly paymentRef: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'Currency'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentReceivedOn: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdById: FieldRef<"Payment", 'String'>
    readonly updatedById: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly shipmentId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.shipment
   */
  export type Payment$shipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * Payment.documents
   */
  export type Payment$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type DocumentSumAggregateOutputType = {
    sizeBytes: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    fileType: string | null
    url: string | null
    sizeBytes: number | null
    createdAt: Date | null
    opportunityId: string | null
    quotationId: string | null
    orderId: string | null
    purchaseOrderId: string | null
    shipmentId: string | null
    paymentId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    fileType: string | null
    url: string | null
    sizeBytes: number | null
    createdAt: Date | null
    opportunityId: string | null
    quotationId: string | null
    orderId: string | null
    purchaseOrderId: string | null
    shipmentId: string | null
    paymentId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    fileName: number
    fileType: number
    url: number
    sizeBytes: number
    createdAt: number
    opportunityId: number
    quotationId: number
    orderId: number
    purchaseOrderId: number
    shipmentId: number
    paymentId: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type DocumentSumAggregateInputType = {
    sizeBytes?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    fileName?: true
    fileType?: true
    url?: true
    sizeBytes?: true
    createdAt?: true
    opportunityId?: true
    quotationId?: true
    orderId?: true
    purchaseOrderId?: true
    shipmentId?: true
    paymentId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    fileName?: true
    fileType?: true
    url?: true
    sizeBytes?: true
    createdAt?: true
    opportunityId?: true
    quotationId?: true
    orderId?: true
    purchaseOrderId?: true
    shipmentId?: true
    paymentId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    fileName?: true
    fileType?: true
    url?: true
    sizeBytes?: true
    createdAt?: true
    opportunityId?: true
    quotationId?: true
    orderId?: true
    purchaseOrderId?: true
    shipmentId?: true
    paymentId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt: Date
    opportunityId: string | null
    quotationId: string | null
    orderId: string | null
    purchaseOrderId: string | null
    shipmentId: string | null
    paymentId: string | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileType?: boolean
    url?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    orderId?: boolean
    purchaseOrderId?: boolean
    shipmentId?: boolean
    paymentId?: boolean
    opportunity?: boolean | Document$opportunityArgs<ExtArgs>
    quotation?: boolean | Document$quotationArgs<ExtArgs>
    order?: boolean | Document$orderArgs<ExtArgs>
    purchaseOrder?: boolean | Document$purchaseOrderArgs<ExtArgs>
    shipment?: boolean | Document$shipmentArgs<ExtArgs>
    payment?: boolean | Document$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileType?: boolean
    url?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    orderId?: boolean
    purchaseOrderId?: boolean
    shipmentId?: boolean
    paymentId?: boolean
    opportunity?: boolean | Document$opportunityArgs<ExtArgs>
    quotation?: boolean | Document$quotationArgs<ExtArgs>
    order?: boolean | Document$orderArgs<ExtArgs>
    purchaseOrder?: boolean | Document$purchaseOrderArgs<ExtArgs>
    shipment?: boolean | Document$shipmentArgs<ExtArgs>
    payment?: boolean | Document$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileType?: boolean
    url?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    orderId?: boolean
    purchaseOrderId?: boolean
    shipmentId?: boolean
    paymentId?: boolean
    opportunity?: boolean | Document$opportunityArgs<ExtArgs>
    quotation?: boolean | Document$quotationArgs<ExtArgs>
    order?: boolean | Document$orderArgs<ExtArgs>
    purchaseOrder?: boolean | Document$purchaseOrderArgs<ExtArgs>
    shipment?: boolean | Document$shipmentArgs<ExtArgs>
    payment?: boolean | Document$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    fileName?: boolean
    fileType?: boolean
    url?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    orderId?: boolean
    purchaseOrderId?: boolean
    shipmentId?: boolean
    paymentId?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileName" | "fileType" | "url" | "sizeBytes" | "createdAt" | "opportunityId" | "quotationId" | "orderId" | "purchaseOrderId" | "shipmentId" | "paymentId", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | Document$opportunityArgs<ExtArgs>
    quotation?: boolean | Document$quotationArgs<ExtArgs>
    order?: boolean | Document$orderArgs<ExtArgs>
    purchaseOrder?: boolean | Document$purchaseOrderArgs<ExtArgs>
    shipment?: boolean | Document$shipmentArgs<ExtArgs>
    payment?: boolean | Document$paymentArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | Document$opportunityArgs<ExtArgs>
    quotation?: boolean | Document$quotationArgs<ExtArgs>
    order?: boolean | Document$orderArgs<ExtArgs>
    purchaseOrder?: boolean | Document$purchaseOrderArgs<ExtArgs>
    shipment?: boolean | Document$shipmentArgs<ExtArgs>
    payment?: boolean | Document$paymentArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | Document$opportunityArgs<ExtArgs>
    quotation?: boolean | Document$quotationArgs<ExtArgs>
    order?: boolean | Document$orderArgs<ExtArgs>
    purchaseOrder?: boolean | Document$purchaseOrderArgs<ExtArgs>
    shipment?: boolean | Document$shipmentArgs<ExtArgs>
    payment?: boolean | Document$paymentArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
      quotation: Prisma.$QuotationPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs> | null
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      shipment: Prisma.$ShipmentPayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      fileType: string
      url: string
      sizeBytes: number
      createdAt: Date
      opportunityId: string | null
      quotationId: string | null
      orderId: string | null
      purchaseOrderId: string | null
      shipmentId: string | null
      paymentId: string | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunity<T extends Document$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, Document$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quotation<T extends Document$quotationArgs<ExtArgs> = {}>(args?: Subset<T, Document$quotationArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends Document$orderArgs<ExtArgs> = {}>(args?: Subset<T, Document$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchaseOrder<T extends Document$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Document$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shipment<T extends Document$shipmentArgs<ExtArgs> = {}>(args?: Subset<T, Document$shipmentArgs<ExtArgs>>): Prisma__ShipmentClient<$Result.GetResult<Prisma.$ShipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment<T extends Document$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Document$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly fileName: FieldRef<"Document", 'String'>
    readonly fileType: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly sizeBytes: FieldRef<"Document", 'Int'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly opportunityId: FieldRef<"Document", 'String'>
    readonly quotationId: FieldRef<"Document", 'String'>
    readonly orderId: FieldRef<"Document", 'String'>
    readonly purchaseOrderId: FieldRef<"Document", 'String'>
    readonly shipmentId: FieldRef<"Document", 'String'>
    readonly paymentId: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.opportunity
   */
  export type Document$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * Document.quotation
   */
  export type Document$quotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
  }

  /**
   * Document.order
   */
  export type Document$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Document.purchaseOrder
   */
  export type Document$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * Document.shipment
   */
  export type Document$shipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shipment
     */
    select?: ShipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shipment
     */
    omit?: ShipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShipmentInclude<ExtArgs> | null
    where?: ShipmentWhereInput
  }

  /**
   * Document.payment
   */
  export type Document$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Communication
   */

  export type AggregateCommunication = {
    _count: CommunicationCountAggregateOutputType | null
    _min: CommunicationMinAggregateOutputType | null
    _max: CommunicationMaxAggregateOutputType | null
  }

  export type CommunicationMinAggregateOutputType = {
    id: string | null
    type: $Enums.CommunicationType | null
    direction: $Enums.CommunicationDirection | null
    content: string | null
    subject: string | null
    sender: string | null
    recipient: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
    opportunityId: string | null
    quotationId: string | null
    orderId: string | null
    loggedByStaffId: string | null
  }

  export type CommunicationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.CommunicationType | null
    direction: $Enums.CommunicationDirection | null
    content: string | null
    subject: string | null
    sender: string | null
    recipient: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    customerId: string | null
    opportunityId: string | null
    quotationId: string | null
    orderId: string | null
    loggedByStaffId: string | null
  }

  export type CommunicationCountAggregateOutputType = {
    id: number
    type: number
    direction: number
    content: number
    subject: number
    sender: number
    recipient: number
    timestamp: number
    createdAt: number
    updatedAt: number
    customerId: number
    opportunityId: number
    quotationId: number
    orderId: number
    loggedByStaffId: number
    _all: number
  }


  export type CommunicationMinAggregateInputType = {
    id?: true
    type?: true
    direction?: true
    content?: true
    subject?: true
    sender?: true
    recipient?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    opportunityId?: true
    quotationId?: true
    orderId?: true
    loggedByStaffId?: true
  }

  export type CommunicationMaxAggregateInputType = {
    id?: true
    type?: true
    direction?: true
    content?: true
    subject?: true
    sender?: true
    recipient?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    opportunityId?: true
    quotationId?: true
    orderId?: true
    loggedByStaffId?: true
  }

  export type CommunicationCountAggregateInputType = {
    id?: true
    type?: true
    direction?: true
    content?: true
    subject?: true
    sender?: true
    recipient?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    customerId?: true
    opportunityId?: true
    quotationId?: true
    orderId?: true
    loggedByStaffId?: true
    _all?: true
  }

  export type CommunicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communication to aggregate.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communications
    **/
    _count?: true | CommunicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunicationMaxAggregateInputType
  }

  export type GetCommunicationAggregateType<T extends CommunicationAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunication[P]>
      : GetScalarType<T[P], AggregateCommunication[P]>
  }




  export type CommunicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithAggregationInput | CommunicationOrderByWithAggregationInput[]
    by: CommunicationScalarFieldEnum[] | CommunicationScalarFieldEnum
    having?: CommunicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunicationCountAggregateInputType | true
    _min?: CommunicationMinAggregateInputType
    _max?: CommunicationMaxAggregateInputType
  }

  export type CommunicationGroupByOutputType = {
    id: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject: string | null
    sender: string
    recipient: string | null
    timestamp: Date
    createdAt: Date
    updatedAt: Date
    customerId: string | null
    opportunityId: string | null
    quotationId: string | null
    orderId: string | null
    loggedByStaffId: string | null
    _count: CommunicationCountAggregateOutputType | null
    _min: CommunicationMinAggregateOutputType | null
    _max: CommunicationMaxAggregateOutputType | null
  }

  type GetCommunicationGroupByPayload<T extends CommunicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunicationGroupByOutputType[P]>
            : GetScalarType<T[P], CommunicationGroupByOutputType[P]>
        }
      >
    >


  export type CommunicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    direction?: boolean
    content?: boolean
    subject?: boolean
    sender?: boolean
    recipient?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    orderId?: boolean
    loggedByStaffId?: boolean
    customer?: boolean | Communication$customerArgs<ExtArgs>
    opportunity?: boolean | Communication$opportunityArgs<ExtArgs>
    quotation?: boolean | Communication$quotationArgs<ExtArgs>
    order?: boolean | Communication$orderArgs<ExtArgs>
    loggedBy?: boolean | Communication$loggedByArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    direction?: boolean
    content?: boolean
    subject?: boolean
    sender?: boolean
    recipient?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    orderId?: boolean
    loggedByStaffId?: boolean
    customer?: boolean | Communication$customerArgs<ExtArgs>
    opportunity?: boolean | Communication$opportunityArgs<ExtArgs>
    quotation?: boolean | Communication$quotationArgs<ExtArgs>
    order?: boolean | Communication$orderArgs<ExtArgs>
    loggedBy?: boolean | Communication$loggedByArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    direction?: boolean
    content?: boolean
    subject?: boolean
    sender?: boolean
    recipient?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    orderId?: boolean
    loggedByStaffId?: boolean
    customer?: boolean | Communication$customerArgs<ExtArgs>
    opportunity?: boolean | Communication$opportunityArgs<ExtArgs>
    quotation?: boolean | Communication$quotationArgs<ExtArgs>
    order?: boolean | Communication$orderArgs<ExtArgs>
    loggedBy?: boolean | Communication$loggedByArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectScalar = {
    id?: boolean
    type?: boolean
    direction?: boolean
    content?: boolean
    subject?: boolean
    sender?: boolean
    recipient?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerId?: boolean
    opportunityId?: boolean
    quotationId?: boolean
    orderId?: boolean
    loggedByStaffId?: boolean
  }

  export type CommunicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "direction" | "content" | "subject" | "sender" | "recipient" | "timestamp" | "createdAt" | "updatedAt" | "customerId" | "opportunityId" | "quotationId" | "orderId" | "loggedByStaffId", ExtArgs["result"]["communication"]>
  export type CommunicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Communication$customerArgs<ExtArgs>
    opportunity?: boolean | Communication$opportunityArgs<ExtArgs>
    quotation?: boolean | Communication$quotationArgs<ExtArgs>
    order?: boolean | Communication$orderArgs<ExtArgs>
    loggedBy?: boolean | Communication$loggedByArgs<ExtArgs>
  }
  export type CommunicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Communication$customerArgs<ExtArgs>
    opportunity?: boolean | Communication$opportunityArgs<ExtArgs>
    quotation?: boolean | Communication$quotationArgs<ExtArgs>
    order?: boolean | Communication$orderArgs<ExtArgs>
    loggedBy?: boolean | Communication$loggedByArgs<ExtArgs>
  }
  export type CommunicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Communication$customerArgs<ExtArgs>
    opportunity?: boolean | Communication$opportunityArgs<ExtArgs>
    quotation?: boolean | Communication$quotationArgs<ExtArgs>
    order?: boolean | Communication$orderArgs<ExtArgs>
    loggedBy?: boolean | Communication$loggedByArgs<ExtArgs>
  }

  export type $CommunicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Communication"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
      quotation: Prisma.$QuotationPayload<ExtArgs> | null
      order: Prisma.$OrderPayload<ExtArgs> | null
      loggedBy: Prisma.$StaffUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.CommunicationType
      direction: $Enums.CommunicationDirection
      content: string
      subject: string | null
      sender: string
      recipient: string | null
      timestamp: Date
      createdAt: Date
      updatedAt: Date
      customerId: string | null
      opportunityId: string | null
      quotationId: string | null
      orderId: string | null
      loggedByStaffId: string | null
    }, ExtArgs["result"]["communication"]>
    composites: {}
  }

  type CommunicationGetPayload<S extends boolean | null | undefined | CommunicationDefaultArgs> = $Result.GetResult<Prisma.$CommunicationPayload, S>

  type CommunicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunicationCountAggregateInputType | true
    }

  export interface CommunicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Communication'], meta: { name: 'Communication' } }
    /**
     * Find zero or one Communication that matches the filter.
     * @param {CommunicationFindUniqueArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunicationFindUniqueArgs>(args: SelectSubset<T, CommunicationFindUniqueArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Communication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunicationFindUniqueOrThrowArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunicationFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Communication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindFirstArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunicationFindFirstArgs>(args?: SelectSubset<T, CommunicationFindFirstArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Communication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindFirstOrThrowArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunicationFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Communications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communications
     * const communications = await prisma.communication.findMany()
     * 
     * // Get first 10 Communications
     * const communications = await prisma.communication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communicationWithIdOnly = await prisma.communication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunicationFindManyArgs>(args?: SelectSubset<T, CommunicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Communication.
     * @param {CommunicationCreateArgs} args - Arguments to create a Communication.
     * @example
     * // Create one Communication
     * const Communication = await prisma.communication.create({
     *   data: {
     *     // ... data to create a Communication
     *   }
     * })
     * 
     */
    create<T extends CommunicationCreateArgs>(args: SelectSubset<T, CommunicationCreateArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Communications.
     * @param {CommunicationCreateManyArgs} args - Arguments to create many Communications.
     * @example
     * // Create many Communications
     * const communication = await prisma.communication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunicationCreateManyArgs>(args?: SelectSubset<T, CommunicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Communications and returns the data saved in the database.
     * @param {CommunicationCreateManyAndReturnArgs} args - Arguments to create many Communications.
     * @example
     * // Create many Communications
     * const communication = await prisma.communication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Communications and only return the `id`
     * const communicationWithIdOnly = await prisma.communication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunicationCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Communication.
     * @param {CommunicationDeleteArgs} args - Arguments to delete one Communication.
     * @example
     * // Delete one Communication
     * const Communication = await prisma.communication.delete({
     *   where: {
     *     // ... filter to delete one Communication
     *   }
     * })
     * 
     */
    delete<T extends CommunicationDeleteArgs>(args: SelectSubset<T, CommunicationDeleteArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Communication.
     * @param {CommunicationUpdateArgs} args - Arguments to update one Communication.
     * @example
     * // Update one Communication
     * const communication = await prisma.communication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunicationUpdateArgs>(args: SelectSubset<T, CommunicationUpdateArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Communications.
     * @param {CommunicationDeleteManyArgs} args - Arguments to filter Communications to delete.
     * @example
     * // Delete a few Communications
     * const { count } = await prisma.communication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunicationDeleteManyArgs>(args?: SelectSubset<T, CommunicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communications
     * const communication = await prisma.communication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunicationUpdateManyArgs>(args: SelectSubset<T, CommunicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communications and returns the data updated in the database.
     * @param {CommunicationUpdateManyAndReturnArgs} args - Arguments to update many Communications.
     * @example
     * // Update many Communications
     * const communication = await prisma.communication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Communications and only return the `id`
     * const communicationWithIdOnly = await prisma.communication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunicationUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Communication.
     * @param {CommunicationUpsertArgs} args - Arguments to update or create a Communication.
     * @example
     * // Update or create a Communication
     * const communication = await prisma.communication.upsert({
     *   create: {
     *     // ... data to create a Communication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Communication we want to update
     *   }
     * })
     */
    upsert<T extends CommunicationUpsertArgs>(args: SelectSubset<T, CommunicationUpsertArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Communications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationCountArgs} args - Arguments to filter Communications to count.
     * @example
     * // Count the number of Communications
     * const count = await prisma.communication.count({
     *   where: {
     *     // ... the filter for the Communications we want to count
     *   }
     * })
    **/
    count<T extends CommunicationCountArgs>(
      args?: Subset<T, CommunicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Communication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunicationAggregateArgs>(args: Subset<T, CommunicationAggregateArgs>): Prisma.PrismaPromise<GetCommunicationAggregateType<T>>

    /**
     * Group by Communication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunicationGroupByArgs['orderBy'] }
        : { orderBy?: CommunicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Communication model
   */
  readonly fields: CommunicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Communication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Communication$customerArgs<ExtArgs> = {}>(args?: Subset<T, Communication$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    opportunity<T extends Communication$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, Communication$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quotation<T extends Communication$quotationArgs<ExtArgs> = {}>(args?: Subset<T, Communication$quotationArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends Communication$orderArgs<ExtArgs> = {}>(args?: Subset<T, Communication$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    loggedBy<T extends Communication$loggedByArgs<ExtArgs> = {}>(args?: Subset<T, Communication$loggedByArgs<ExtArgs>>): Prisma__StaffUserClient<$Result.GetResult<Prisma.$StaffUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Communication model
   */
  interface CommunicationFieldRefs {
    readonly id: FieldRef<"Communication", 'String'>
    readonly type: FieldRef<"Communication", 'CommunicationType'>
    readonly direction: FieldRef<"Communication", 'CommunicationDirection'>
    readonly content: FieldRef<"Communication", 'String'>
    readonly subject: FieldRef<"Communication", 'String'>
    readonly sender: FieldRef<"Communication", 'String'>
    readonly recipient: FieldRef<"Communication", 'String'>
    readonly timestamp: FieldRef<"Communication", 'DateTime'>
    readonly createdAt: FieldRef<"Communication", 'DateTime'>
    readonly updatedAt: FieldRef<"Communication", 'DateTime'>
    readonly customerId: FieldRef<"Communication", 'String'>
    readonly opportunityId: FieldRef<"Communication", 'String'>
    readonly quotationId: FieldRef<"Communication", 'String'>
    readonly orderId: FieldRef<"Communication", 'String'>
    readonly loggedByStaffId: FieldRef<"Communication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Communication findUnique
   */
  export type CommunicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication findUniqueOrThrow
   */
  export type CommunicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication findFirst
   */
  export type CommunicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communications.
     */
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication findFirstOrThrow
   */
  export type CommunicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communications.
     */
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication findMany
   */
  export type CommunicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communications to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication create
   */
  export type CommunicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Communication.
     */
    data: XOR<CommunicationCreateInput, CommunicationUncheckedCreateInput>
  }

  /**
   * Communication createMany
   */
  export type CommunicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communications.
     */
    data: CommunicationCreateManyInput | CommunicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Communication createManyAndReturn
   */
  export type CommunicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * The data used to create many Communications.
     */
    data: CommunicationCreateManyInput | CommunicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Communication update
   */
  export type CommunicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Communication.
     */
    data: XOR<CommunicationUpdateInput, CommunicationUncheckedUpdateInput>
    /**
     * Choose, which Communication to update.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication updateMany
   */
  export type CommunicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communications.
     */
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyInput>
    /**
     * Filter which Communications to update
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to update.
     */
    limit?: number
  }

  /**
   * Communication updateManyAndReturn
   */
  export type CommunicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * The data used to update Communications.
     */
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyInput>
    /**
     * Filter which Communications to update
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Communication upsert
   */
  export type CommunicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Communication to update in case it exists.
     */
    where: CommunicationWhereUniqueInput
    /**
     * In case the Communication found by the `where` argument doesn't exist, create a new Communication with this data.
     */
    create: XOR<CommunicationCreateInput, CommunicationUncheckedCreateInput>
    /**
     * In case the Communication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunicationUpdateInput, CommunicationUncheckedUpdateInput>
  }

  /**
   * Communication delete
   */
  export type CommunicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter which Communication to delete.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication deleteMany
   */
  export type CommunicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communications to delete
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to delete.
     */
    limit?: number
  }

  /**
   * Communication.customer
   */
  export type Communication$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Communication.opportunity
   */
  export type Communication$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * Communication.quotation
   */
  export type Communication$quotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
  }

  /**
   * Communication.order
   */
  export type Communication$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Communication.loggedBy
   */
  export type Communication$loggedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffUser
     */
    select?: StaffUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffUser
     */
    omit?: StaffUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffUserInclude<ExtArgs> | null
    where?: StaffUserWhereInput
  }

  /**
   * Communication without action
   */
  export type CommunicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StaffUserScalarFieldEnum: {
    staffId: 'staffId',
    name: 'name',
    email: 'email',
    designation: 'designation',
    contactNumber: 'contactNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffUserScalarFieldEnum = (typeof StaffUserScalarFieldEnum)[keyof typeof StaffUserScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedUserId: 'assignedUserId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    cid: 'cid',
    customerType: 'customerType',
    businessName: 'businessName',
    salutation: 'salutation',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    currency: 'currency',
    gstin: 'gstin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const OpportunityScalarFieldEnum: {
    id: 'id',
    oppRef: 'oppRef',
    title: 'title',
    status: 'status',
    value: 'value',
    currency: 'currency',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerId: 'customerId',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerId: 'customerId',
    projectManagerId: 'projectManagerId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const QuotationScalarFieldEnum: {
    id: 'id',
    quoteRef: 'quoteRef',
    revision: 'revision',
    status: 'status',
    currency: 'currency',
    fxRate: 'fxRate',
    totalCost: 'totalCost',
    markupPercent: 'markupPercent',
    insurancePercent: 'insurancePercent',
    financeCharge: 'financeCharge',
    subtotal: 'subtotal',
    vatPercent: 'vatPercent',
    totalWithVAT: 'totalWithVAT',
    profitMarginBHD: 'profitMarginBHD',
    fxGain: 'fxGain',
    validUntil: 'validUntil',
    paymentTerms: 'paymentTerms',
    deliveryTerms: 'deliveryTerms',
    expectedDeliveryDate: 'expectedDeliveryDate',
    marginApprovalPopup: 'marginApprovalPopup',
    approvedById: 'approvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    opportunityId: 'opportunityId'
  };

  export type QuotationScalarFieldEnum = (typeof QuotationScalarFieldEnum)[keyof typeof QuotationScalarFieldEnum]


  export const QuoteItemScalarFieldEnum: {
    id: 'id',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    unitCost: 'unitCost',
    totalCost: 'totalCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    quotationId: 'quotationId'
  };

  export type QuoteItemScalarFieldEnum = (typeof QuoteItemScalarFieldEnum)[keyof typeof QuoteItemScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderRef: 'orderRef',
    status: 'status',
    orderDate: 'orderDate',
    totalValue: 'totalValue',
    currency: 'currency',
    expectedDeliveryDate: 'expectedDeliveryDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    opportunityId: 'opportunityId',
    quotationId: 'quotationId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    poRef: 'poRef',
    issueDate: 'issueDate',
    supplier: 'supplier',
    totalValue: 'totalValue',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    orderId: 'orderId'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const ShipmentScalarFieldEnum: {
    id: 'id',
    shipmentRef: 'shipmentRef',
    status: 'status',
    trackingNumber: 'trackingNumber',
    carrier: 'carrier',
    shippedOn: 'shippedOn',
    expectedDeliveryDate: 'expectedDeliveryDate',
    actualShipmentDate: 'actualShipmentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    orderId: 'orderId'
  };

  export type ShipmentScalarFieldEnum = (typeof ShipmentScalarFieldEnum)[keyof typeof ShipmentScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    paymentRef: 'paymentRef',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    status: 'status',
    paymentDate: 'paymentDate',
    paymentReceivedOn: 'paymentReceivedOn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById',
    orderId: 'orderId',
    shipmentId: 'shipmentId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    fileType: 'fileType',
    url: 'url',
    sizeBytes: 'sizeBytes',
    createdAt: 'createdAt',
    opportunityId: 'opportunityId',
    quotationId: 'quotationId',
    orderId: 'orderId',
    purchaseOrderId: 'purchaseOrderId',
    shipmentId: 'shipmentId',
    paymentId: 'paymentId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CommunicationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    direction: 'direction',
    content: 'content',
    subject: 'subject',
    sender: 'sender',
    recipient: 'recipient',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    customerId: 'customerId',
    opportunityId: 'opportunityId',
    quotationId: 'quotationId',
    orderId: 'orderId',
    loggedByStaffId: 'loggedByStaffId'
  };

  export type CommunicationScalarFieldEnum = (typeof CommunicationScalarFieldEnum)[keyof typeof CommunicationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'Currency'
   */
  export type EnumCurrencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Currency'>
    


  /**
   * Reference to a field of type 'Currency[]'
   */
  export type ListEnumCurrencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Currency[]'>
    


  /**
   * Reference to a field of type 'OpportunityStatus'
   */
  export type EnumOpportunityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityStatus'>
    


  /**
   * Reference to a field of type 'OpportunityStatus[]'
   */
  export type ListEnumOpportunityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'QuotationStatus'
   */
  export type EnumQuotationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationStatus'>
    


  /**
   * Reference to a field of type 'QuotationStatus[]'
   */
  export type ListEnumQuotationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuotationStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'ShipmentStatus'
   */
  export type EnumShipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShipmentStatus'>
    


  /**
   * Reference to a field of type 'ShipmentStatus[]'
   */
  export type ListEnumShipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShipmentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'CommunicationType'
   */
  export type EnumCommunicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationType'>
    


  /**
   * Reference to a field of type 'CommunicationType[]'
   */
  export type ListEnumCommunicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationType[]'>
    


  /**
   * Reference to a field of type 'CommunicationDirection'
   */
  export type EnumCommunicationDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationDirection'>
    


  /**
   * Reference to a field of type 'CommunicationDirection[]'
   */
  export type ListEnumCommunicationDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationDirection[]'>
    
  /**
   * Deep Input Types
   */


  export type StaffUserWhereInput = {
    AND?: StaffUserWhereInput | StaffUserWhereInput[]
    OR?: StaffUserWhereInput[]
    NOT?: StaffUserWhereInput | StaffUserWhereInput[]
    staffId?: UuidFilter<"StaffUser"> | string
    name?: StringFilter<"StaffUser"> | string
    email?: StringFilter<"StaffUser"> | string
    designation?: StringFilter<"StaffUser"> | string
    contactNumber?: StringNullableFilter<"StaffUser"> | string | null
    createdAt?: DateTimeFilter<"StaffUser"> | Date | string
    updatedAt?: DateTimeFilter<"StaffUser"> | Date | string
    createdOpportunities?: OpportunityListRelationFilter
    updatedOpportunities?: OpportunityListRelationFilter
    createdQuotations?: QuotationListRelationFilter
    updatedQuotations?: QuotationListRelationFilter
    createdOrders?: OrderListRelationFilter
    updatedOrders?: OrderListRelationFilter
    createdShipments?: ShipmentListRelationFilter
    updatedShipments?: ShipmentListRelationFilter
    createdPayments?: PaymentListRelationFilter
    updatedPayments?: PaymentListRelationFilter
    approvedQuotations?: QuotationListRelationFilter
    assignedTasks?: TaskListRelationFilter
    loggedCommunications?: CommunicationListRelationFilter
    managedProjects?: ProjectListRelationFilter
    memberOfProjects?: ProjectListRelationFilter
  }

  export type StaffUserOrderByWithRelationInput = {
    staffId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    designation?: SortOrder
    contactNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdOpportunities?: OpportunityOrderByRelationAggregateInput
    updatedOpportunities?: OpportunityOrderByRelationAggregateInput
    createdQuotations?: QuotationOrderByRelationAggregateInput
    updatedQuotations?: QuotationOrderByRelationAggregateInput
    createdOrders?: OrderOrderByRelationAggregateInput
    updatedOrders?: OrderOrderByRelationAggregateInput
    createdShipments?: ShipmentOrderByRelationAggregateInput
    updatedShipments?: ShipmentOrderByRelationAggregateInput
    createdPayments?: PaymentOrderByRelationAggregateInput
    updatedPayments?: PaymentOrderByRelationAggregateInput
    approvedQuotations?: QuotationOrderByRelationAggregateInput
    assignedTasks?: TaskOrderByRelationAggregateInput
    loggedCommunications?: CommunicationOrderByRelationAggregateInput
    managedProjects?: ProjectOrderByRelationAggregateInput
    memberOfProjects?: ProjectOrderByRelationAggregateInput
  }

  export type StaffUserWhereUniqueInput = Prisma.AtLeast<{
    staffId?: string
    email?: string
    AND?: StaffUserWhereInput | StaffUserWhereInput[]
    OR?: StaffUserWhereInput[]
    NOT?: StaffUserWhereInput | StaffUserWhereInput[]
    name?: StringFilter<"StaffUser"> | string
    designation?: StringFilter<"StaffUser"> | string
    contactNumber?: StringNullableFilter<"StaffUser"> | string | null
    createdAt?: DateTimeFilter<"StaffUser"> | Date | string
    updatedAt?: DateTimeFilter<"StaffUser"> | Date | string
    createdOpportunities?: OpportunityListRelationFilter
    updatedOpportunities?: OpportunityListRelationFilter
    createdQuotations?: QuotationListRelationFilter
    updatedQuotations?: QuotationListRelationFilter
    createdOrders?: OrderListRelationFilter
    updatedOrders?: OrderListRelationFilter
    createdShipments?: ShipmentListRelationFilter
    updatedShipments?: ShipmentListRelationFilter
    createdPayments?: PaymentListRelationFilter
    updatedPayments?: PaymentListRelationFilter
    approvedQuotations?: QuotationListRelationFilter
    assignedTasks?: TaskListRelationFilter
    loggedCommunications?: CommunicationListRelationFilter
    managedProjects?: ProjectListRelationFilter
    memberOfProjects?: ProjectListRelationFilter
  }, "staffId" | "email">

  export type StaffUserOrderByWithAggregationInput = {
    staffId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    designation?: SortOrder
    contactNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffUserCountOrderByAggregateInput
    _max?: StaffUserMaxOrderByAggregateInput
    _min?: StaffUserMinOrderByAggregateInput
  }

  export type StaffUserScalarWhereWithAggregatesInput = {
    AND?: StaffUserScalarWhereWithAggregatesInput | StaffUserScalarWhereWithAggregatesInput[]
    OR?: StaffUserScalarWhereWithAggregatesInput[]
    NOT?: StaffUserScalarWhereWithAggregatesInput | StaffUserScalarWhereWithAggregatesInput[]
    staffId?: UuidWithAggregatesFilter<"StaffUser"> | string
    name?: StringWithAggregatesFilter<"StaffUser"> | string
    email?: StringWithAggregatesFilter<"StaffUser"> | string
    designation?: StringWithAggregatesFilter<"StaffUser"> | string
    contactNumber?: StringNullableWithAggregatesFilter<"StaffUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StaffUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StaffUser"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: UuidFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignedUserId?: UuidNullableFilter<"Task"> | string | null
    assignedUser?: XOR<StaffUserNullableScalarRelationFilter, StaffUserWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    assignedUser?: StaffUserOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignedUserId?: UuidNullableFilter<"Task"> | string | null
    assignedUser?: XOR<StaffUserNullableScalarRelationFilter, StaffUserWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    assignedUserId?: UuidNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: UuidFilter<"Customer"> | string
    cid?: StringFilter<"Customer"> | string
    customerType?: StringFilter<"Customer"> | string
    businessName?: StringFilter<"Customer"> | string
    salutation?: StringNullableFilter<"Customer"> | string | null
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    currency?: EnumCurrencyFilter<"Customer"> | $Enums.Currency
    gstin?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    opportunities?: OpportunityListRelationFilter
    projects?: ProjectListRelationFilter
    communications?: CommunicationListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    cid?: SortOrder
    customerType?: SortOrder
    businessName?: SortOrder
    salutation?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    currency?: SortOrder
    gstin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    opportunities?: OpportunityOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    communications?: CommunicationOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cid?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    customerType?: StringFilter<"Customer"> | string
    businessName?: StringFilter<"Customer"> | string
    salutation?: StringNullableFilter<"Customer"> | string | null
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    currency?: EnumCurrencyFilter<"Customer"> | $Enums.Currency
    gstin?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    opportunities?: OpportunityListRelationFilter
    projects?: ProjectListRelationFilter
    communications?: CommunicationListRelationFilter
  }, "id" | "cid" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    cid?: SortOrder
    customerType?: SortOrder
    businessName?: SortOrder
    salutation?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    currency?: SortOrder
    gstin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Customer"> | string
    cid?: StringWithAggregatesFilter<"Customer"> | string
    customerType?: StringWithAggregatesFilter<"Customer"> | string
    businessName?: StringWithAggregatesFilter<"Customer"> | string
    salutation?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    firstName?: StringWithAggregatesFilter<"Customer"> | string
    lastName?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    currency?: EnumCurrencyWithAggregatesFilter<"Customer"> | $Enums.Currency
    gstin?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type OpportunityWhereInput = {
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    id?: UuidFilter<"Opportunity"> | string
    oppRef?: StringFilter<"Opportunity"> | string
    title?: StringFilter<"Opportunity"> | string
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    value?: FloatFilter<"Opportunity"> | number
    currency?: EnumCurrencyFilter<"Opportunity"> | $Enums.Currency
    description?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    customerId?: UuidFilter<"Opportunity"> | string
    createdById?: UuidFilter<"Opportunity"> | string
    updatedById?: UuidFilter<"Opportunity"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    quotations?: QuotationListRelationFilter
    orders?: OrderListRelationFilter
    documents?: DocumentListRelationFilter
    communications?: CommunicationListRelationFilter
  }

  export type OpportunityOrderByWithRelationInput = {
    id?: SortOrder
    oppRef?: SortOrder
    title?: SortOrder
    status?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    createdBy?: StaffUserOrderByWithRelationInput
    updatedBy?: StaffUserOrderByWithRelationInput
    quotations?: QuotationOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    communications?: CommunicationOrderByRelationAggregateInput
  }

  export type OpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    oppRef?: string
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    title?: StringFilter<"Opportunity"> | string
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    value?: FloatFilter<"Opportunity"> | number
    currency?: EnumCurrencyFilter<"Opportunity"> | $Enums.Currency
    description?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    customerId?: UuidFilter<"Opportunity"> | string
    createdById?: UuidFilter<"Opportunity"> | string
    updatedById?: UuidFilter<"Opportunity"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    quotations?: QuotationListRelationFilter
    orders?: OrderListRelationFilter
    documents?: DocumentListRelationFilter
    communications?: CommunicationListRelationFilter
  }, "id" | "oppRef">

  export type OpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    oppRef?: SortOrder
    title?: SortOrder
    status?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    _count?: OpportunityCountOrderByAggregateInput
    _avg?: OpportunityAvgOrderByAggregateInput
    _max?: OpportunityMaxOrderByAggregateInput
    _min?: OpportunityMinOrderByAggregateInput
    _sum?: OpportunitySumOrderByAggregateInput
  }

  export type OpportunityScalarWhereWithAggregatesInput = {
    AND?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    OR?: OpportunityScalarWhereWithAggregatesInput[]
    NOT?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Opportunity"> | string
    oppRef?: StringWithAggregatesFilter<"Opportunity"> | string
    title?: StringWithAggregatesFilter<"Opportunity"> | string
    status?: EnumOpportunityStatusWithAggregatesFilter<"Opportunity"> | $Enums.OpportunityStatus
    value?: FloatWithAggregatesFilter<"Opportunity"> | number
    currency?: EnumCurrencyWithAggregatesFilter<"Opportunity"> | $Enums.Currency
    description?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    customerId?: UuidWithAggregatesFilter<"Opportunity"> | string
    createdById?: UuidWithAggregatesFilter<"Opportunity"> | string
    updatedById?: UuidWithAggregatesFilter<"Opportunity"> | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: UuidFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    customerId?: UuidFilter<"Project"> | string
    projectManagerId?: UuidNullableFilter<"Project"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    projectManager?: XOR<StaffUserNullableScalarRelationFilter, StaffUserWhereInput> | null
    teamMembers?: StaffUserListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    projectManagerId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    projectManager?: StaffUserOrderByWithRelationInput
    teamMembers?: StaffUserOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    customerId?: UuidFilter<"Project"> | string
    projectManagerId?: UuidNullableFilter<"Project"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    projectManager?: XOR<StaffUserNullableScalarRelationFilter, StaffUserWhereInput> | null
    teamMembers?: StaffUserListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    projectManagerId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    customerId?: UuidWithAggregatesFilter<"Project"> | string
    projectManagerId?: UuidNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type QuotationWhereInput = {
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    id?: UuidFilter<"Quotation"> | string
    quoteRef?: StringFilter<"Quotation"> | string
    revision?: IntFilter<"Quotation"> | number
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    currency?: EnumCurrencyFilter<"Quotation"> | $Enums.Currency
    fxRate?: FloatFilter<"Quotation"> | number
    totalCost?: FloatFilter<"Quotation"> | number
    markupPercent?: FloatFilter<"Quotation"> | number
    insurancePercent?: FloatFilter<"Quotation"> | number
    financeCharge?: FloatFilter<"Quotation"> | number
    subtotal?: FloatFilter<"Quotation"> | number
    vatPercent?: FloatFilter<"Quotation"> | number
    totalWithVAT?: FloatFilter<"Quotation"> | number
    profitMarginBHD?: FloatFilter<"Quotation"> | number
    fxGain?: FloatNullableFilter<"Quotation"> | number | null
    validUntil?: DateTimeFilter<"Quotation"> | Date | string
    paymentTerms?: StringNullableFilter<"Quotation"> | string | null
    deliveryTerms?: StringNullableFilter<"Quotation"> | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    marginApprovalPopup?: BoolFilter<"Quotation"> | boolean
    approvedById?: UuidNullableFilter<"Quotation"> | string | null
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
    createdById?: UuidFilter<"Quotation"> | string
    updatedById?: UuidFilter<"Quotation"> | string
    opportunityId?: UuidFilter<"Quotation"> | string
    approvedBy?: XOR<StaffUserNullableScalarRelationFilter, StaffUserWhereInput> | null
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
    items?: QuoteItemListRelationFilter
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    documents?: DocumentListRelationFilter
    communications?: CommunicationListRelationFilter
  }

  export type QuotationOrderByWithRelationInput = {
    id?: SortOrder
    quoteRef?: SortOrder
    revision?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    fxRate?: SortOrder
    totalCost?: SortOrder
    markupPercent?: SortOrder
    insurancePercent?: SortOrder
    financeCharge?: SortOrder
    subtotal?: SortOrder
    vatPercent?: SortOrder
    totalWithVAT?: SortOrder
    profitMarginBHD?: SortOrder
    fxGain?: SortOrderInput | SortOrder
    validUntil?: SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    deliveryTerms?: SortOrderInput | SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    marginApprovalPopup?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
    approvedBy?: StaffUserOrderByWithRelationInput
    createdBy?: StaffUserOrderByWithRelationInput
    updatedBy?: StaffUserOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
    items?: QuoteItemOrderByRelationAggregateInput
    order?: OrderOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    communications?: CommunicationOrderByRelationAggregateInput
  }

  export type QuotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quoteRef?: string
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    revision?: IntFilter<"Quotation"> | number
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    currency?: EnumCurrencyFilter<"Quotation"> | $Enums.Currency
    fxRate?: FloatFilter<"Quotation"> | number
    totalCost?: FloatFilter<"Quotation"> | number
    markupPercent?: FloatFilter<"Quotation"> | number
    insurancePercent?: FloatFilter<"Quotation"> | number
    financeCharge?: FloatFilter<"Quotation"> | number
    subtotal?: FloatFilter<"Quotation"> | number
    vatPercent?: FloatFilter<"Quotation"> | number
    totalWithVAT?: FloatFilter<"Quotation"> | number
    profitMarginBHD?: FloatFilter<"Quotation"> | number
    fxGain?: FloatNullableFilter<"Quotation"> | number | null
    validUntil?: DateTimeFilter<"Quotation"> | Date | string
    paymentTerms?: StringNullableFilter<"Quotation"> | string | null
    deliveryTerms?: StringNullableFilter<"Quotation"> | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    marginApprovalPopup?: BoolFilter<"Quotation"> | boolean
    approvedById?: UuidNullableFilter<"Quotation"> | string | null
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
    createdById?: UuidFilter<"Quotation"> | string
    updatedById?: UuidFilter<"Quotation"> | string
    opportunityId?: UuidFilter<"Quotation"> | string
    approvedBy?: XOR<StaffUserNullableScalarRelationFilter, StaffUserWhereInput> | null
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
    items?: QuoteItemListRelationFilter
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    documents?: DocumentListRelationFilter
    communications?: CommunicationListRelationFilter
  }, "id" | "quoteRef">

  export type QuotationOrderByWithAggregationInput = {
    id?: SortOrder
    quoteRef?: SortOrder
    revision?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    fxRate?: SortOrder
    totalCost?: SortOrder
    markupPercent?: SortOrder
    insurancePercent?: SortOrder
    financeCharge?: SortOrder
    subtotal?: SortOrder
    vatPercent?: SortOrder
    totalWithVAT?: SortOrder
    profitMarginBHD?: SortOrder
    fxGain?: SortOrderInput | SortOrder
    validUntil?: SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    deliveryTerms?: SortOrderInput | SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    marginApprovalPopup?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
    _count?: QuotationCountOrderByAggregateInput
    _avg?: QuotationAvgOrderByAggregateInput
    _max?: QuotationMaxOrderByAggregateInput
    _min?: QuotationMinOrderByAggregateInput
    _sum?: QuotationSumOrderByAggregateInput
  }

  export type QuotationScalarWhereWithAggregatesInput = {
    AND?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    OR?: QuotationScalarWhereWithAggregatesInput[]
    NOT?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Quotation"> | string
    quoteRef?: StringWithAggregatesFilter<"Quotation"> | string
    revision?: IntWithAggregatesFilter<"Quotation"> | number
    status?: EnumQuotationStatusWithAggregatesFilter<"Quotation"> | $Enums.QuotationStatus
    currency?: EnumCurrencyWithAggregatesFilter<"Quotation"> | $Enums.Currency
    fxRate?: FloatWithAggregatesFilter<"Quotation"> | number
    totalCost?: FloatWithAggregatesFilter<"Quotation"> | number
    markupPercent?: FloatWithAggregatesFilter<"Quotation"> | number
    insurancePercent?: FloatWithAggregatesFilter<"Quotation"> | number
    financeCharge?: FloatWithAggregatesFilter<"Quotation"> | number
    subtotal?: FloatWithAggregatesFilter<"Quotation"> | number
    vatPercent?: FloatWithAggregatesFilter<"Quotation"> | number
    totalWithVAT?: FloatWithAggregatesFilter<"Quotation"> | number
    profitMarginBHD?: FloatWithAggregatesFilter<"Quotation"> | number
    fxGain?: FloatNullableWithAggregatesFilter<"Quotation"> | number | null
    validUntil?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    paymentTerms?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    deliveryTerms?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    expectedDeliveryDate?: DateTimeNullableWithAggregatesFilter<"Quotation"> | Date | string | null
    marginApprovalPopup?: BoolWithAggregatesFilter<"Quotation"> | boolean
    approvedById?: UuidNullableWithAggregatesFilter<"Quotation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
    createdById?: UuidWithAggregatesFilter<"Quotation"> | string
    updatedById?: UuidWithAggregatesFilter<"Quotation"> | string
    opportunityId?: UuidWithAggregatesFilter<"Quotation"> | string
  }

  export type QuoteItemWhereInput = {
    AND?: QuoteItemWhereInput | QuoteItemWhereInput[]
    OR?: QuoteItemWhereInput[]
    NOT?: QuoteItemWhereInput | QuoteItemWhereInput[]
    id?: UuidFilter<"QuoteItem"> | string
    description?: StringFilter<"QuoteItem"> | string
    quantity?: IntFilter<"QuoteItem"> | number
    unitPrice?: FloatFilter<"QuoteItem"> | number
    totalPrice?: FloatFilter<"QuoteItem"> | number
    unitCost?: FloatFilter<"QuoteItem"> | number
    totalCost?: FloatFilter<"QuoteItem"> | number
    createdAt?: DateTimeFilter<"QuoteItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteItem"> | Date | string
    quotationId?: UuidFilter<"QuoteItem"> | string
    quotation?: XOR<QuotationScalarRelationFilter, QuotationWhereInput>
  }

  export type QuoteItemOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrder
    quotation?: QuotationOrderByWithRelationInput
  }

  export type QuoteItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuoteItemWhereInput | QuoteItemWhereInput[]
    OR?: QuoteItemWhereInput[]
    NOT?: QuoteItemWhereInput | QuoteItemWhereInput[]
    description?: StringFilter<"QuoteItem"> | string
    quantity?: IntFilter<"QuoteItem"> | number
    unitPrice?: FloatFilter<"QuoteItem"> | number
    totalPrice?: FloatFilter<"QuoteItem"> | number
    unitCost?: FloatFilter<"QuoteItem"> | number
    totalCost?: FloatFilter<"QuoteItem"> | number
    createdAt?: DateTimeFilter<"QuoteItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteItem"> | Date | string
    quotationId?: UuidFilter<"QuoteItem"> | string
    quotation?: XOR<QuotationScalarRelationFilter, QuotationWhereInput>
  }, "id">

  export type QuoteItemOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrder
    _count?: QuoteItemCountOrderByAggregateInput
    _avg?: QuoteItemAvgOrderByAggregateInput
    _max?: QuoteItemMaxOrderByAggregateInput
    _min?: QuoteItemMinOrderByAggregateInput
    _sum?: QuoteItemSumOrderByAggregateInput
  }

  export type QuoteItemScalarWhereWithAggregatesInput = {
    AND?: QuoteItemScalarWhereWithAggregatesInput | QuoteItemScalarWhereWithAggregatesInput[]
    OR?: QuoteItemScalarWhereWithAggregatesInput[]
    NOT?: QuoteItemScalarWhereWithAggregatesInput | QuoteItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QuoteItem"> | string
    description?: StringWithAggregatesFilter<"QuoteItem"> | string
    quantity?: IntWithAggregatesFilter<"QuoteItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"QuoteItem"> | number
    totalPrice?: FloatWithAggregatesFilter<"QuoteItem"> | number
    unitCost?: FloatWithAggregatesFilter<"QuoteItem"> | number
    totalCost?: FloatWithAggregatesFilter<"QuoteItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuoteItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuoteItem"> | Date | string
    quotationId?: UuidWithAggregatesFilter<"QuoteItem"> | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: UuidFilter<"Order"> | string
    orderRef?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"Order"> | Date | string
    totalValue?: FloatFilter<"Order"> | number
    currency?: EnumCurrencyFilter<"Order"> | $Enums.Currency
    expectedDeliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    createdById?: UuidFilter<"Order"> | string
    updatedById?: UuidFilter<"Order"> | string
    opportunityId?: UuidFilter<"Order"> | string
    quotationId?: UuidFilter<"Order"> | string
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
    quotation?: XOR<QuotationScalarRelationFilter, QuotationWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    shipments?: ShipmentListRelationFilter
    payments?: PaymentListRelationFilter
    documents?: DocumentListRelationFilter
    communications?: CommunicationListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderRef?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
    createdBy?: StaffUserOrderByWithRelationInput
    updatedBy?: StaffUserOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
    quotation?: QuotationOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    shipments?: ShipmentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    communications?: CommunicationOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderRef?: string
    quotationId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"Order"> | Date | string
    totalValue?: FloatFilter<"Order"> | number
    currency?: EnumCurrencyFilter<"Order"> | $Enums.Currency
    expectedDeliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    createdById?: UuidFilter<"Order"> | string
    updatedById?: UuidFilter<"Order"> | string
    opportunityId?: UuidFilter<"Order"> | string
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
    quotation?: XOR<QuotationScalarRelationFilter, QuotationWhereInput>
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    shipments?: ShipmentListRelationFilter
    payments?: PaymentListRelationFilter
    documents?: DocumentListRelationFilter
    communications?: CommunicationListRelationFilter
  }, "id" | "orderRef" | "quotationId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderRef?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Order"> | string
    orderRef?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    orderDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    totalValue?: FloatWithAggregatesFilter<"Order"> | number
    currency?: EnumCurrencyWithAggregatesFilter<"Order"> | $Enums.Currency
    expectedDeliveryDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    createdById?: UuidWithAggregatesFilter<"Order"> | string
    updatedById?: UuidWithAggregatesFilter<"Order"> | string
    opportunityId?: UuidWithAggregatesFilter<"Order"> | string
    quotationId?: UuidWithAggregatesFilter<"Order"> | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: UuidFilter<"PurchaseOrder"> | string
    poRef?: StringFilter<"PurchaseOrder"> | string
    issueDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    supplier?: StringFilter<"PurchaseOrder"> | string
    totalValue?: FloatFilter<"PurchaseOrder"> | number
    currency?: EnumCurrencyFilter<"PurchaseOrder"> | $Enums.Currency
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    orderId?: UuidFilter<"PurchaseOrder"> | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    documents?: DocumentListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    poRef?: SortOrder
    issueDate?: SortOrder
    supplier?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    order?: OrderOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    poRef?: string
    orderId?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    issueDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    supplier?: StringFilter<"PurchaseOrder"> | string
    totalValue?: FloatFilter<"PurchaseOrder"> | number
    currency?: EnumCurrencyFilter<"PurchaseOrder"> | $Enums.Currency
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    documents?: DocumentListRelationFilter
  }, "id" | "poRef" | "orderId">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    poRef?: SortOrder
    issueDate?: SortOrder
    supplier?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PurchaseOrder"> | string
    poRef?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    issueDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    supplier?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    totalValue?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    currency?: EnumCurrencyWithAggregatesFilter<"PurchaseOrder"> | $Enums.Currency
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    orderId?: UuidWithAggregatesFilter<"PurchaseOrder"> | string
  }

  export type ShipmentWhereInput = {
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    id?: UuidFilter<"Shipment"> | string
    shipmentRef?: StringFilter<"Shipment"> | string
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    trackingNumber?: StringNullableFilter<"Shipment"> | string | null
    carrier?: StringNullableFilter<"Shipment"> | string | null
    shippedOn?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    actualShipmentDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeFilter<"Shipment"> | Date | string
    createdById?: UuidFilter<"Shipment"> | string
    updatedById?: UuidFilter<"Shipment"> | string
    orderId?: UuidFilter<"Shipment"> | string
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    payments?: PaymentListRelationFilter
    documents?: DocumentListRelationFilter
  }

  export type ShipmentOrderByWithRelationInput = {
    id?: SortOrder
    shipmentRef?: SortOrder
    status?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    shippedOn?: SortOrderInput | SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    actualShipmentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
    createdBy?: StaffUserOrderByWithRelationInput
    updatedBy?: StaffUserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type ShipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shipmentRef?: string
    AND?: ShipmentWhereInput | ShipmentWhereInput[]
    OR?: ShipmentWhereInput[]
    NOT?: ShipmentWhereInput | ShipmentWhereInput[]
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    trackingNumber?: StringNullableFilter<"Shipment"> | string | null
    carrier?: StringNullableFilter<"Shipment"> | string | null
    shippedOn?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    actualShipmentDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeFilter<"Shipment"> | Date | string
    createdById?: UuidFilter<"Shipment"> | string
    updatedById?: UuidFilter<"Shipment"> | string
    orderId?: UuidFilter<"Shipment"> | string
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    payments?: PaymentListRelationFilter
    documents?: DocumentListRelationFilter
  }, "id" | "shipmentRef">

  export type ShipmentOrderByWithAggregationInput = {
    id?: SortOrder
    shipmentRef?: SortOrder
    status?: SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    carrier?: SortOrderInput | SortOrder
    shippedOn?: SortOrderInput | SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    actualShipmentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
    _count?: ShipmentCountOrderByAggregateInput
    _max?: ShipmentMaxOrderByAggregateInput
    _min?: ShipmentMinOrderByAggregateInput
  }

  export type ShipmentScalarWhereWithAggregatesInput = {
    AND?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    OR?: ShipmentScalarWhereWithAggregatesInput[]
    NOT?: ShipmentScalarWhereWithAggregatesInput | ShipmentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Shipment"> | string
    shipmentRef?: StringWithAggregatesFilter<"Shipment"> | string
    status?: EnumShipmentStatusWithAggregatesFilter<"Shipment"> | $Enums.ShipmentStatus
    trackingNumber?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    carrier?: StringNullableWithAggregatesFilter<"Shipment"> | string | null
    shippedOn?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    actualShipmentDate?: DateTimeNullableWithAggregatesFilter<"Shipment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shipment"> | Date | string
    createdById?: UuidWithAggregatesFilter<"Shipment"> | string
    updatedById?: UuidWithAggregatesFilter<"Shipment"> | string
    orderId?: UuidWithAggregatesFilter<"Shipment"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    paymentRef?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: EnumCurrencyFilter<"Payment"> | $Enums.Currency
    paymentMethod?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentReceivedOn?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    createdById?: UuidFilter<"Payment"> | string
    updatedById?: UuidFilter<"Payment"> | string
    orderId?: UuidFilter<"Payment"> | string
    shipmentId?: UuidNullableFilter<"Payment"> | string | null
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    shipment?: XOR<ShipmentNullableScalarRelationFilter, ShipmentWhereInput> | null
    documents?: DocumentListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentRef?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    paymentReceivedOn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
    shipmentId?: SortOrderInput | SortOrder
    createdBy?: StaffUserOrderByWithRelationInput
    updatedBy?: StaffUserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentRef?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    currency?: EnumCurrencyFilter<"Payment"> | $Enums.Currency
    paymentMethod?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentReceivedOn?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    createdById?: UuidFilter<"Payment"> | string
    updatedById?: UuidFilter<"Payment"> | string
    orderId?: UuidFilter<"Payment"> | string
    shipmentId?: UuidNullableFilter<"Payment"> | string | null
    createdBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    updatedBy?: XOR<StaffUserScalarRelationFilter, StaffUserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    shipment?: XOR<ShipmentNullableScalarRelationFilter, ShipmentWhereInput> | null
    documents?: DocumentListRelationFilter
  }, "id" | "paymentRef">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentRef?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    paymentReceivedOn?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
    shipmentId?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    paymentRef?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: EnumCurrencyWithAggregatesFilter<"Payment"> | $Enums.Currency
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentReceivedOn?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    createdById?: UuidWithAggregatesFilter<"Payment"> | string
    updatedById?: UuidWithAggregatesFilter<"Payment"> | string
    orderId?: UuidWithAggregatesFilter<"Payment"> | string
    shipmentId?: UuidNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: UuidFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    sizeBytes?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
    opportunityId?: UuidNullableFilter<"Document"> | string | null
    quotationId?: UuidNullableFilter<"Document"> | string | null
    orderId?: UuidNullableFilter<"Document"> | string | null
    purchaseOrderId?: UuidNullableFilter<"Document"> | string | null
    shipmentId?: UuidNullableFilter<"Document"> | string | null
    paymentId?: UuidNullableFilter<"Document"> | string | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    shipment?: XOR<ShipmentNullableScalarRelationFilter, ShipmentWhereInput> | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    opportunityId?: SortOrderInput | SortOrder
    quotationId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    shipmentId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    opportunity?: OpportunityOrderByWithRelationInput
    quotation?: QuotationOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    shipment?: ShipmentOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    fileName?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    sizeBytes?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
    opportunityId?: UuidNullableFilter<"Document"> | string | null
    quotationId?: UuidNullableFilter<"Document"> | string | null
    orderId?: UuidNullableFilter<"Document"> | string | null
    purchaseOrderId?: UuidNullableFilter<"Document"> | string | null
    shipmentId?: UuidNullableFilter<"Document"> | string | null
    paymentId?: UuidNullableFilter<"Document"> | string | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    shipment?: XOR<ShipmentNullableScalarRelationFilter, ShipmentWhereInput> | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    opportunityId?: SortOrderInput | SortOrder
    quotationId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    shipmentId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Document"> | string
    fileName?: StringWithAggregatesFilter<"Document"> | string
    fileType?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    sizeBytes?: IntWithAggregatesFilter<"Document"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    opportunityId?: UuidNullableWithAggregatesFilter<"Document"> | string | null
    quotationId?: UuidNullableWithAggregatesFilter<"Document"> | string | null
    orderId?: UuidNullableWithAggregatesFilter<"Document"> | string | null
    purchaseOrderId?: UuidNullableWithAggregatesFilter<"Document"> | string | null
    shipmentId?: UuidNullableWithAggregatesFilter<"Document"> | string | null
    paymentId?: UuidNullableWithAggregatesFilter<"Document"> | string | null
  }

  export type CommunicationWhereInput = {
    AND?: CommunicationWhereInput | CommunicationWhereInput[]
    OR?: CommunicationWhereInput[]
    NOT?: CommunicationWhereInput | CommunicationWhereInput[]
    id?: UuidFilter<"Communication"> | string
    type?: EnumCommunicationTypeFilter<"Communication"> | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFilter<"Communication"> | $Enums.CommunicationDirection
    content?: StringFilter<"Communication"> | string
    subject?: StringNullableFilter<"Communication"> | string | null
    sender?: StringFilter<"Communication"> | string
    recipient?: StringNullableFilter<"Communication"> | string | null
    timestamp?: DateTimeFilter<"Communication"> | Date | string
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
    customerId?: UuidNullableFilter<"Communication"> | string | null
    opportunityId?: UuidNullableFilter<"Communication"> | string | null
    quotationId?: UuidNullableFilter<"Communication"> | string | null
    orderId?: UuidNullableFilter<"Communication"> | string | null
    loggedByStaffId?: UuidNullableFilter<"Communication"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    loggedBy?: XOR<StaffUserNullableScalarRelationFilter, StaffUserWhereInput> | null
  }

  export type CommunicationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    content?: SortOrder
    subject?: SortOrderInput | SortOrder
    sender?: SortOrder
    recipient?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    quotationId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    loggedByStaffId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
    quotation?: QuotationOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    loggedBy?: StaffUserOrderByWithRelationInput
  }

  export type CommunicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunicationWhereInput | CommunicationWhereInput[]
    OR?: CommunicationWhereInput[]
    NOT?: CommunicationWhereInput | CommunicationWhereInput[]
    type?: EnumCommunicationTypeFilter<"Communication"> | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFilter<"Communication"> | $Enums.CommunicationDirection
    content?: StringFilter<"Communication"> | string
    subject?: StringNullableFilter<"Communication"> | string | null
    sender?: StringFilter<"Communication"> | string
    recipient?: StringNullableFilter<"Communication"> | string | null
    timestamp?: DateTimeFilter<"Communication"> | Date | string
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
    customerId?: UuidNullableFilter<"Communication"> | string | null
    opportunityId?: UuidNullableFilter<"Communication"> | string | null
    quotationId?: UuidNullableFilter<"Communication"> | string | null
    orderId?: UuidNullableFilter<"Communication"> | string | null
    loggedByStaffId?: UuidNullableFilter<"Communication"> | string | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    loggedBy?: XOR<StaffUserNullableScalarRelationFilter, StaffUserWhereInput> | null
  }, "id">

  export type CommunicationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    content?: SortOrder
    subject?: SortOrderInput | SortOrder
    sender?: SortOrder
    recipient?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    quotationId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    loggedByStaffId?: SortOrderInput | SortOrder
    _count?: CommunicationCountOrderByAggregateInput
    _max?: CommunicationMaxOrderByAggregateInput
    _min?: CommunicationMinOrderByAggregateInput
  }

  export type CommunicationScalarWhereWithAggregatesInput = {
    AND?: CommunicationScalarWhereWithAggregatesInput | CommunicationScalarWhereWithAggregatesInput[]
    OR?: CommunicationScalarWhereWithAggregatesInput[]
    NOT?: CommunicationScalarWhereWithAggregatesInput | CommunicationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Communication"> | string
    type?: EnumCommunicationTypeWithAggregatesFilter<"Communication"> | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionWithAggregatesFilter<"Communication"> | $Enums.CommunicationDirection
    content?: StringWithAggregatesFilter<"Communication"> | string
    subject?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    sender?: StringWithAggregatesFilter<"Communication"> | string
    recipient?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
    customerId?: UuidNullableWithAggregatesFilter<"Communication"> | string | null
    opportunityId?: UuidNullableWithAggregatesFilter<"Communication"> | string | null
    quotationId?: UuidNullableWithAggregatesFilter<"Communication"> | string | null
    orderId?: UuidNullableWithAggregatesFilter<"Communication"> | string | null
    loggedByStaffId?: UuidNullableWithAggregatesFilter<"Communication"> | string | null
  }

  export type StaffUserCreateInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUpdateInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserCreateManyInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUserUpdateManyMutationInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUserUncheckedUpdateManyInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUser?: StaffUserCreateNestedOneWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUser?: StaffUserUpdateOneWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    communications?: CommunicationCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    communications?: CommunicationUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityCreateInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedOpportunitiesInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOpportunitiesInput
    quotations?: QuotationCreateNestedManyWithoutOpportunityInput
    orders?: OrderCreateNestedManyWithoutOpportunityInput
    documents?: DocumentCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    createdById: string
    updatedById: string
    quotations?: QuotationUncheckedCreateNestedManyWithoutOpportunityInput
    orders?: OrderUncheckedCreateNestedManyWithoutOpportunityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOpportunitiesNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOpportunitiesNestedInput
    quotations?: QuotationUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    quotations?: QuotationUncheckedUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityCreateManyInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    createdById: string
    updatedById: string
  }

  export type OpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProjectsInput
    projectManager?: StaffUserCreateNestedOneWithoutManagedProjectsInput
    teamMembers?: StaffUserCreateNestedManyWithoutMemberOfProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    projectManagerId?: string | null
    teamMembers?: StaffUserUncheckedCreateNestedManyWithoutMemberOfProjectsInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    projectManager?: StaffUserUpdateOneWithoutManagedProjectsNestedInput
    teamMembers?: StaffUserUpdateManyWithoutMemberOfProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamMembers?: StaffUserUncheckedUpdateManyWithoutMemberOfProjectsNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    projectManagerId?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationCreateInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: StaffUserCreateNestedOneWithoutApprovedQuotationsInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedQuotationsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedQuotationsInput
    opportunity: OpportunityCreateNestedOneWithoutQuotationsInput
    items?: QuoteItemCreateNestedManyWithoutQuotationInput
    order?: OrderCreateNestedOneWithoutQuotationInput
    documents?: DocumentCreateNestedManyWithoutQuotationInput
    communications?: CommunicationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuotationInput
    order?: OrderUncheckedCreateNestedOneWithoutQuotationInput
    documents?: DocumentUncheckedCreateNestedManyWithoutQuotationInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StaffUserUpdateOneWithoutApprovedQuotationsNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuoteItemUpdateManyWithoutQuotationNestedInput
    order?: OrderUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput
    order?: OrderUncheckedUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationCreateManyInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
  }

  export type QuotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type QuoteItemCreateInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    unitCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quotation: QuotationCreateNestedOneWithoutItemsInput
  }

  export type QuoteItemUncheckedCreateInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    unitCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId: string
  }

  export type QuoteItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation?: QuotationUpdateOneRequiredWithoutItemsNestedInput
  }

  export type QuoteItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: StringFieldUpdateOperationsInput | string
  }

  export type QuoteItemCreateManyInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    unitCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quotationId: string
  }

  export type QuoteItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    quotationId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    quotationId: string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    poRef: string
    issueDate?: Date | string
    supplier: string
    totalValue: number
    currency?: $Enums.Currency
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPurchaseOrderInput
    documents?: DocumentCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    poRef: string
    issueDate?: Date | string
    supplier: string
    totalValue: number
    currency?: $Enums.Currency
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poRef?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPurchaseOrderNestedInput
    documents?: DocumentUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poRef?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    poRef: string
    issueDate?: Date | string
    supplier: string
    totalValue: number
    currency?: $Enums.Currency
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poRef?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poRef?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type ShipmentCreateInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedShipmentsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedShipmentsInput
    order: OrderCreateNestedOneWithoutShipmentsInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    documents?: DocumentCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedShipmentsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedShipmentsNestedInput
    order?: OrderUpdateOneRequiredWithoutShipmentsNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    documents?: DocumentUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentCreateManyInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
  }

  export type ShipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedPaymentsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
    shipment?: ShipmentCreateNestedOneWithoutPaymentsInput
    documents?: DocumentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
    shipmentId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedPaymentsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    shipment?: ShipmentUpdateOneWithoutPaymentsNestedInput
    documents?: DocumentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
    shipmentId?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutDocumentsInput
    quotation?: QuotationCreateNestedOneWithoutDocumentsInput
    order?: OrderCreateNestedOneWithoutDocumentsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutDocumentsInput
    shipment?: ShipmentCreateNestedOneWithoutDocumentsInput
    payment?: PaymentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutDocumentsNestedInput
    quotation?: QuotationUpdateOneWithoutDocumentsNestedInput
    order?: OrderUpdateOneWithoutDocumentsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutDocumentsNestedInput
    shipment?: ShipmentUpdateOneWithoutDocumentsNestedInput
    payment?: PaymentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationCreateInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutCommunicationsInput
    opportunity?: OpportunityCreateNestedOneWithoutCommunicationsInput
    quotation?: QuotationCreateNestedOneWithoutCommunicationsInput
    order?: OrderCreateNestedOneWithoutCommunicationsInput
    loggedBy?: StaffUserCreateNestedOneWithoutLoggedCommunicationsInput
  }

  export type CommunicationUncheckedCreateInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    loggedByStaffId?: string | null
  }

  export type CommunicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutCommunicationsNestedInput
    opportunity?: OpportunityUpdateOneWithoutCommunicationsNestedInput
    quotation?: QuotationUpdateOneWithoutCommunicationsNestedInput
    order?: OrderUpdateOneWithoutCommunicationsNestedInput
    loggedBy?: StaffUserUpdateOneWithoutLoggedCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationCreateManyInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    loggedByStaffId?: string | null
  }

  export type CommunicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OpportunityListRelationFilter = {
    every?: OpportunityWhereInput
    some?: OpportunityWhereInput
    none?: OpportunityWhereInput
  }

  export type QuotationListRelationFilter = {
    every?: QuotationWhereInput
    some?: QuotationWhereInput
    none?: QuotationWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ShipmentListRelationFilter = {
    every?: ShipmentWhereInput
    some?: ShipmentWhereInput
    none?: ShipmentWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type CommunicationListRelationFilter = {
    every?: CommunicationWhereInput
    some?: CommunicationWhereInput
    none?: CommunicationWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffUserCountOrderByAggregateInput = {
    staffId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    designation?: SortOrder
    contactNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffUserMaxOrderByAggregateInput = {
    staffId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    designation?: SortOrder
    contactNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffUserMinOrderByAggregateInput = {
    staffId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    designation?: SortOrder
    contactNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type StaffUserNullableScalarRelationFilter = {
    is?: StaffUserWhereInput | null
    isNot?: StaffUserWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumCurrencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyFilter<$PrismaModel> | $Enums.Currency
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    cid?: SortOrder
    customerType?: SortOrder
    businessName?: SortOrder
    salutation?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    gstin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    cid?: SortOrder
    customerType?: SortOrder
    businessName?: SortOrder
    salutation?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    gstin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    cid?: SortOrder
    customerType?: SortOrder
    businessName?: SortOrder
    salutation?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    currency?: SortOrder
    gstin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCurrencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyWithAggregatesFilter<$PrismaModel> | $Enums.Currency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyFilter<$PrismaModel>
    _max?: NestedEnumCurrencyFilter<$PrismaModel>
  }

  export type EnumOpportunityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusFilter<$PrismaModel> | $Enums.OpportunityStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type StaffUserScalarRelationFilter = {
    is?: StaffUserWhereInput
    isNot?: StaffUserWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    oppRef?: SortOrder
    title?: SortOrder
    status?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type OpportunityAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type OpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    oppRef?: SortOrder
    title?: SortOrder
    status?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type OpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    oppRef?: SortOrder
    title?: SortOrder
    status?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type OpportunitySumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumOpportunityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityStatusFilter<$PrismaModel>
    _max?: NestedEnumOpportunityStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type StaffUserListRelationFilter = {
    every?: StaffUserWhereInput
    some?: StaffUserWhereInput
    none?: StaffUserWhereInput
  }

  export type StaffUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    projectManagerId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    projectManagerId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    projectManagerId?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumQuotationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusFilter<$PrismaModel> | $Enums.QuotationStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type OpportunityScalarRelationFilter = {
    is?: OpportunityWhereInput
    isNot?: OpportunityWhereInput
  }

  export type QuoteItemListRelationFilter = {
    every?: QuoteItemWhereInput
    some?: QuoteItemWhereInput
    none?: QuoteItemWhereInput
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type QuoteItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotationCountOrderByAggregateInput = {
    id?: SortOrder
    quoteRef?: SortOrder
    revision?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    fxRate?: SortOrder
    totalCost?: SortOrder
    markupPercent?: SortOrder
    insurancePercent?: SortOrder
    financeCharge?: SortOrder
    subtotal?: SortOrder
    vatPercent?: SortOrder
    totalWithVAT?: SortOrder
    profitMarginBHD?: SortOrder
    fxGain?: SortOrder
    validUntil?: SortOrder
    paymentTerms?: SortOrder
    deliveryTerms?: SortOrder
    expectedDeliveryDate?: SortOrder
    marginApprovalPopup?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
  }

  export type QuotationAvgOrderByAggregateInput = {
    revision?: SortOrder
    fxRate?: SortOrder
    totalCost?: SortOrder
    markupPercent?: SortOrder
    insurancePercent?: SortOrder
    financeCharge?: SortOrder
    subtotal?: SortOrder
    vatPercent?: SortOrder
    totalWithVAT?: SortOrder
    profitMarginBHD?: SortOrder
    fxGain?: SortOrder
  }

  export type QuotationMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteRef?: SortOrder
    revision?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    fxRate?: SortOrder
    totalCost?: SortOrder
    markupPercent?: SortOrder
    insurancePercent?: SortOrder
    financeCharge?: SortOrder
    subtotal?: SortOrder
    vatPercent?: SortOrder
    totalWithVAT?: SortOrder
    profitMarginBHD?: SortOrder
    fxGain?: SortOrder
    validUntil?: SortOrder
    paymentTerms?: SortOrder
    deliveryTerms?: SortOrder
    expectedDeliveryDate?: SortOrder
    marginApprovalPopup?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
  }

  export type QuotationMinOrderByAggregateInput = {
    id?: SortOrder
    quoteRef?: SortOrder
    revision?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    fxRate?: SortOrder
    totalCost?: SortOrder
    markupPercent?: SortOrder
    insurancePercent?: SortOrder
    financeCharge?: SortOrder
    subtotal?: SortOrder
    vatPercent?: SortOrder
    totalWithVAT?: SortOrder
    profitMarginBHD?: SortOrder
    fxGain?: SortOrder
    validUntil?: SortOrder
    paymentTerms?: SortOrder
    deliveryTerms?: SortOrder
    expectedDeliveryDate?: SortOrder
    marginApprovalPopup?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
  }

  export type QuotationSumOrderByAggregateInput = {
    revision?: SortOrder
    fxRate?: SortOrder
    totalCost?: SortOrder
    markupPercent?: SortOrder
    insurancePercent?: SortOrder
    financeCharge?: SortOrder
    subtotal?: SortOrder
    vatPercent?: SortOrder
    totalWithVAT?: SortOrder
    profitMarginBHD?: SortOrder
    fxGain?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumQuotationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QuotationScalarRelationFilter = {
    is?: QuotationWhereInput
    isNot?: QuotationWhereInput
  }

  export type QuoteItemCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrder
  }

  export type QuoteItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type QuoteItemMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrder
  }

  export type QuoteItemMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotationId?: SortOrder
  }

  export type QuoteItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type PurchaseOrderNullableScalarRelationFilter = {
    is?: PurchaseOrderWhereInput | null
    isNot?: PurchaseOrderWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderRef?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    expectedDeliveryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalValue?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderRef?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    expectedDeliveryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderRef?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    expectedDeliveryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalValue?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    poRef?: SortOrder
    issueDate?: SortOrder
    supplier?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    totalValue?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    poRef?: SortOrder
    issueDate?: SortOrder
    supplier?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    poRef?: SortOrder
    issueDate?: SortOrder
    supplier?: SortOrder
    totalValue?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    totalValue?: SortOrder
  }

  export type EnumShipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusFilter<$PrismaModel> | $Enums.ShipmentStatus
  }

  export type ShipmentCountOrderByAggregateInput = {
    id?: SortOrder
    shipmentRef?: SortOrder
    status?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    shippedOn?: SortOrder
    expectedDeliveryDate?: SortOrder
    actualShipmentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
  }

  export type ShipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    shipmentRef?: SortOrder
    status?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    shippedOn?: SortOrder
    expectedDeliveryDate?: SortOrder
    actualShipmentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
  }

  export type ShipmentMinOrderByAggregateInput = {
    id?: SortOrder
    shipmentRef?: SortOrder
    status?: SortOrder
    trackingNumber?: SortOrder
    carrier?: SortOrder
    shippedOn?: SortOrder
    expectedDeliveryDate?: SortOrder
    actualShipmentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
  }

  export type EnumShipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumShipmentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type ShipmentNullableScalarRelationFilter = {
    is?: ShipmentWhereInput | null
    isNot?: ShipmentWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentRef?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    paymentReceivedOn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
    shipmentId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentRef?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    paymentReceivedOn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
    shipmentId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentRef?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    paymentReceivedOn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    orderId?: SortOrder
    shipmentId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type OpportunityNullableScalarRelationFilter = {
    is?: OpportunityWhereInput | null
    isNot?: OpportunityWhereInput | null
  }

  export type QuotationNullableScalarRelationFilter = {
    is?: QuotationWhereInput | null
    isNot?: QuotationWhereInput | null
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
    orderId?: SortOrder
    purchaseOrderId?: SortOrder
    shipmentId?: SortOrder
    paymentId?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
    orderId?: SortOrder
    purchaseOrderId?: SortOrder
    shipmentId?: SortOrder
    paymentId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    url?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
    orderId?: SortOrder
    purchaseOrderId?: SortOrder
    shipmentId?: SortOrder
    paymentId?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type EnumCommunicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeFilter<$PrismaModel> | $Enums.CommunicationType
  }

  export type EnumCommunicationDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationDirection | EnumCommunicationDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationDirection[] | ListEnumCommunicationDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationDirection[] | ListEnumCommunicationDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationDirectionFilter<$PrismaModel> | $Enums.CommunicationDirection
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type CommunicationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
    orderId?: SortOrder
    loggedByStaffId?: SortOrder
  }

  export type CommunicationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
    orderId?: SortOrder
    loggedByStaffId?: SortOrder
  }

  export type CommunicationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    direction?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerId?: SortOrder
    opportunityId?: SortOrder
    quotationId?: SortOrder
    orderId?: SortOrder
    loggedByStaffId?: SortOrder
  }

  export type EnumCommunicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationTypeFilter<$PrismaModel>
    _max?: NestedEnumCommunicationTypeFilter<$PrismaModel>
  }

  export type EnumCommunicationDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationDirection | EnumCommunicationDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationDirection[] | ListEnumCommunicationDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationDirection[] | ListEnumCommunicationDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationDirectionWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationDirectionFilter<$PrismaModel>
    _max?: NestedEnumCommunicationDirectionFilter<$PrismaModel>
  }

  export type OpportunityCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OpportunityCreateWithoutCreatedByInput, OpportunityUncheckedCreateWithoutCreatedByInput> | OpportunityCreateWithoutCreatedByInput[] | OpportunityUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCreatedByInput | OpportunityCreateOrConnectWithoutCreatedByInput[]
    createMany?: OpportunityCreateManyCreatedByInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<OpportunityCreateWithoutUpdatedByInput, OpportunityUncheckedCreateWithoutUpdatedByInput> | OpportunityCreateWithoutUpdatedByInput[] | OpportunityUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutUpdatedByInput | OpportunityCreateOrConnectWithoutUpdatedByInput[]
    createMany?: OpportunityCreateManyUpdatedByInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<QuotationCreateWithoutCreatedByInput, QuotationUncheckedCreateWithoutCreatedByInput> | QuotationCreateWithoutCreatedByInput[] | QuotationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutCreatedByInput | QuotationCreateOrConnectWithoutCreatedByInput[]
    createMany?: QuotationCreateManyCreatedByInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<QuotationCreateWithoutUpdatedByInput, QuotationUncheckedCreateWithoutUpdatedByInput> | QuotationCreateWithoutUpdatedByInput[] | QuotationUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutUpdatedByInput | QuotationCreateOrConnectWithoutUpdatedByInput[]
    createMany?: QuotationCreateManyUpdatedByInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<OrderCreateWithoutUpdatedByInput, OrderUncheckedCreateWithoutUpdatedByInput> | OrderCreateWithoutUpdatedByInput[] | OrderUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUpdatedByInput | OrderCreateOrConnectWithoutUpdatedByInput[]
    createMany?: OrderCreateManyUpdatedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ShipmentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ShipmentCreateWithoutCreatedByInput, ShipmentUncheckedCreateWithoutCreatedByInput> | ShipmentCreateWithoutCreatedByInput[] | ShipmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutCreatedByInput | ShipmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: ShipmentCreateManyCreatedByInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type ShipmentCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ShipmentCreateWithoutUpdatedByInput, ShipmentUncheckedCreateWithoutUpdatedByInput> | ShipmentCreateWithoutUpdatedByInput[] | ShipmentUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUpdatedByInput | ShipmentCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ShipmentCreateManyUpdatedByInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PaymentCreateWithoutUpdatedByInput, PaymentUncheckedCreateWithoutUpdatedByInput> | PaymentCreateWithoutUpdatedByInput[] | PaymentUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUpdatedByInput | PaymentCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PaymentCreateManyUpdatedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type QuotationCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput> | QuotationCreateWithoutApprovedByInput[] | QuotationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutApprovedByInput | QuotationCreateOrConnectWithoutApprovedByInput[]
    createMany?: QuotationCreateManyApprovedByInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<TaskCreateWithoutAssignedUserInput, TaskUncheckedCreateWithoutAssignedUserInput> | TaskCreateWithoutAssignedUserInput[] | TaskUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedUserInput | TaskCreateOrConnectWithoutAssignedUserInput[]
    createMany?: TaskCreateManyAssignedUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutLoggedByInput = {
    create?: XOR<CommunicationCreateWithoutLoggedByInput, CommunicationUncheckedCreateWithoutLoggedByInput> | CommunicationCreateWithoutLoggedByInput[] | CommunicationUncheckedCreateWithoutLoggedByInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutLoggedByInput | CommunicationCreateOrConnectWithoutLoggedByInput[]
    createMany?: CommunicationCreateManyLoggedByInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutProjectManagerInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutTeamMembersInput = {
    create?: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput> | ProjectCreateWithoutTeamMembersInput[] | ProjectUncheckedCreateWithoutTeamMembersInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput | ProjectCreateOrConnectWithoutTeamMembersInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OpportunityCreateWithoutCreatedByInput, OpportunityUncheckedCreateWithoutCreatedByInput> | OpportunityCreateWithoutCreatedByInput[] | OpportunityUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCreatedByInput | OpportunityCreateOrConnectWithoutCreatedByInput[]
    createMany?: OpportunityCreateManyCreatedByInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<OpportunityCreateWithoutUpdatedByInput, OpportunityUncheckedCreateWithoutUpdatedByInput> | OpportunityCreateWithoutUpdatedByInput[] | OpportunityUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutUpdatedByInput | OpportunityCreateOrConnectWithoutUpdatedByInput[]
    createMany?: OpportunityCreateManyUpdatedByInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<QuotationCreateWithoutCreatedByInput, QuotationUncheckedCreateWithoutCreatedByInput> | QuotationCreateWithoutCreatedByInput[] | QuotationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutCreatedByInput | QuotationCreateOrConnectWithoutCreatedByInput[]
    createMany?: QuotationCreateManyCreatedByInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<QuotationCreateWithoutUpdatedByInput, QuotationUncheckedCreateWithoutUpdatedByInput> | QuotationCreateWithoutUpdatedByInput[] | QuotationUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutUpdatedByInput | QuotationCreateOrConnectWithoutUpdatedByInput[]
    createMany?: QuotationCreateManyUpdatedByInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<OrderCreateWithoutUpdatedByInput, OrderUncheckedCreateWithoutUpdatedByInput> | OrderCreateWithoutUpdatedByInput[] | OrderUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUpdatedByInput | OrderCreateOrConnectWithoutUpdatedByInput[]
    createMany?: OrderCreateManyUpdatedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ShipmentCreateWithoutCreatedByInput, ShipmentUncheckedCreateWithoutCreatedByInput> | ShipmentCreateWithoutCreatedByInput[] | ShipmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutCreatedByInput | ShipmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: ShipmentCreateManyCreatedByInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<ShipmentCreateWithoutUpdatedByInput, ShipmentUncheckedCreateWithoutUpdatedByInput> | ShipmentCreateWithoutUpdatedByInput[] | ShipmentUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUpdatedByInput | ShipmentCreateOrConnectWithoutUpdatedByInput[]
    createMany?: ShipmentCreateManyUpdatedByInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PaymentCreateWithoutUpdatedByInput, PaymentUncheckedCreateWithoutUpdatedByInput> | PaymentCreateWithoutUpdatedByInput[] | PaymentUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUpdatedByInput | PaymentCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PaymentCreateManyUpdatedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput> | QuotationCreateWithoutApprovedByInput[] | QuotationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutApprovedByInput | QuotationCreateOrConnectWithoutApprovedByInput[]
    createMany?: QuotationCreateManyApprovedByInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<TaskCreateWithoutAssignedUserInput, TaskUncheckedCreateWithoutAssignedUserInput> | TaskCreateWithoutAssignedUserInput[] | TaskUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedUserInput | TaskCreateOrConnectWithoutAssignedUserInput[]
    createMany?: TaskCreateManyAssignedUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutLoggedByInput = {
    create?: XOR<CommunicationCreateWithoutLoggedByInput, CommunicationUncheckedCreateWithoutLoggedByInput> | CommunicationCreateWithoutLoggedByInput[] | CommunicationUncheckedCreateWithoutLoggedByInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutLoggedByInput | CommunicationCreateOrConnectWithoutLoggedByInput[]
    createMany?: CommunicationCreateManyLoggedByInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProjectManagerInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutTeamMembersInput = {
    create?: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput> | ProjectCreateWithoutTeamMembersInput[] | ProjectUncheckedCreateWithoutTeamMembersInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput | ProjectCreateOrConnectWithoutTeamMembersInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OpportunityUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OpportunityCreateWithoutCreatedByInput, OpportunityUncheckedCreateWithoutCreatedByInput> | OpportunityCreateWithoutCreatedByInput[] | OpportunityUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCreatedByInput | OpportunityCreateOrConnectWithoutCreatedByInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutCreatedByInput | OpportunityUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OpportunityCreateManyCreatedByInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutCreatedByInput | OpportunityUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutCreatedByInput | OpportunityUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<OpportunityCreateWithoutUpdatedByInput, OpportunityUncheckedCreateWithoutUpdatedByInput> | OpportunityCreateWithoutUpdatedByInput[] | OpportunityUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutUpdatedByInput | OpportunityCreateOrConnectWithoutUpdatedByInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutUpdatedByInput | OpportunityUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: OpportunityCreateManyUpdatedByInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutUpdatedByInput | OpportunityUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutUpdatedByInput | OpportunityUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<QuotationCreateWithoutCreatedByInput, QuotationUncheckedCreateWithoutCreatedByInput> | QuotationCreateWithoutCreatedByInput[] | QuotationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutCreatedByInput | QuotationCreateOrConnectWithoutCreatedByInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutCreatedByInput | QuotationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: QuotationCreateManyCreatedByInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutCreatedByInput | QuotationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutCreatedByInput | QuotationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<QuotationCreateWithoutUpdatedByInput, QuotationUncheckedCreateWithoutUpdatedByInput> | QuotationCreateWithoutUpdatedByInput[] | QuotationUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutUpdatedByInput | QuotationCreateOrConnectWithoutUpdatedByInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutUpdatedByInput | QuotationUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: QuotationCreateManyUpdatedByInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutUpdatedByInput | QuotationUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutUpdatedByInput | QuotationUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCreatedByInput | OrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCreatedByInput | OrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCreatedByInput | OrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<OrderCreateWithoutUpdatedByInput, OrderUncheckedCreateWithoutUpdatedByInput> | OrderCreateWithoutUpdatedByInput[] | OrderUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUpdatedByInput | OrderCreateOrConnectWithoutUpdatedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUpdatedByInput | OrderUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: OrderCreateManyUpdatedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUpdatedByInput | OrderUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUpdatedByInput | OrderUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ShipmentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ShipmentCreateWithoutCreatedByInput, ShipmentUncheckedCreateWithoutCreatedByInput> | ShipmentCreateWithoutCreatedByInput[] | ShipmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutCreatedByInput | ShipmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutCreatedByInput | ShipmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ShipmentCreateManyCreatedByInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutCreatedByInput | ShipmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutCreatedByInput | ShipmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type ShipmentUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ShipmentCreateWithoutUpdatedByInput, ShipmentUncheckedCreateWithoutUpdatedByInput> | ShipmentCreateWithoutUpdatedByInput[] | ShipmentUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUpdatedByInput | ShipmentCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutUpdatedByInput | ShipmentUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ShipmentCreateManyUpdatedByInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutUpdatedByInput | ShipmentUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutUpdatedByInput | ShipmentUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCreatedByInput | PaymentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCreatedByInput | PaymentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCreatedByInput | PaymentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PaymentCreateWithoutUpdatedByInput, PaymentUncheckedCreateWithoutUpdatedByInput> | PaymentCreateWithoutUpdatedByInput[] | PaymentUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUpdatedByInput | PaymentCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUpdatedByInput | PaymentUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PaymentCreateManyUpdatedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUpdatedByInput | PaymentUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUpdatedByInput | PaymentUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type QuotationUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput> | QuotationCreateWithoutApprovedByInput[] | QuotationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutApprovedByInput | QuotationCreateOrConnectWithoutApprovedByInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutApprovedByInput | QuotationUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: QuotationCreateManyApprovedByInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutApprovedByInput | QuotationUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutApprovedByInput | QuotationUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<TaskCreateWithoutAssignedUserInput, TaskUncheckedCreateWithoutAssignedUserInput> | TaskCreateWithoutAssignedUserInput[] | TaskUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedUserInput | TaskCreateOrConnectWithoutAssignedUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssignedUserInput | TaskUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: TaskCreateManyAssignedUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssignedUserInput | TaskUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssignedUserInput | TaskUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutLoggedByNestedInput = {
    create?: XOR<CommunicationCreateWithoutLoggedByInput, CommunicationUncheckedCreateWithoutLoggedByInput> | CommunicationCreateWithoutLoggedByInput[] | CommunicationUncheckedCreateWithoutLoggedByInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutLoggedByInput | CommunicationCreateOrConnectWithoutLoggedByInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutLoggedByInput | CommunicationUpsertWithWhereUniqueWithoutLoggedByInput[]
    createMany?: CommunicationCreateManyLoggedByInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutLoggedByInput | CommunicationUpdateWithWhereUniqueWithoutLoggedByInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutLoggedByInput | CommunicationUpdateManyWithWhereWithoutLoggedByInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutProjectManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectManagerInput | ProjectUpsertWithWhereUniqueWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectManagerInput | ProjectUpdateWithWhereUniqueWithoutProjectManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectManagerInput | ProjectUpdateManyWithWhereWithoutProjectManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutTeamMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput> | ProjectCreateWithoutTeamMembersInput[] | ProjectUncheckedCreateWithoutTeamMembersInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput | ProjectCreateOrConnectWithoutTeamMembersInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutTeamMembersInput | ProjectUpsertWithWhereUniqueWithoutTeamMembersInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutTeamMembersInput | ProjectUpdateWithWhereUniqueWithoutTeamMembersInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutTeamMembersInput | ProjectUpdateManyWithWhereWithoutTeamMembersInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OpportunityCreateWithoutCreatedByInput, OpportunityUncheckedCreateWithoutCreatedByInput> | OpportunityCreateWithoutCreatedByInput[] | OpportunityUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCreatedByInput | OpportunityCreateOrConnectWithoutCreatedByInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutCreatedByInput | OpportunityUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OpportunityCreateManyCreatedByInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutCreatedByInput | OpportunityUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutCreatedByInput | OpportunityUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<OpportunityCreateWithoutUpdatedByInput, OpportunityUncheckedCreateWithoutUpdatedByInput> | OpportunityCreateWithoutUpdatedByInput[] | OpportunityUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutUpdatedByInput | OpportunityCreateOrConnectWithoutUpdatedByInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutUpdatedByInput | OpportunityUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: OpportunityCreateManyUpdatedByInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutUpdatedByInput | OpportunityUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutUpdatedByInput | OpportunityUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<QuotationCreateWithoutCreatedByInput, QuotationUncheckedCreateWithoutCreatedByInput> | QuotationCreateWithoutCreatedByInput[] | QuotationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutCreatedByInput | QuotationCreateOrConnectWithoutCreatedByInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutCreatedByInput | QuotationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: QuotationCreateManyCreatedByInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutCreatedByInput | QuotationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutCreatedByInput | QuotationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<QuotationCreateWithoutUpdatedByInput, QuotationUncheckedCreateWithoutUpdatedByInput> | QuotationCreateWithoutUpdatedByInput[] | QuotationUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutUpdatedByInput | QuotationCreateOrConnectWithoutUpdatedByInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutUpdatedByInput | QuotationUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: QuotationCreateManyUpdatedByInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutUpdatedByInput | QuotationUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutUpdatedByInput | QuotationUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCreatedByInput | OrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCreatedByInput | OrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCreatedByInput | OrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<OrderCreateWithoutUpdatedByInput, OrderUncheckedCreateWithoutUpdatedByInput> | OrderCreateWithoutUpdatedByInput[] | OrderUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUpdatedByInput | OrderCreateOrConnectWithoutUpdatedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUpdatedByInput | OrderUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: OrderCreateManyUpdatedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUpdatedByInput | OrderUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUpdatedByInput | OrderUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ShipmentCreateWithoutCreatedByInput, ShipmentUncheckedCreateWithoutCreatedByInput> | ShipmentCreateWithoutCreatedByInput[] | ShipmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutCreatedByInput | ShipmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutCreatedByInput | ShipmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ShipmentCreateManyCreatedByInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutCreatedByInput | ShipmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutCreatedByInput | ShipmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<ShipmentCreateWithoutUpdatedByInput, ShipmentUncheckedCreateWithoutUpdatedByInput> | ShipmentCreateWithoutUpdatedByInput[] | ShipmentUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutUpdatedByInput | ShipmentCreateOrConnectWithoutUpdatedByInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutUpdatedByInput | ShipmentUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: ShipmentCreateManyUpdatedByInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutUpdatedByInput | ShipmentUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutUpdatedByInput | ShipmentUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput> | PaymentCreateWithoutCreatedByInput[] | PaymentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCreatedByInput | PaymentCreateOrConnectWithoutCreatedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCreatedByInput | PaymentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PaymentCreateManyCreatedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCreatedByInput | PaymentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCreatedByInput | PaymentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PaymentCreateWithoutUpdatedByInput, PaymentUncheckedCreateWithoutUpdatedByInput> | PaymentCreateWithoutUpdatedByInput[] | PaymentUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUpdatedByInput | PaymentCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUpdatedByInput | PaymentUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PaymentCreateManyUpdatedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUpdatedByInput | PaymentUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUpdatedByInput | PaymentUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput> | QuotationCreateWithoutApprovedByInput[] | QuotationUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutApprovedByInput | QuotationCreateOrConnectWithoutApprovedByInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutApprovedByInput | QuotationUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: QuotationCreateManyApprovedByInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutApprovedByInput | QuotationUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutApprovedByInput | QuotationUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<TaskCreateWithoutAssignedUserInput, TaskUncheckedCreateWithoutAssignedUserInput> | TaskCreateWithoutAssignedUserInput[] | TaskUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssignedUserInput | TaskCreateOrConnectWithoutAssignedUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssignedUserInput | TaskUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: TaskCreateManyAssignedUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssignedUserInput | TaskUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssignedUserInput | TaskUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput = {
    create?: XOR<CommunicationCreateWithoutLoggedByInput, CommunicationUncheckedCreateWithoutLoggedByInput> | CommunicationCreateWithoutLoggedByInput[] | CommunicationUncheckedCreateWithoutLoggedByInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutLoggedByInput | CommunicationCreateOrConnectWithoutLoggedByInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutLoggedByInput | CommunicationUpsertWithWhereUniqueWithoutLoggedByInput[]
    createMany?: CommunicationCreateManyLoggedByInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutLoggedByInput | CommunicationUpdateWithWhereUniqueWithoutLoggedByInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutLoggedByInput | CommunicationUpdateManyWithWhereWithoutLoggedByInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectManagerInput | ProjectUpsertWithWhereUniqueWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectManagerInput | ProjectUpdateWithWhereUniqueWithoutProjectManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectManagerInput | ProjectUpdateManyWithWhereWithoutProjectManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput> | ProjectCreateWithoutTeamMembersInput[] | ProjectUncheckedCreateWithoutTeamMembersInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamMembersInput | ProjectCreateOrConnectWithoutTeamMembersInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutTeamMembersInput | ProjectUpsertWithWhereUniqueWithoutTeamMembersInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutTeamMembersInput | ProjectUpdateWithWhereUniqueWithoutTeamMembersInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutTeamMembersInput | ProjectUpdateManyWithWhereWithoutTeamMembersInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type StaffUserCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<StaffUserCreateWithoutAssignedTasksInput, StaffUserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutAssignedTasksInput
    connect?: StaffUserWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StaffUserUpdateOneWithoutAssignedTasksNestedInput = {
    create?: XOR<StaffUserCreateWithoutAssignedTasksInput, StaffUserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutAssignedTasksInput
    upsert?: StaffUserUpsertWithoutAssignedTasksInput
    disconnect?: StaffUserWhereInput | boolean
    delete?: StaffUserWhereInput | boolean
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutAssignedTasksInput, StaffUserUpdateWithoutAssignedTasksInput>, StaffUserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type OpportunityCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput> | OpportunityCreateWithoutCustomerInput[] | OpportunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCustomerInput | OpportunityCreateOrConnectWithoutCustomerInput[]
    createMany?: OpportunityCreateManyCustomerInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CommunicationCreateWithoutCustomerInput, CommunicationUncheckedCreateWithoutCustomerInput> | CommunicationCreateWithoutCustomerInput[] | CommunicationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutCustomerInput | CommunicationCreateOrConnectWithoutCustomerInput[]
    createMany?: CommunicationCreateManyCustomerInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput> | OpportunityCreateWithoutCustomerInput[] | OpportunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCustomerInput | OpportunityCreateOrConnectWithoutCustomerInput[]
    createMany?: OpportunityCreateManyCustomerInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CommunicationCreateWithoutCustomerInput, CommunicationUncheckedCreateWithoutCustomerInput> | CommunicationCreateWithoutCustomerInput[] | CommunicationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutCustomerInput | CommunicationCreateOrConnectWithoutCustomerInput[]
    createMany?: CommunicationCreateManyCustomerInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type EnumCurrencyFieldUpdateOperationsInput = {
    set?: $Enums.Currency
  }

  export type OpportunityUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput> | OpportunityCreateWithoutCustomerInput[] | OpportunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCustomerInput | OpportunityCreateOrConnectWithoutCustomerInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutCustomerInput | OpportunityUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OpportunityCreateManyCustomerInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutCustomerInput | OpportunityUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutCustomerInput | OpportunityUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCustomerInput | ProjectUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCustomerInput | ProjectUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCustomerInput | ProjectUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CommunicationCreateWithoutCustomerInput, CommunicationUncheckedCreateWithoutCustomerInput> | CommunicationCreateWithoutCustomerInput[] | CommunicationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutCustomerInput | CommunicationCreateOrConnectWithoutCustomerInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutCustomerInput | CommunicationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CommunicationCreateManyCustomerInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutCustomerInput | CommunicationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutCustomerInput | CommunicationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput> | OpportunityCreateWithoutCustomerInput[] | OpportunityUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutCustomerInput | OpportunityCreateOrConnectWithoutCustomerInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutCustomerInput | OpportunityUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OpportunityCreateManyCustomerInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutCustomerInput | OpportunityUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutCustomerInput | OpportunityUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput> | ProjectCreateWithoutCustomerInput[] | ProjectUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCustomerInput | ProjectCreateOrConnectWithoutCustomerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCustomerInput | ProjectUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ProjectCreateManyCustomerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCustomerInput | ProjectUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCustomerInput | ProjectUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CommunicationCreateWithoutCustomerInput, CommunicationUncheckedCreateWithoutCustomerInput> | CommunicationCreateWithoutCustomerInput[] | CommunicationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutCustomerInput | CommunicationCreateOrConnectWithoutCustomerInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutCustomerInput | CommunicationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CommunicationCreateManyCustomerInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutCustomerInput | CommunicationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutCustomerInput | CommunicationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<CustomerCreateWithoutOpportunitiesInput, CustomerUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOpportunitiesInput
    connect?: CustomerWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutCreatedOpportunitiesInput = {
    create?: XOR<StaffUserCreateWithoutCreatedOpportunitiesInput, StaffUserUncheckedCreateWithoutCreatedOpportunitiesInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedOpportunitiesInput
    connect?: StaffUserWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutUpdatedOpportunitiesInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedOpportunitiesInput, StaffUserUncheckedCreateWithoutUpdatedOpportunitiesInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedOpportunitiesInput
    connect?: StaffUserWhereUniqueInput
  }

  export type QuotationCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<QuotationCreateWithoutOpportunityInput, QuotationUncheckedCreateWithoutOpportunityInput> | QuotationCreateWithoutOpportunityInput[] | QuotationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutOpportunityInput | QuotationCreateOrConnectWithoutOpportunityInput[]
    createMany?: QuotationCreateManyOpportunityInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OrderCreateWithoutOpportunityInput, OrderUncheckedCreateWithoutOpportunityInput> | OrderCreateWithoutOpportunityInput[] | OrderUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOpportunityInput | OrderCreateOrConnectWithoutOpportunityInput[]
    createMany?: OrderCreateManyOpportunityInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<DocumentCreateWithoutOpportunityInput, DocumentUncheckedCreateWithoutOpportunityInput> | DocumentCreateWithoutOpportunityInput[] | DocumentUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOpportunityInput | DocumentCreateOrConnectWithoutOpportunityInput[]
    createMany?: DocumentCreateManyOpportunityInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<CommunicationCreateWithoutOpportunityInput, CommunicationUncheckedCreateWithoutOpportunityInput> | CommunicationCreateWithoutOpportunityInput[] | CommunicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutOpportunityInput | CommunicationCreateOrConnectWithoutOpportunityInput[]
    createMany?: CommunicationCreateManyOpportunityInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<QuotationCreateWithoutOpportunityInput, QuotationUncheckedCreateWithoutOpportunityInput> | QuotationCreateWithoutOpportunityInput[] | QuotationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutOpportunityInput | QuotationCreateOrConnectWithoutOpportunityInput[]
    createMany?: QuotationCreateManyOpportunityInputEnvelope
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OrderCreateWithoutOpportunityInput, OrderUncheckedCreateWithoutOpportunityInput> | OrderCreateWithoutOpportunityInput[] | OrderUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOpportunityInput | OrderCreateOrConnectWithoutOpportunityInput[]
    createMany?: OrderCreateManyOpportunityInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<DocumentCreateWithoutOpportunityInput, DocumentUncheckedCreateWithoutOpportunityInput> | DocumentCreateWithoutOpportunityInput[] | DocumentUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOpportunityInput | DocumentCreateOrConnectWithoutOpportunityInput[]
    createMany?: DocumentCreateManyOpportunityInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<CommunicationCreateWithoutOpportunityInput, CommunicationUncheckedCreateWithoutOpportunityInput> | CommunicationCreateWithoutOpportunityInput[] | CommunicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutOpportunityInput | CommunicationCreateOrConnectWithoutOpportunityInput[]
    createMany?: CommunicationCreateManyOpportunityInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type EnumOpportunityStatusFieldUpdateOperationsInput = {
    set?: $Enums.OpportunityStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<CustomerCreateWithoutOpportunitiesInput, CustomerUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOpportunitiesInput
    upsert?: CustomerUpsertWithoutOpportunitiesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOpportunitiesInput, CustomerUpdateWithoutOpportunitiesInput>, CustomerUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type StaffUserUpdateOneRequiredWithoutCreatedOpportunitiesNestedInput = {
    create?: XOR<StaffUserCreateWithoutCreatedOpportunitiesInput, StaffUserUncheckedCreateWithoutCreatedOpportunitiesInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedOpportunitiesInput
    upsert?: StaffUserUpsertWithoutCreatedOpportunitiesInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutCreatedOpportunitiesInput, StaffUserUpdateWithoutCreatedOpportunitiesInput>, StaffUserUncheckedUpdateWithoutCreatedOpportunitiesInput>
  }

  export type StaffUserUpdateOneRequiredWithoutUpdatedOpportunitiesNestedInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedOpportunitiesInput, StaffUserUncheckedCreateWithoutUpdatedOpportunitiesInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedOpportunitiesInput
    upsert?: StaffUserUpsertWithoutUpdatedOpportunitiesInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutUpdatedOpportunitiesInput, StaffUserUpdateWithoutUpdatedOpportunitiesInput>, StaffUserUncheckedUpdateWithoutUpdatedOpportunitiesInput>
  }

  export type QuotationUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<QuotationCreateWithoutOpportunityInput, QuotationUncheckedCreateWithoutOpportunityInput> | QuotationCreateWithoutOpportunityInput[] | QuotationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutOpportunityInput | QuotationCreateOrConnectWithoutOpportunityInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutOpportunityInput | QuotationUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: QuotationCreateManyOpportunityInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutOpportunityInput | QuotationUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutOpportunityInput | QuotationUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OrderCreateWithoutOpportunityInput, OrderUncheckedCreateWithoutOpportunityInput> | OrderCreateWithoutOpportunityInput[] | OrderUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOpportunityInput | OrderCreateOrConnectWithoutOpportunityInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOpportunityInput | OrderUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OrderCreateManyOpportunityInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOpportunityInput | OrderUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOpportunityInput | OrderUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<DocumentCreateWithoutOpportunityInput, DocumentUncheckedCreateWithoutOpportunityInput> | DocumentCreateWithoutOpportunityInput[] | DocumentUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOpportunityInput | DocumentCreateOrConnectWithoutOpportunityInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOpportunityInput | DocumentUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: DocumentCreateManyOpportunityInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOpportunityInput | DocumentUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOpportunityInput | DocumentUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<CommunicationCreateWithoutOpportunityInput, CommunicationUncheckedCreateWithoutOpportunityInput> | CommunicationCreateWithoutOpportunityInput[] | CommunicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutOpportunityInput | CommunicationCreateOrConnectWithoutOpportunityInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutOpportunityInput | CommunicationUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: CommunicationCreateManyOpportunityInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutOpportunityInput | CommunicationUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutOpportunityInput | CommunicationUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<QuotationCreateWithoutOpportunityInput, QuotationUncheckedCreateWithoutOpportunityInput> | QuotationCreateWithoutOpportunityInput[] | QuotationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: QuotationCreateOrConnectWithoutOpportunityInput | QuotationCreateOrConnectWithoutOpportunityInput[]
    upsert?: QuotationUpsertWithWhereUniqueWithoutOpportunityInput | QuotationUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: QuotationCreateManyOpportunityInputEnvelope
    set?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    disconnect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    delete?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    connect?: QuotationWhereUniqueInput | QuotationWhereUniqueInput[]
    update?: QuotationUpdateWithWhereUniqueWithoutOpportunityInput | QuotationUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: QuotationUpdateManyWithWhereWithoutOpportunityInput | QuotationUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OrderCreateWithoutOpportunityInput, OrderUncheckedCreateWithoutOpportunityInput> | OrderCreateWithoutOpportunityInput[] | OrderUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOpportunityInput | OrderCreateOrConnectWithoutOpportunityInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOpportunityInput | OrderUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OrderCreateManyOpportunityInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOpportunityInput | OrderUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOpportunityInput | OrderUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<DocumentCreateWithoutOpportunityInput, DocumentUncheckedCreateWithoutOpportunityInput> | DocumentCreateWithoutOpportunityInput[] | DocumentUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOpportunityInput | DocumentCreateOrConnectWithoutOpportunityInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOpportunityInput | DocumentUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: DocumentCreateManyOpportunityInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOpportunityInput | DocumentUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOpportunityInput | DocumentUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<CommunicationCreateWithoutOpportunityInput, CommunicationUncheckedCreateWithoutOpportunityInput> | CommunicationCreateWithoutOpportunityInput[] | CommunicationUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutOpportunityInput | CommunicationCreateOrConnectWithoutOpportunityInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutOpportunityInput | CommunicationUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: CommunicationCreateManyOpportunityInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutOpportunityInput | CommunicationUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutOpportunityInput | CommunicationUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutProjectsInput = {
    create?: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProjectsInput
    connect?: CustomerWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutManagedProjectsInput = {
    create?: XOR<StaffUserCreateWithoutManagedProjectsInput, StaffUserUncheckedCreateWithoutManagedProjectsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutManagedProjectsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type StaffUserCreateNestedManyWithoutMemberOfProjectsInput = {
    create?: XOR<StaffUserCreateWithoutMemberOfProjectsInput, StaffUserUncheckedCreateWithoutMemberOfProjectsInput> | StaffUserCreateWithoutMemberOfProjectsInput[] | StaffUserUncheckedCreateWithoutMemberOfProjectsInput[]
    connectOrCreate?: StaffUserCreateOrConnectWithoutMemberOfProjectsInput | StaffUserCreateOrConnectWithoutMemberOfProjectsInput[]
    connect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
  }

  export type StaffUserUncheckedCreateNestedManyWithoutMemberOfProjectsInput = {
    create?: XOR<StaffUserCreateWithoutMemberOfProjectsInput, StaffUserUncheckedCreateWithoutMemberOfProjectsInput> | StaffUserCreateWithoutMemberOfProjectsInput[] | StaffUserUncheckedCreateWithoutMemberOfProjectsInput[]
    connectOrCreate?: StaffUserCreateOrConnectWithoutMemberOfProjectsInput | StaffUserCreateOrConnectWithoutMemberOfProjectsInput[]
    connect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type CustomerUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProjectsInput
    upsert?: CustomerUpsertWithoutProjectsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutProjectsInput, CustomerUpdateWithoutProjectsInput>, CustomerUncheckedUpdateWithoutProjectsInput>
  }

  export type StaffUserUpdateOneWithoutManagedProjectsNestedInput = {
    create?: XOR<StaffUserCreateWithoutManagedProjectsInput, StaffUserUncheckedCreateWithoutManagedProjectsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutManagedProjectsInput
    upsert?: StaffUserUpsertWithoutManagedProjectsInput
    disconnect?: StaffUserWhereInput | boolean
    delete?: StaffUserWhereInput | boolean
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutManagedProjectsInput, StaffUserUpdateWithoutManagedProjectsInput>, StaffUserUncheckedUpdateWithoutManagedProjectsInput>
  }

  export type StaffUserUpdateManyWithoutMemberOfProjectsNestedInput = {
    create?: XOR<StaffUserCreateWithoutMemberOfProjectsInput, StaffUserUncheckedCreateWithoutMemberOfProjectsInput> | StaffUserCreateWithoutMemberOfProjectsInput[] | StaffUserUncheckedCreateWithoutMemberOfProjectsInput[]
    connectOrCreate?: StaffUserCreateOrConnectWithoutMemberOfProjectsInput | StaffUserCreateOrConnectWithoutMemberOfProjectsInput[]
    upsert?: StaffUserUpsertWithWhereUniqueWithoutMemberOfProjectsInput | StaffUserUpsertWithWhereUniqueWithoutMemberOfProjectsInput[]
    set?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
    disconnect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
    delete?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
    connect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
    update?: StaffUserUpdateWithWhereUniqueWithoutMemberOfProjectsInput | StaffUserUpdateWithWhereUniqueWithoutMemberOfProjectsInput[]
    updateMany?: StaffUserUpdateManyWithWhereWithoutMemberOfProjectsInput | StaffUserUpdateManyWithWhereWithoutMemberOfProjectsInput[]
    deleteMany?: StaffUserScalarWhereInput | StaffUserScalarWhereInput[]
  }

  export type StaffUserUncheckedUpdateManyWithoutMemberOfProjectsNestedInput = {
    create?: XOR<StaffUserCreateWithoutMemberOfProjectsInput, StaffUserUncheckedCreateWithoutMemberOfProjectsInput> | StaffUserCreateWithoutMemberOfProjectsInput[] | StaffUserUncheckedCreateWithoutMemberOfProjectsInput[]
    connectOrCreate?: StaffUserCreateOrConnectWithoutMemberOfProjectsInput | StaffUserCreateOrConnectWithoutMemberOfProjectsInput[]
    upsert?: StaffUserUpsertWithWhereUniqueWithoutMemberOfProjectsInput | StaffUserUpsertWithWhereUniqueWithoutMemberOfProjectsInput[]
    set?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
    disconnect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
    delete?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
    connect?: StaffUserWhereUniqueInput | StaffUserWhereUniqueInput[]
    update?: StaffUserUpdateWithWhereUniqueWithoutMemberOfProjectsInput | StaffUserUpdateWithWhereUniqueWithoutMemberOfProjectsInput[]
    updateMany?: StaffUserUpdateManyWithWhereWithoutMemberOfProjectsInput | StaffUserUpdateManyWithWhereWithoutMemberOfProjectsInput[]
    deleteMany?: StaffUserScalarWhereInput | StaffUserScalarWhereInput[]
  }

  export type StaffUserCreateNestedOneWithoutApprovedQuotationsInput = {
    create?: XOR<StaffUserCreateWithoutApprovedQuotationsInput, StaffUserUncheckedCreateWithoutApprovedQuotationsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutApprovedQuotationsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutCreatedQuotationsInput = {
    create?: XOR<StaffUserCreateWithoutCreatedQuotationsInput, StaffUserUncheckedCreateWithoutCreatedQuotationsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedQuotationsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutUpdatedQuotationsInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedQuotationsInput, StaffUserUncheckedCreateWithoutUpdatedQuotationsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedQuotationsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutQuotationsInput = {
    create?: XOR<OpportunityCreateWithoutQuotationsInput, OpportunityUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutQuotationsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type QuoteItemCreateNestedManyWithoutQuotationInput = {
    create?: XOR<QuoteItemCreateWithoutQuotationInput, QuoteItemUncheckedCreateWithoutQuotationInput> | QuoteItemCreateWithoutQuotationInput[] | QuoteItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuotationInput | QuoteItemCreateOrConnectWithoutQuotationInput[]
    createMany?: QuoteItemCreateManyQuotationInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type OrderCreateNestedOneWithoutQuotationInput = {
    create?: XOR<OrderCreateWithoutQuotationInput, OrderUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: OrderCreateOrConnectWithoutQuotationInput
    connect?: OrderWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutQuotationInput = {
    create?: XOR<DocumentCreateWithoutQuotationInput, DocumentUncheckedCreateWithoutQuotationInput> | DocumentCreateWithoutQuotationInput[] | DocumentUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutQuotationInput | DocumentCreateOrConnectWithoutQuotationInput[]
    createMany?: DocumentCreateManyQuotationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutQuotationInput = {
    create?: XOR<CommunicationCreateWithoutQuotationInput, CommunicationUncheckedCreateWithoutQuotationInput> | CommunicationCreateWithoutQuotationInput[] | CommunicationUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutQuotationInput | CommunicationCreateOrConnectWithoutQuotationInput[]
    createMany?: CommunicationCreateManyQuotationInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type QuoteItemUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<QuoteItemCreateWithoutQuotationInput, QuoteItemUncheckedCreateWithoutQuotationInput> | QuoteItemCreateWithoutQuotationInput[] | QuoteItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuotationInput | QuoteItemCreateOrConnectWithoutQuotationInput[]
    createMany?: QuoteItemCreateManyQuotationInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedOneWithoutQuotationInput = {
    create?: XOR<OrderCreateWithoutQuotationInput, OrderUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: OrderCreateOrConnectWithoutQuotationInput
    connect?: OrderWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<DocumentCreateWithoutQuotationInput, DocumentUncheckedCreateWithoutQuotationInput> | DocumentCreateWithoutQuotationInput[] | DocumentUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutQuotationInput | DocumentCreateOrConnectWithoutQuotationInput[]
    createMany?: DocumentCreateManyQuotationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutQuotationInput = {
    create?: XOR<CommunicationCreateWithoutQuotationInput, CommunicationUncheckedCreateWithoutQuotationInput> | CommunicationCreateWithoutQuotationInput[] | CommunicationUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutQuotationInput | CommunicationCreateOrConnectWithoutQuotationInput[]
    createMany?: CommunicationCreateManyQuotationInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumQuotationStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuotationStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StaffUserUpdateOneWithoutApprovedQuotationsNestedInput = {
    create?: XOR<StaffUserCreateWithoutApprovedQuotationsInput, StaffUserUncheckedCreateWithoutApprovedQuotationsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutApprovedQuotationsInput
    upsert?: StaffUserUpsertWithoutApprovedQuotationsInput
    disconnect?: StaffUserWhereInput | boolean
    delete?: StaffUserWhereInput | boolean
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutApprovedQuotationsInput, StaffUserUpdateWithoutApprovedQuotationsInput>, StaffUserUncheckedUpdateWithoutApprovedQuotationsInput>
  }

  export type StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput = {
    create?: XOR<StaffUserCreateWithoutCreatedQuotationsInput, StaffUserUncheckedCreateWithoutCreatedQuotationsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedQuotationsInput
    upsert?: StaffUserUpsertWithoutCreatedQuotationsInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutCreatedQuotationsInput, StaffUserUpdateWithoutCreatedQuotationsInput>, StaffUserUncheckedUpdateWithoutCreatedQuotationsInput>
  }

  export type StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedQuotationsInput, StaffUserUncheckedCreateWithoutUpdatedQuotationsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedQuotationsInput
    upsert?: StaffUserUpsertWithoutUpdatedQuotationsInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutUpdatedQuotationsInput, StaffUserUpdateWithoutUpdatedQuotationsInput>, StaffUserUncheckedUpdateWithoutUpdatedQuotationsInput>
  }

  export type OpportunityUpdateOneRequiredWithoutQuotationsNestedInput = {
    create?: XOR<OpportunityCreateWithoutQuotationsInput, OpportunityUncheckedCreateWithoutQuotationsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutQuotationsInput
    upsert?: OpportunityUpsertWithoutQuotationsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutQuotationsInput, OpportunityUpdateWithoutQuotationsInput>, OpportunityUncheckedUpdateWithoutQuotationsInput>
  }

  export type QuoteItemUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<QuoteItemCreateWithoutQuotationInput, QuoteItemUncheckedCreateWithoutQuotationInput> | QuoteItemCreateWithoutQuotationInput[] | QuoteItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuotationInput | QuoteItemCreateOrConnectWithoutQuotationInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutQuotationInput | QuoteItemUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: QuoteItemCreateManyQuotationInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutQuotationInput | QuoteItemUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutQuotationInput | QuoteItemUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type OrderUpdateOneWithoutQuotationNestedInput = {
    create?: XOR<OrderCreateWithoutQuotationInput, OrderUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: OrderCreateOrConnectWithoutQuotationInput
    upsert?: OrderUpsertWithoutQuotationInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutQuotationInput, OrderUpdateWithoutQuotationInput>, OrderUncheckedUpdateWithoutQuotationInput>
  }

  export type DocumentUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<DocumentCreateWithoutQuotationInput, DocumentUncheckedCreateWithoutQuotationInput> | DocumentCreateWithoutQuotationInput[] | DocumentUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutQuotationInput | DocumentCreateOrConnectWithoutQuotationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutQuotationInput | DocumentUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: DocumentCreateManyQuotationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutQuotationInput | DocumentUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutQuotationInput | DocumentUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<CommunicationCreateWithoutQuotationInput, CommunicationUncheckedCreateWithoutQuotationInput> | CommunicationCreateWithoutQuotationInput[] | CommunicationUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutQuotationInput | CommunicationCreateOrConnectWithoutQuotationInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutQuotationInput | CommunicationUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: CommunicationCreateManyQuotationInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutQuotationInput | CommunicationUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutQuotationInput | CommunicationUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<QuoteItemCreateWithoutQuotationInput, QuoteItemUncheckedCreateWithoutQuotationInput> | QuoteItemCreateWithoutQuotationInput[] | QuoteItemUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuotationInput | QuoteItemCreateOrConnectWithoutQuotationInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutQuotationInput | QuoteItemUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: QuoteItemCreateManyQuotationInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutQuotationInput | QuoteItemUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutQuotationInput | QuoteItemUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type OrderUncheckedUpdateOneWithoutQuotationNestedInput = {
    create?: XOR<OrderCreateWithoutQuotationInput, OrderUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: OrderCreateOrConnectWithoutQuotationInput
    upsert?: OrderUpsertWithoutQuotationInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutQuotationInput, OrderUpdateWithoutQuotationInput>, OrderUncheckedUpdateWithoutQuotationInput>
  }

  export type DocumentUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<DocumentCreateWithoutQuotationInput, DocumentUncheckedCreateWithoutQuotationInput> | DocumentCreateWithoutQuotationInput[] | DocumentUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutQuotationInput | DocumentCreateOrConnectWithoutQuotationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutQuotationInput | DocumentUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: DocumentCreateManyQuotationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutQuotationInput | DocumentUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutQuotationInput | DocumentUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutQuotationNestedInput = {
    create?: XOR<CommunicationCreateWithoutQuotationInput, CommunicationUncheckedCreateWithoutQuotationInput> | CommunicationCreateWithoutQuotationInput[] | CommunicationUncheckedCreateWithoutQuotationInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutQuotationInput | CommunicationCreateOrConnectWithoutQuotationInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutQuotationInput | CommunicationUpsertWithWhereUniqueWithoutQuotationInput[]
    createMany?: CommunicationCreateManyQuotationInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutQuotationInput | CommunicationUpdateWithWhereUniqueWithoutQuotationInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutQuotationInput | CommunicationUpdateManyWithWhereWithoutQuotationInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type QuotationCreateNestedOneWithoutItemsInput = {
    create?: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutItemsInput
    connect?: QuotationWhereUniqueInput
  }

  export type QuotationUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutItemsInput
    upsert?: QuotationUpsertWithoutItemsInput
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutItemsInput, QuotationUpdateWithoutItemsInput>, QuotationUncheckedUpdateWithoutItemsInput>
  }

  export type StaffUserCreateNestedOneWithoutCreatedOrdersInput = {
    create?: XOR<StaffUserCreateWithoutCreatedOrdersInput, StaffUserUncheckedCreateWithoutCreatedOrdersInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedOrdersInput
    connect?: StaffUserWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutUpdatedOrdersInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedOrdersInput, StaffUserUncheckedCreateWithoutUpdatedOrdersInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedOrdersInput
    connect?: StaffUserWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OpportunityCreateWithoutOrdersInput, OpportunityUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutOrdersInput
    connect?: OpportunityWhereUniqueInput
  }

  export type QuotationCreateNestedOneWithoutOrderInput = {
    create?: XOR<QuotationCreateWithoutOrderInput, QuotationUncheckedCreateWithoutOrderInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutOrderInput
    connect?: QuotationWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutOrderInput = {
    create?: XOR<PurchaseOrderCreateWithoutOrderInput, PurchaseOrderUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutOrderInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ShipmentCreateNestedManyWithoutOrderInput = {
    create?: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput> | ShipmentCreateWithoutOrderInput[] | ShipmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutOrderInput | ShipmentCreateOrConnectWithoutOrderInput[]
    createMany?: ShipmentCreateManyOrderInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutOrderInput = {
    create?: XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput> | DocumentCreateWithoutOrderInput[] | DocumentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrderInput | DocumentCreateOrConnectWithoutOrderInput[]
    createMany?: DocumentCreateManyOrderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutOrderInput = {
    create?: XOR<CommunicationCreateWithoutOrderInput, CommunicationUncheckedCreateWithoutOrderInput> | CommunicationCreateWithoutOrderInput[] | CommunicationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutOrderInput | CommunicationCreateOrConnectWithoutOrderInput[]
    createMany?: CommunicationCreateManyOrderInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PurchaseOrderCreateWithoutOrderInput, PurchaseOrderUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutOrderInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ShipmentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput> | ShipmentCreateWithoutOrderInput[] | ShipmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutOrderInput | ShipmentCreateOrConnectWithoutOrderInput[]
    createMany?: ShipmentCreateManyOrderInputEnvelope
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput> | DocumentCreateWithoutOrderInput[] | DocumentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrderInput | DocumentCreateOrConnectWithoutOrderInput[]
    createMany?: DocumentCreateManyOrderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<CommunicationCreateWithoutOrderInput, CommunicationUncheckedCreateWithoutOrderInput> | CommunicationCreateWithoutOrderInput[] | CommunicationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutOrderInput | CommunicationCreateOrConnectWithoutOrderInput[]
    createMany?: CommunicationCreateManyOrderInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput = {
    create?: XOR<StaffUserCreateWithoutCreatedOrdersInput, StaffUserUncheckedCreateWithoutCreatedOrdersInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedOrdersInput
    upsert?: StaffUserUpsertWithoutCreatedOrdersInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutCreatedOrdersInput, StaffUserUpdateWithoutCreatedOrdersInput>, StaffUserUncheckedUpdateWithoutCreatedOrdersInput>
  }

  export type StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedOrdersInput, StaffUserUncheckedCreateWithoutUpdatedOrdersInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedOrdersInput
    upsert?: StaffUserUpsertWithoutUpdatedOrdersInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutUpdatedOrdersInput, StaffUserUpdateWithoutUpdatedOrdersInput>, StaffUserUncheckedUpdateWithoutUpdatedOrdersInput>
  }

  export type OpportunityUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OpportunityCreateWithoutOrdersInput, OpportunityUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutOrdersInput
    upsert?: OpportunityUpsertWithoutOrdersInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutOrdersInput, OpportunityUpdateWithoutOrdersInput>, OpportunityUncheckedUpdateWithoutOrdersInput>
  }

  export type QuotationUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<QuotationCreateWithoutOrderInput, QuotationUncheckedCreateWithoutOrderInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutOrderInput
    upsert?: QuotationUpsertWithoutOrderInput
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutOrderInput, QuotationUpdateWithoutOrderInput>, QuotationUncheckedUpdateWithoutOrderInput>
  }

  export type PurchaseOrderUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutOrderInput, PurchaseOrderUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutOrderInput
    upsert?: PurchaseOrderUpsertWithoutOrderInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutOrderInput, PurchaseOrderUpdateWithoutOrderInput>, PurchaseOrderUncheckedUpdateWithoutOrderInput>
  }

  export type ShipmentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput> | ShipmentCreateWithoutOrderInput[] | ShipmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutOrderInput | ShipmentCreateOrConnectWithoutOrderInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutOrderInput | ShipmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ShipmentCreateManyOrderInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutOrderInput | ShipmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutOrderInput | ShipmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput> | DocumentCreateWithoutOrderInput[] | DocumentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrderInput | DocumentCreateOrConnectWithoutOrderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOrderInput | DocumentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DocumentCreateManyOrderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOrderInput | DocumentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOrderInput | DocumentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CommunicationCreateWithoutOrderInput, CommunicationUncheckedCreateWithoutOrderInput> | CommunicationCreateWithoutOrderInput[] | CommunicationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutOrderInput | CommunicationCreateOrConnectWithoutOrderInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutOrderInput | CommunicationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CommunicationCreateManyOrderInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutOrderInput | CommunicationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutOrderInput | CommunicationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutOrderInput, PurchaseOrderUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutOrderInput
    upsert?: PurchaseOrderUpsertWithoutOrderInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutOrderInput, PurchaseOrderUpdateWithoutOrderInput>, PurchaseOrderUncheckedUpdateWithoutOrderInput>
  }

  export type ShipmentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput> | ShipmentCreateWithoutOrderInput[] | ShipmentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ShipmentCreateOrConnectWithoutOrderInput | ShipmentCreateOrConnectWithoutOrderInput[]
    upsert?: ShipmentUpsertWithWhereUniqueWithoutOrderInput | ShipmentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ShipmentCreateManyOrderInputEnvelope
    set?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    disconnect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    delete?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    connect?: ShipmentWhereUniqueInput | ShipmentWhereUniqueInput[]
    update?: ShipmentUpdateWithWhereUniqueWithoutOrderInput | ShipmentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ShipmentUpdateManyWithWhereWithoutOrderInput | ShipmentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput> | DocumentCreateWithoutOrderInput[] | DocumentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrderInput | DocumentCreateOrConnectWithoutOrderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOrderInput | DocumentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DocumentCreateManyOrderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOrderInput | DocumentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOrderInput | DocumentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CommunicationCreateWithoutOrderInput, CommunicationUncheckedCreateWithoutOrderInput> | CommunicationCreateWithoutOrderInput[] | CommunicationUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutOrderInput | CommunicationCreateOrConnectWithoutOrderInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutOrderInput | CommunicationUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CommunicationCreateManyOrderInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutOrderInput | CommunicationUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutOrderInput | CommunicationUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutPurchaseOrderInput = {
    create?: XOR<OrderCreateWithoutPurchaseOrderInput, OrderUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPurchaseOrderInput
    connect?: OrderWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<DocumentCreateWithoutPurchaseOrderInput, DocumentUncheckedCreateWithoutPurchaseOrderInput> | DocumentCreateWithoutPurchaseOrderInput[] | DocumentUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPurchaseOrderInput | DocumentCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: DocumentCreateManyPurchaseOrderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<DocumentCreateWithoutPurchaseOrderInput, DocumentUncheckedCreateWithoutPurchaseOrderInput> | DocumentCreateWithoutPurchaseOrderInput[] | DocumentUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPurchaseOrderInput | DocumentCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: DocumentCreateManyPurchaseOrderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type OrderUpdateOneRequiredWithoutPurchaseOrderNestedInput = {
    create?: XOR<OrderCreateWithoutPurchaseOrderInput, OrderUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPurchaseOrderInput
    upsert?: OrderUpsertWithoutPurchaseOrderInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPurchaseOrderInput, OrderUpdateWithoutPurchaseOrderInput>, OrderUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type DocumentUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<DocumentCreateWithoutPurchaseOrderInput, DocumentUncheckedCreateWithoutPurchaseOrderInput> | DocumentCreateWithoutPurchaseOrderInput[] | DocumentUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPurchaseOrderInput | DocumentCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPurchaseOrderInput | DocumentUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: DocumentCreateManyPurchaseOrderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPurchaseOrderInput | DocumentUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPurchaseOrderInput | DocumentUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<DocumentCreateWithoutPurchaseOrderInput, DocumentUncheckedCreateWithoutPurchaseOrderInput> | DocumentCreateWithoutPurchaseOrderInput[] | DocumentUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPurchaseOrderInput | DocumentCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPurchaseOrderInput | DocumentUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: DocumentCreateManyPurchaseOrderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPurchaseOrderInput | DocumentUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPurchaseOrderInput | DocumentUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type StaffUserCreateNestedOneWithoutCreatedShipmentsInput = {
    create?: XOR<StaffUserCreateWithoutCreatedShipmentsInput, StaffUserUncheckedCreateWithoutCreatedShipmentsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedShipmentsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutUpdatedShipmentsInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedShipmentsInput, StaffUserUncheckedCreateWithoutUpdatedShipmentsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedShipmentsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutShipmentsInput = {
    create?: XOR<OrderCreateWithoutShipmentsInput, OrderUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutShipmentsInput
    connect?: OrderWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutShipmentInput = {
    create?: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput> | PaymentCreateWithoutShipmentInput[] | PaymentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShipmentInput | PaymentCreateOrConnectWithoutShipmentInput[]
    createMany?: PaymentCreateManyShipmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutShipmentInput = {
    create?: XOR<DocumentCreateWithoutShipmentInput, DocumentUncheckedCreateWithoutShipmentInput> | DocumentCreateWithoutShipmentInput[] | DocumentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutShipmentInput | DocumentCreateOrConnectWithoutShipmentInput[]
    createMany?: DocumentCreateManyShipmentInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput> | PaymentCreateWithoutShipmentInput[] | PaymentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShipmentInput | PaymentCreateOrConnectWithoutShipmentInput[]
    createMany?: PaymentCreateManyShipmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutShipmentInput = {
    create?: XOR<DocumentCreateWithoutShipmentInput, DocumentUncheckedCreateWithoutShipmentInput> | DocumentCreateWithoutShipmentInput[] | DocumentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutShipmentInput | DocumentCreateOrConnectWithoutShipmentInput[]
    createMany?: DocumentCreateManyShipmentInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EnumShipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShipmentStatus
  }

  export type StaffUserUpdateOneRequiredWithoutCreatedShipmentsNestedInput = {
    create?: XOR<StaffUserCreateWithoutCreatedShipmentsInput, StaffUserUncheckedCreateWithoutCreatedShipmentsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedShipmentsInput
    upsert?: StaffUserUpsertWithoutCreatedShipmentsInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutCreatedShipmentsInput, StaffUserUpdateWithoutCreatedShipmentsInput>, StaffUserUncheckedUpdateWithoutCreatedShipmentsInput>
  }

  export type StaffUserUpdateOneRequiredWithoutUpdatedShipmentsNestedInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedShipmentsInput, StaffUserUncheckedCreateWithoutUpdatedShipmentsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedShipmentsInput
    upsert?: StaffUserUpsertWithoutUpdatedShipmentsInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutUpdatedShipmentsInput, StaffUserUpdateWithoutUpdatedShipmentsInput>, StaffUserUncheckedUpdateWithoutUpdatedShipmentsInput>
  }

  export type OrderUpdateOneRequiredWithoutShipmentsNestedInput = {
    create?: XOR<OrderCreateWithoutShipmentsInput, OrderUncheckedCreateWithoutShipmentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutShipmentsInput
    upsert?: OrderUpsertWithoutShipmentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutShipmentsInput, OrderUpdateWithoutShipmentsInput>, OrderUncheckedUpdateWithoutShipmentsInput>
  }

  export type PaymentUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput> | PaymentCreateWithoutShipmentInput[] | PaymentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShipmentInput | PaymentCreateOrConnectWithoutShipmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutShipmentInput | PaymentUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: PaymentCreateManyShipmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutShipmentInput | PaymentUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutShipmentInput | PaymentUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<DocumentCreateWithoutShipmentInput, DocumentUncheckedCreateWithoutShipmentInput> | DocumentCreateWithoutShipmentInput[] | DocumentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutShipmentInput | DocumentCreateOrConnectWithoutShipmentInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutShipmentInput | DocumentUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: DocumentCreateManyShipmentInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutShipmentInput | DocumentUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutShipmentInput | DocumentUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput> | PaymentCreateWithoutShipmentInput[] | PaymentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutShipmentInput | PaymentCreateOrConnectWithoutShipmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutShipmentInput | PaymentUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: PaymentCreateManyShipmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutShipmentInput | PaymentUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutShipmentInput | PaymentUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutShipmentNestedInput = {
    create?: XOR<DocumentCreateWithoutShipmentInput, DocumentUncheckedCreateWithoutShipmentInput> | DocumentCreateWithoutShipmentInput[] | DocumentUncheckedCreateWithoutShipmentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutShipmentInput | DocumentCreateOrConnectWithoutShipmentInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutShipmentInput | DocumentUpsertWithWhereUniqueWithoutShipmentInput[]
    createMany?: DocumentCreateManyShipmentInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutShipmentInput | DocumentUpdateWithWhereUniqueWithoutShipmentInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutShipmentInput | DocumentUpdateManyWithWhereWithoutShipmentInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type StaffUserCreateNestedOneWithoutCreatedPaymentsInput = {
    create?: XOR<StaffUserCreateWithoutCreatedPaymentsInput, StaffUserUncheckedCreateWithoutCreatedPaymentsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedPaymentsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutUpdatedPaymentsInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedPaymentsInput, StaffUserUncheckedCreateWithoutUpdatedPaymentsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedPaymentsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ShipmentCreateWithoutPaymentsInput, ShipmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutPaymentsInput
    connect?: ShipmentWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutPaymentInput = {
    create?: XOR<DocumentCreateWithoutPaymentInput, DocumentUncheckedCreateWithoutPaymentInput> | DocumentCreateWithoutPaymentInput[] | DocumentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPaymentInput | DocumentCreateOrConnectWithoutPaymentInput[]
    createMany?: DocumentCreateManyPaymentInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<DocumentCreateWithoutPaymentInput, DocumentUncheckedCreateWithoutPaymentInput> | DocumentCreateWithoutPaymentInput[] | DocumentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPaymentInput | DocumentCreateOrConnectWithoutPaymentInput[]
    createMany?: DocumentCreateManyPaymentInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type StaffUserUpdateOneRequiredWithoutCreatedPaymentsNestedInput = {
    create?: XOR<StaffUserCreateWithoutCreatedPaymentsInput, StaffUserUncheckedCreateWithoutCreatedPaymentsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutCreatedPaymentsInput
    upsert?: StaffUserUpsertWithoutCreatedPaymentsInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutCreatedPaymentsInput, StaffUserUpdateWithoutCreatedPaymentsInput>, StaffUserUncheckedUpdateWithoutCreatedPaymentsInput>
  }

  export type StaffUserUpdateOneRequiredWithoutUpdatedPaymentsNestedInput = {
    create?: XOR<StaffUserCreateWithoutUpdatedPaymentsInput, StaffUserUncheckedCreateWithoutUpdatedPaymentsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutUpdatedPaymentsInput
    upsert?: StaffUserUpsertWithoutUpdatedPaymentsInput
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutUpdatedPaymentsInput, StaffUserUpdateWithoutUpdatedPaymentsInput>, StaffUserUncheckedUpdateWithoutUpdatedPaymentsInput>
  }

  export type OrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type ShipmentUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<ShipmentCreateWithoutPaymentsInput, ShipmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutPaymentsInput
    upsert?: ShipmentUpsertWithoutPaymentsInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutPaymentsInput, ShipmentUpdateWithoutPaymentsInput>, ShipmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type DocumentUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<DocumentCreateWithoutPaymentInput, DocumentUncheckedCreateWithoutPaymentInput> | DocumentCreateWithoutPaymentInput[] | DocumentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPaymentInput | DocumentCreateOrConnectWithoutPaymentInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPaymentInput | DocumentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: DocumentCreateManyPaymentInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPaymentInput | DocumentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPaymentInput | DocumentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<DocumentCreateWithoutPaymentInput, DocumentUncheckedCreateWithoutPaymentInput> | DocumentCreateWithoutPaymentInput[] | DocumentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutPaymentInput | DocumentCreateOrConnectWithoutPaymentInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutPaymentInput | DocumentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: DocumentCreateManyPaymentInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutPaymentInput | DocumentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutPaymentInput | DocumentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type OpportunityCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<OpportunityCreateWithoutDocumentsInput, OpportunityUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutDocumentsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type QuotationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<QuotationCreateWithoutDocumentsInput, QuotationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutDocumentsInput
    connect?: QuotationWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<OrderCreateWithoutDocumentsInput, OrderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDocumentsInput
    connect?: OrderWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PurchaseOrderCreateWithoutDocumentsInput, PurchaseOrderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutDocumentsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ShipmentCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ShipmentCreateWithoutDocumentsInput, ShipmentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutDocumentsInput
    connect?: ShipmentWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PaymentCreateWithoutDocumentsInput, PaymentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutDocumentsInput
    connect?: PaymentWhereUniqueInput
  }

  export type OpportunityUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<OpportunityCreateWithoutDocumentsInput, OpportunityUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutDocumentsInput
    upsert?: OpportunityUpsertWithoutDocumentsInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutDocumentsInput, OpportunityUpdateWithoutDocumentsInput>, OpportunityUncheckedUpdateWithoutDocumentsInput>
  }

  export type QuotationUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<QuotationCreateWithoutDocumentsInput, QuotationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutDocumentsInput
    upsert?: QuotationUpsertWithoutDocumentsInput
    disconnect?: QuotationWhereInput | boolean
    delete?: QuotationWhereInput | boolean
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutDocumentsInput, QuotationUpdateWithoutDocumentsInput>, QuotationUncheckedUpdateWithoutDocumentsInput>
  }

  export type OrderUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<OrderCreateWithoutDocumentsInput, OrderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDocumentsInput
    upsert?: OrderUpsertWithoutDocumentsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDocumentsInput, OrderUpdateWithoutDocumentsInput>, OrderUncheckedUpdateWithoutDocumentsInput>
  }

  export type PurchaseOrderUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutDocumentsInput, PurchaseOrderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutDocumentsInput
    upsert?: PurchaseOrderUpsertWithoutDocumentsInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutDocumentsInput, PurchaseOrderUpdateWithoutDocumentsInput>, PurchaseOrderUncheckedUpdateWithoutDocumentsInput>
  }

  export type ShipmentUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ShipmentCreateWithoutDocumentsInput, ShipmentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ShipmentCreateOrConnectWithoutDocumentsInput
    upsert?: ShipmentUpsertWithoutDocumentsInput
    disconnect?: ShipmentWhereInput | boolean
    delete?: ShipmentWhereInput | boolean
    connect?: ShipmentWhereUniqueInput
    update?: XOR<XOR<ShipmentUpdateToOneWithWhereWithoutDocumentsInput, ShipmentUpdateWithoutDocumentsInput>, ShipmentUncheckedUpdateWithoutDocumentsInput>
  }

  export type PaymentUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<PaymentCreateWithoutDocumentsInput, PaymentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutDocumentsInput
    upsert?: PaymentUpsertWithoutDocumentsInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutDocumentsInput, PaymentUpdateWithoutDocumentsInput>, PaymentUncheckedUpdateWithoutDocumentsInput>
  }

  export type CustomerCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<CustomerCreateWithoutCommunicationsInput, CustomerUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCommunicationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<OpportunityCreateWithoutCommunicationsInput, OpportunityUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutCommunicationsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type QuotationCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<QuotationCreateWithoutCommunicationsInput, QuotationUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutCommunicationsInput
    connect?: QuotationWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<OrderCreateWithoutCommunicationsInput, OrderUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCommunicationsInput
    connect?: OrderWhereUniqueInput
  }

  export type StaffUserCreateNestedOneWithoutLoggedCommunicationsInput = {
    create?: XOR<StaffUserCreateWithoutLoggedCommunicationsInput, StaffUserUncheckedCreateWithoutLoggedCommunicationsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutLoggedCommunicationsInput
    connect?: StaffUserWhereUniqueInput
  }

  export type EnumCommunicationTypeFieldUpdateOperationsInput = {
    set?: $Enums.CommunicationType
  }

  export type EnumCommunicationDirectionFieldUpdateOperationsInput = {
    set?: $Enums.CommunicationDirection
  }

  export type CustomerUpdateOneWithoutCommunicationsNestedInput = {
    create?: XOR<CustomerCreateWithoutCommunicationsInput, CustomerUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCommunicationsInput
    upsert?: CustomerUpsertWithoutCommunicationsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCommunicationsInput, CustomerUpdateWithoutCommunicationsInput>, CustomerUncheckedUpdateWithoutCommunicationsInput>
  }

  export type OpportunityUpdateOneWithoutCommunicationsNestedInput = {
    create?: XOR<OpportunityCreateWithoutCommunicationsInput, OpportunityUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutCommunicationsInput
    upsert?: OpportunityUpsertWithoutCommunicationsInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutCommunicationsInput, OpportunityUpdateWithoutCommunicationsInput>, OpportunityUncheckedUpdateWithoutCommunicationsInput>
  }

  export type QuotationUpdateOneWithoutCommunicationsNestedInput = {
    create?: XOR<QuotationCreateWithoutCommunicationsInput, QuotationUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutCommunicationsInput
    upsert?: QuotationUpsertWithoutCommunicationsInput
    disconnect?: QuotationWhereInput | boolean
    delete?: QuotationWhereInput | boolean
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutCommunicationsInput, QuotationUpdateWithoutCommunicationsInput>, QuotationUncheckedUpdateWithoutCommunicationsInput>
  }

  export type OrderUpdateOneWithoutCommunicationsNestedInput = {
    create?: XOR<OrderCreateWithoutCommunicationsInput, OrderUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCommunicationsInput
    upsert?: OrderUpsertWithoutCommunicationsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutCommunicationsInput, OrderUpdateWithoutCommunicationsInput>, OrderUncheckedUpdateWithoutCommunicationsInput>
  }

  export type StaffUserUpdateOneWithoutLoggedCommunicationsNestedInput = {
    create?: XOR<StaffUserCreateWithoutLoggedCommunicationsInput, StaffUserUncheckedCreateWithoutLoggedCommunicationsInput>
    connectOrCreate?: StaffUserCreateOrConnectWithoutLoggedCommunicationsInput
    upsert?: StaffUserUpsertWithoutLoggedCommunicationsInput
    disconnect?: StaffUserWhereInput | boolean
    delete?: StaffUserWhereInput | boolean
    connect?: StaffUserWhereUniqueInput
    update?: XOR<XOR<StaffUserUpdateToOneWithWhereWithoutLoggedCommunicationsInput, StaffUserUpdateWithoutLoggedCommunicationsInput>, StaffUserUncheckedUpdateWithoutLoggedCommunicationsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyFilter<$PrismaModel> | $Enums.Currency
  }

  export type NestedEnumCurrencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyWithAggregatesFilter<$PrismaModel> | $Enums.Currency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyFilter<$PrismaModel>
    _max?: NestedEnumCurrencyFilter<$PrismaModel>
  }

  export type NestedEnumOpportunityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusFilter<$PrismaModel> | $Enums.OpportunityStatus
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityStatusFilter<$PrismaModel>
    _max?: NestedEnumOpportunityStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuotationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusFilter<$PrismaModel> | $Enums.QuotationStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuotationStatus | EnumQuotationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuotationStatus[] | ListEnumQuotationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuotationStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuotationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuotationStatusFilter<$PrismaModel>
    _max?: NestedEnumQuotationStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumShipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusFilter<$PrismaModel> | $Enums.ShipmentStatus
  }

  export type NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShipmentStatus | EnumShipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShipmentStatus[] | ListEnumShipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumShipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumShipmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumCommunicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeFilter<$PrismaModel> | $Enums.CommunicationType
  }

  export type NestedEnumCommunicationDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationDirection | EnumCommunicationDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationDirection[] | ListEnumCommunicationDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationDirection[] | ListEnumCommunicationDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationDirectionFilter<$PrismaModel> | $Enums.CommunicationDirection
  }

  export type NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationType | EnumCommunicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationType[] | ListEnumCommunicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationTypeFilter<$PrismaModel>
    _max?: NestedEnumCommunicationTypeFilter<$PrismaModel>
  }

  export type NestedEnumCommunicationDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationDirection | EnumCommunicationDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationDirection[] | ListEnumCommunicationDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommunicationDirection[] | ListEnumCommunicationDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCommunicationDirectionWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationDirectionFilter<$PrismaModel>
    _max?: NestedEnumCommunicationDirectionFilter<$PrismaModel>
  }

  export type OpportunityCreateWithoutCreatedByInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOpportunitiesInput
    quotations?: QuotationCreateNestedManyWithoutOpportunityInput
    orders?: OrderCreateNestedManyWithoutOpportunityInput
    documents?: DocumentCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutCreatedByInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    updatedById: string
    quotations?: QuotationUncheckedCreateNestedManyWithoutOpportunityInput
    orders?: OrderUncheckedCreateNestedManyWithoutOpportunityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutCreatedByInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutCreatedByInput, OpportunityUncheckedCreateWithoutCreatedByInput>
  }

  export type OpportunityCreateManyCreatedByInputEnvelope = {
    data: OpportunityCreateManyCreatedByInput | OpportunityCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutUpdatedByInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedOpportunitiesInput
    quotations?: QuotationCreateNestedManyWithoutOpportunityInput
    orders?: OrderCreateNestedManyWithoutOpportunityInput
    documents?: DocumentCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    createdById: string
    quotations?: QuotationUncheckedCreateNestedManyWithoutOpportunityInput
    orders?: OrderUncheckedCreateNestedManyWithoutOpportunityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutUpdatedByInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutUpdatedByInput, OpportunityUncheckedCreateWithoutUpdatedByInput>
  }

  export type OpportunityCreateManyUpdatedByInputEnvelope = {
    data: OpportunityCreateManyUpdatedByInput | OpportunityCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutCreatedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: StaffUserCreateNestedOneWithoutApprovedQuotationsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedQuotationsInput
    opportunity: OpportunityCreateNestedOneWithoutQuotationsInput
    items?: QuoteItemCreateNestedManyWithoutQuotationInput
    order?: OrderCreateNestedOneWithoutQuotationInput
    documents?: DocumentCreateNestedManyWithoutQuotationInput
    communications?: CommunicationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutCreatedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    opportunityId: string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuotationInput
    order?: OrderUncheckedCreateNestedOneWithoutQuotationInput
    documents?: DocumentUncheckedCreateNestedManyWithoutQuotationInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutCreatedByInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutCreatedByInput, QuotationUncheckedCreateWithoutCreatedByInput>
  }

  export type QuotationCreateManyCreatedByInputEnvelope = {
    data: QuotationCreateManyCreatedByInput | QuotationCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutUpdatedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: StaffUserCreateNestedOneWithoutApprovedQuotationsInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedQuotationsInput
    opportunity: OpportunityCreateNestedOneWithoutQuotationsInput
    items?: QuoteItemCreateNestedManyWithoutQuotationInput
    order?: OrderCreateNestedOneWithoutQuotationInput
    documents?: DocumentCreateNestedManyWithoutQuotationInput
    communications?: CommunicationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    opportunityId: string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuotationInput
    order?: OrderUncheckedCreateNestedOneWithoutQuotationInput
    documents?: DocumentUncheckedCreateNestedManyWithoutQuotationInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutUpdatedByInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutUpdatedByInput, QuotationUncheckedCreateWithoutUpdatedByInput>
  }

  export type QuotationCreateManyUpdatedByInputEnvelope = {
    data: QuotationCreateManyUpdatedByInput | QuotationCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCreatedByInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCreatedByInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    opportunityId: string
    quotationId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput>
  }

  export type OrderCreateManyCreatedByInputEnvelope = {
    data: OrderCreateManyCreatedByInput | OrderCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUpdatedByInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    opportunityId: string
    quotationId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUpdatedByInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUpdatedByInput, OrderUncheckedCreateWithoutUpdatedByInput>
  }

  export type OrderCreateManyUpdatedByInputEnvelope = {
    data: OrderCreateManyUpdatedByInput | OrderCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentCreateWithoutCreatedByInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedShipmentsInput
    order: OrderCreateNestedOneWithoutShipmentsInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    documents?: DocumentCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    orderId: string
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutCreatedByInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutCreatedByInput, ShipmentUncheckedCreateWithoutCreatedByInput>
  }

  export type ShipmentCreateManyCreatedByInputEnvelope = {
    data: ShipmentCreateManyCreatedByInput | ShipmentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ShipmentCreateWithoutUpdatedByInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedShipmentsInput
    order: OrderCreateNestedOneWithoutShipmentsInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    documents?: DocumentCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    orderId: string
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutUpdatedByInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutUpdatedByInput, ShipmentUncheckedCreateWithoutUpdatedByInput>
  }

  export type ShipmentCreateManyUpdatedByInputEnvelope = {
    data: ShipmentCreateManyUpdatedByInput | ShipmentCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCreatedByInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
    shipment?: ShipmentCreateNestedOneWithoutPaymentsInput
    documents?: DocumentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    orderId: string
    shipmentId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput>
  }

  export type PaymentCreateManyCreatedByInputEnvelope = {
    data: PaymentCreateManyCreatedByInput | PaymentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUpdatedByInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
    shipment?: ShipmentCreateNestedOneWithoutPaymentsInput
    documents?: DocumentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    orderId: string
    shipmentId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutUpdatedByInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUpdatedByInput, PaymentUncheckedCreateWithoutUpdatedByInput>
  }

  export type PaymentCreateManyUpdatedByInputEnvelope = {
    data: PaymentCreateManyUpdatedByInput | PaymentCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type QuotationCreateWithoutApprovedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedQuotationsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedQuotationsInput
    opportunity: OpportunityCreateNestedOneWithoutQuotationsInput
    items?: QuoteItemCreateNestedManyWithoutQuotationInput
    order?: OrderCreateNestedOneWithoutQuotationInput
    documents?: DocumentCreateNestedManyWithoutQuotationInput
    communications?: CommunicationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutApprovedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuotationInput
    order?: OrderUncheckedCreateNestedOneWithoutQuotationInput
    documents?: DocumentUncheckedCreateNestedManyWithoutQuotationInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutApprovedByInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput>
  }

  export type QuotationCreateManyApprovedByInputEnvelope = {
    data: QuotationCreateManyApprovedByInput | QuotationCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssignedUserInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUncheckedCreateWithoutAssignedUserInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutAssignedUserInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssignedUserInput, TaskUncheckedCreateWithoutAssignedUserInput>
  }

  export type TaskCreateManyAssignedUserInputEnvelope = {
    data: TaskCreateManyAssignedUserInput | TaskCreateManyAssignedUserInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutLoggedByInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutCommunicationsInput
    opportunity?: OpportunityCreateNestedOneWithoutCommunicationsInput
    quotation?: QuotationCreateNestedOneWithoutCommunicationsInput
    order?: OrderCreateNestedOneWithoutCommunicationsInput
  }

  export type CommunicationUncheckedCreateWithoutLoggedByInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
  }

  export type CommunicationCreateOrConnectWithoutLoggedByInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutLoggedByInput, CommunicationUncheckedCreateWithoutLoggedByInput>
  }

  export type CommunicationCreateManyLoggedByInputEnvelope = {
    data: CommunicationCreateManyLoggedByInput | CommunicationCreateManyLoggedByInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutProjectManagerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProjectsInput
    teamMembers?: StaffUserCreateNestedManyWithoutMemberOfProjectsInput
  }

  export type ProjectUncheckedCreateWithoutProjectManagerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    teamMembers?: StaffUserUncheckedCreateNestedManyWithoutMemberOfProjectsInput
  }

  export type ProjectCreateOrConnectWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput>
  }

  export type ProjectCreateManyProjectManagerInputEnvelope = {
    data: ProjectCreateManyProjectManagerInput | ProjectCreateManyProjectManagerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutTeamMembersInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProjectsInput
    projectManager?: StaffUserCreateNestedOneWithoutManagedProjectsInput
  }

  export type ProjectUncheckedCreateWithoutTeamMembersInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    projectManagerId?: string | null
  }

  export type ProjectCreateOrConnectWithoutTeamMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
  }

  export type OpportunityUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutCreatedByInput, OpportunityUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OpportunityCreateWithoutCreatedByInput, OpportunityUncheckedCreateWithoutCreatedByInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutCreatedByInput, OpportunityUncheckedUpdateWithoutCreatedByInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutCreatedByInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type OpportunityScalarWhereInput = {
    AND?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    OR?: OpportunityScalarWhereInput[]
    NOT?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    id?: UuidFilter<"Opportunity"> | string
    oppRef?: StringFilter<"Opportunity"> | string
    title?: StringFilter<"Opportunity"> | string
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    value?: FloatFilter<"Opportunity"> | number
    currency?: EnumCurrencyFilter<"Opportunity"> | $Enums.Currency
    description?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    customerId?: UuidFilter<"Opportunity"> | string
    createdById?: UuidFilter<"Opportunity"> | string
    updatedById?: UuidFilter<"Opportunity"> | string
  }

  export type OpportunityUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutUpdatedByInput, OpportunityUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<OpportunityCreateWithoutUpdatedByInput, OpportunityUncheckedCreateWithoutUpdatedByInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutUpdatedByInput, OpportunityUncheckedUpdateWithoutUpdatedByInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutUpdatedByInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutCreatedByInput, QuotationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<QuotationCreateWithoutCreatedByInput, QuotationUncheckedCreateWithoutCreatedByInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutCreatedByInput, QuotationUncheckedUpdateWithoutCreatedByInput>
  }

  export type QuotationUpdateManyWithWhereWithoutCreatedByInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type QuotationScalarWhereInput = {
    AND?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
    OR?: QuotationScalarWhereInput[]
    NOT?: QuotationScalarWhereInput | QuotationScalarWhereInput[]
    id?: UuidFilter<"Quotation"> | string
    quoteRef?: StringFilter<"Quotation"> | string
    revision?: IntFilter<"Quotation"> | number
    status?: EnumQuotationStatusFilter<"Quotation"> | $Enums.QuotationStatus
    currency?: EnumCurrencyFilter<"Quotation"> | $Enums.Currency
    fxRate?: FloatFilter<"Quotation"> | number
    totalCost?: FloatFilter<"Quotation"> | number
    markupPercent?: FloatFilter<"Quotation"> | number
    insurancePercent?: FloatFilter<"Quotation"> | number
    financeCharge?: FloatFilter<"Quotation"> | number
    subtotal?: FloatFilter<"Quotation"> | number
    vatPercent?: FloatFilter<"Quotation"> | number
    totalWithVAT?: FloatFilter<"Quotation"> | number
    profitMarginBHD?: FloatFilter<"Quotation"> | number
    fxGain?: FloatNullableFilter<"Quotation"> | number | null
    validUntil?: DateTimeFilter<"Quotation"> | Date | string
    paymentTerms?: StringNullableFilter<"Quotation"> | string | null
    deliveryTerms?: StringNullableFilter<"Quotation"> | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Quotation"> | Date | string | null
    marginApprovalPopup?: BoolFilter<"Quotation"> | boolean
    approvedById?: UuidNullableFilter<"Quotation"> | string | null
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    updatedAt?: DateTimeFilter<"Quotation"> | Date | string
    createdById?: UuidFilter<"Quotation"> | string
    updatedById?: UuidFilter<"Quotation"> | string
    opportunityId?: UuidFilter<"Quotation"> | string
  }

  export type QuotationUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutUpdatedByInput, QuotationUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<QuotationCreateWithoutUpdatedByInput, QuotationUncheckedCreateWithoutUpdatedByInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutUpdatedByInput, QuotationUncheckedUpdateWithoutUpdatedByInput>
  }

  export type QuotationUpdateManyWithWhereWithoutUpdatedByInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCreatedByInput, OrderUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCreatedByInput, OrderUncheckedUpdateWithoutCreatedByInput>
  }

  export type OrderUpdateManyWithWhereWithoutCreatedByInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: UuidFilter<"Order"> | string
    orderRef?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"Order"> | Date | string
    totalValue?: FloatFilter<"Order"> | number
    currency?: EnumCurrencyFilter<"Order"> | $Enums.Currency
    expectedDeliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    createdById?: UuidFilter<"Order"> | string
    updatedById?: UuidFilter<"Order"> | string
    opportunityId?: UuidFilter<"Order"> | string
    quotationId?: UuidFilter<"Order"> | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUpdatedByInput, OrderUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<OrderCreateWithoutUpdatedByInput, OrderUncheckedCreateWithoutUpdatedByInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUpdatedByInput, OrderUncheckedUpdateWithoutUpdatedByInput>
  }

  export type OrderUpdateManyWithWhereWithoutUpdatedByInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type ShipmentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutCreatedByInput, ShipmentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ShipmentCreateWithoutCreatedByInput, ShipmentUncheckedCreateWithoutCreatedByInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutCreatedByInput, ShipmentUncheckedUpdateWithoutCreatedByInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutCreatedByInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ShipmentScalarWhereInput = {
    AND?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
    OR?: ShipmentScalarWhereInput[]
    NOT?: ShipmentScalarWhereInput | ShipmentScalarWhereInput[]
    id?: UuidFilter<"Shipment"> | string
    shipmentRef?: StringFilter<"Shipment"> | string
    status?: EnumShipmentStatusFilter<"Shipment"> | $Enums.ShipmentStatus
    trackingNumber?: StringNullableFilter<"Shipment"> | string | null
    carrier?: StringNullableFilter<"Shipment"> | string | null
    shippedOn?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    actualShipmentDate?: DateTimeNullableFilter<"Shipment"> | Date | string | null
    createdAt?: DateTimeFilter<"Shipment"> | Date | string
    updatedAt?: DateTimeFilter<"Shipment"> | Date | string
    createdById?: UuidFilter<"Shipment"> | string
    updatedById?: UuidFilter<"Shipment"> | string
    orderId?: UuidFilter<"Shipment"> | string
  }

  export type ShipmentUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutUpdatedByInput, ShipmentUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<ShipmentCreateWithoutUpdatedByInput, ShipmentUncheckedCreateWithoutUpdatedByInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutUpdatedByInput, ShipmentUncheckedUpdateWithoutUpdatedByInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutUpdatedByInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCreatedByInput, PaymentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PaymentCreateWithoutCreatedByInput, PaymentUncheckedCreateWithoutCreatedByInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCreatedByInput, PaymentUncheckedUpdateWithoutCreatedByInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCreatedByInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    paymentRef?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: EnumCurrencyFilter<"Payment"> | $Enums.Currency
    paymentMethod?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentReceivedOn?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    createdById?: UuidFilter<"Payment"> | string
    updatedById?: UuidFilter<"Payment"> | string
    orderId?: UuidFilter<"Payment"> | string
    shipmentId?: UuidNullableFilter<"Payment"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUpdatedByInput, PaymentUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<PaymentCreateWithoutUpdatedByInput, PaymentUncheckedCreateWithoutUpdatedByInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUpdatedByInput, PaymentUncheckedUpdateWithoutUpdatedByInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUpdatedByInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type QuotationUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutApprovedByInput, QuotationUncheckedUpdateWithoutApprovedByInput>
    create: XOR<QuotationCreateWithoutApprovedByInput, QuotationUncheckedCreateWithoutApprovedByInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutApprovedByInput, QuotationUncheckedUpdateWithoutApprovedByInput>
  }

  export type QuotationUpdateManyWithWhereWithoutApprovedByInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutAssignedUserInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssignedUserInput, TaskUncheckedUpdateWithoutAssignedUserInput>
    create: XOR<TaskCreateWithoutAssignedUserInput, TaskUncheckedCreateWithoutAssignedUserInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssignedUserInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssignedUserInput, TaskUncheckedUpdateWithoutAssignedUserInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssignedUserInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssignedUserInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: UuidFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignedUserId?: UuidNullableFilter<"Task"> | string | null
  }

  export type CommunicationUpsertWithWhereUniqueWithoutLoggedByInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutLoggedByInput, CommunicationUncheckedUpdateWithoutLoggedByInput>
    create: XOR<CommunicationCreateWithoutLoggedByInput, CommunicationUncheckedCreateWithoutLoggedByInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutLoggedByInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutLoggedByInput, CommunicationUncheckedUpdateWithoutLoggedByInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutLoggedByInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutLoggedByInput>
  }

  export type CommunicationScalarWhereInput = {
    AND?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
    OR?: CommunicationScalarWhereInput[]
    NOT?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
    id?: UuidFilter<"Communication"> | string
    type?: EnumCommunicationTypeFilter<"Communication"> | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFilter<"Communication"> | $Enums.CommunicationDirection
    content?: StringFilter<"Communication"> | string
    subject?: StringNullableFilter<"Communication"> | string | null
    sender?: StringFilter<"Communication"> | string
    recipient?: StringNullableFilter<"Communication"> | string | null
    timestamp?: DateTimeFilter<"Communication"> | Date | string
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
    customerId?: UuidNullableFilter<"Communication"> | string | null
    opportunityId?: UuidNullableFilter<"Communication"> | string | null
    quotationId?: UuidNullableFilter<"Communication"> | string | null
    orderId?: UuidNullableFilter<"Communication"> | string | null
    loggedByStaffId?: UuidNullableFilter<"Communication"> | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProjectManagerInput, ProjectUncheckedUpdateWithoutProjectManagerInput>
    create: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProjectManagerInput, ProjectUncheckedUpdateWithoutProjectManagerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProjectManagerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectManagerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: UuidFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    customerId?: UuidFilter<"Project"> | string
    projectManagerId?: UuidNullableFilter<"Project"> | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutTeamMembersInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutTeamMembersInput, ProjectUncheckedUpdateWithoutTeamMembersInput>
    create: XOR<ProjectCreateWithoutTeamMembersInput, ProjectUncheckedCreateWithoutTeamMembersInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutTeamMembersInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutTeamMembersInput, ProjectUncheckedUpdateWithoutTeamMembersInput>
  }

  export type ProjectUpdateManyWithWhereWithoutTeamMembersInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutTeamMembersInput>
  }

  export type StaffUserCreateWithoutAssignedTasksInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutAssignedTasksInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutAssignedTasksInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutAssignedTasksInput, StaffUserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type StaffUserUpsertWithoutAssignedTasksInput = {
    update: XOR<StaffUserUpdateWithoutAssignedTasksInput, StaffUserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<StaffUserCreateWithoutAssignedTasksInput, StaffUserUncheckedCreateWithoutAssignedTasksInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutAssignedTasksInput, StaffUserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type StaffUserUpdateWithoutAssignedTasksInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutAssignedTasksInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type OpportunityCreateWithoutCustomerInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOpportunitiesInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOpportunitiesInput
    quotations?: QuotationCreateNestedManyWithoutOpportunityInput
    orders?: OrderCreateNestedManyWithoutOpportunityInput
    documents?: DocumentCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutCustomerInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    quotations?: QuotationUncheckedCreateNestedManyWithoutOpportunityInput
    orders?: OrderUncheckedCreateNestedManyWithoutOpportunityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutCustomerInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput>
  }

  export type OpportunityCreateManyCustomerInputEnvelope = {
    data: OpportunityCreateManyCustomerInput | OpportunityCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCustomerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectManager?: StaffUserCreateNestedOneWithoutManagedProjectsInput
    teamMembers?: StaffUserCreateNestedManyWithoutMemberOfProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCustomerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectManagerId?: string | null
    teamMembers?: StaffUserUncheckedCreateNestedManyWithoutMemberOfProjectsInput
  }

  export type ProjectCreateOrConnectWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput>
  }

  export type ProjectCreateManyCustomerInputEnvelope = {
    data: ProjectCreateManyCustomerInput | ProjectCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutCommunicationsInput
    quotation?: QuotationCreateNestedOneWithoutCommunicationsInput
    order?: OrderCreateNestedOneWithoutCommunicationsInput
    loggedBy?: StaffUserCreateNestedOneWithoutLoggedCommunicationsInput
  }

  export type CommunicationUncheckedCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    loggedByStaffId?: string | null
  }

  export type CommunicationCreateOrConnectWithoutCustomerInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutCustomerInput, CommunicationUncheckedCreateWithoutCustomerInput>
  }

  export type CommunicationCreateManyCustomerInputEnvelope = {
    data: CommunicationCreateManyCustomerInput | CommunicationCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutCustomerInput, OpportunityUncheckedUpdateWithoutCustomerInput>
    create: XOR<OpportunityCreateWithoutCustomerInput, OpportunityUncheckedCreateWithoutCustomerInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutCustomerInput, OpportunityUncheckedUpdateWithoutCustomerInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutCustomerInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCustomerInput, ProjectUncheckedUpdateWithoutCustomerInput>
    create: XOR<ProjectCreateWithoutCustomerInput, ProjectUncheckedCreateWithoutCustomerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCustomerInput, ProjectUncheckedUpdateWithoutCustomerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCustomerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CommunicationUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutCustomerInput, CommunicationUncheckedUpdateWithoutCustomerInput>
    create: XOR<CommunicationCreateWithoutCustomerInput, CommunicationUncheckedCreateWithoutCustomerInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutCustomerInput, CommunicationUncheckedUpdateWithoutCustomerInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutCustomerInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutOpportunitiesInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCustomerInput
    communications?: CommunicationCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOpportunitiesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOpportunitiesInput, CustomerUncheckedCreateWithoutOpportunitiesInput>
  }

  export type StaffUserCreateWithoutCreatedOpportunitiesInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutCreatedOpportunitiesInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutCreatedOpportunitiesInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutCreatedOpportunitiesInput, StaffUserUncheckedCreateWithoutCreatedOpportunitiesInput>
  }

  export type StaffUserCreateWithoutUpdatedOpportunitiesInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutUpdatedOpportunitiesInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutUpdatedOpportunitiesInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutUpdatedOpportunitiesInput, StaffUserUncheckedCreateWithoutUpdatedOpportunitiesInput>
  }

  export type QuotationCreateWithoutOpportunityInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: StaffUserCreateNestedOneWithoutApprovedQuotationsInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedQuotationsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedQuotationsInput
    items?: QuoteItemCreateNestedManyWithoutQuotationInput
    order?: OrderCreateNestedOneWithoutQuotationInput
    documents?: DocumentCreateNestedManyWithoutQuotationInput
    communications?: CommunicationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutOpportunityInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuotationInput
    order?: OrderUncheckedCreateNestedOneWithoutQuotationInput
    documents?: DocumentUncheckedCreateNestedManyWithoutQuotationInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutOpportunityInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutOpportunityInput, QuotationUncheckedCreateWithoutOpportunityInput>
  }

  export type QuotationCreateManyOpportunityInputEnvelope = {
    data: QuotationCreateManyOpportunityInput | QuotationCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutOpportunityInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOpportunityInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    quotationId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOpportunityInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOpportunityInput, OrderUncheckedCreateWithoutOpportunityInput>
  }

  export type OrderCreateManyOpportunityInputEnvelope = {
    data: OrderCreateManyOpportunityInput | OrderCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutOpportunityInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    quotation?: QuotationCreateNestedOneWithoutDocumentsInput
    order?: OrderCreateNestedOneWithoutDocumentsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutDocumentsInput
    shipment?: ShipmentCreateNestedOneWithoutDocumentsInput
    payment?: PaymentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutOpportunityInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    quotationId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type DocumentCreateOrConnectWithoutOpportunityInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutOpportunityInput, DocumentUncheckedCreateWithoutOpportunityInput>
  }

  export type DocumentCreateManyOpportunityInputEnvelope = {
    data: DocumentCreateManyOpportunityInput | DocumentCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutOpportunityInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutCommunicationsInput
    quotation?: QuotationCreateNestedOneWithoutCommunicationsInput
    order?: OrderCreateNestedOneWithoutCommunicationsInput
    loggedBy?: StaffUserCreateNestedOneWithoutLoggedCommunicationsInput
  }

  export type CommunicationUncheckedCreateWithoutOpportunityInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    quotationId?: string | null
    orderId?: string | null
    loggedByStaffId?: string | null
  }

  export type CommunicationCreateOrConnectWithoutOpportunityInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutOpportunityInput, CommunicationUncheckedCreateWithoutOpportunityInput>
  }

  export type CommunicationCreateManyOpportunityInputEnvelope = {
    data: CommunicationCreateManyOpportunityInput | CommunicationCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOpportunitiesInput = {
    update: XOR<CustomerUpdateWithoutOpportunitiesInput, CustomerUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<CustomerCreateWithoutOpportunitiesInput, CustomerUncheckedCreateWithoutOpportunitiesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOpportunitiesInput, CustomerUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type CustomerUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
    communications?: CommunicationUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StaffUserUpsertWithoutCreatedOpportunitiesInput = {
    update: XOR<StaffUserUpdateWithoutCreatedOpportunitiesInput, StaffUserUncheckedUpdateWithoutCreatedOpportunitiesInput>
    create: XOR<StaffUserCreateWithoutCreatedOpportunitiesInput, StaffUserUncheckedCreateWithoutCreatedOpportunitiesInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutCreatedOpportunitiesInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutCreatedOpportunitiesInput, StaffUserUncheckedUpdateWithoutCreatedOpportunitiesInput>
  }

  export type StaffUserUpdateWithoutCreatedOpportunitiesInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutCreatedOpportunitiesInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUpsertWithoutUpdatedOpportunitiesInput = {
    update: XOR<StaffUserUpdateWithoutUpdatedOpportunitiesInput, StaffUserUncheckedUpdateWithoutUpdatedOpportunitiesInput>
    create: XOR<StaffUserCreateWithoutUpdatedOpportunitiesInput, StaffUserUncheckedCreateWithoutUpdatedOpportunitiesInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutUpdatedOpportunitiesInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutUpdatedOpportunitiesInput, StaffUserUncheckedUpdateWithoutUpdatedOpportunitiesInput>
  }

  export type StaffUserUpdateWithoutUpdatedOpportunitiesInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutUpdatedOpportunitiesInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type QuotationUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: QuotationWhereUniqueInput
    update: XOR<QuotationUpdateWithoutOpportunityInput, QuotationUncheckedUpdateWithoutOpportunityInput>
    create: XOR<QuotationCreateWithoutOpportunityInput, QuotationUncheckedCreateWithoutOpportunityInput>
  }

  export type QuotationUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: QuotationWhereUniqueInput
    data: XOR<QuotationUpdateWithoutOpportunityInput, QuotationUncheckedUpdateWithoutOpportunityInput>
  }

  export type QuotationUpdateManyWithWhereWithoutOpportunityInput = {
    where: QuotationScalarWhereInput
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOpportunityInput, OrderUncheckedUpdateWithoutOpportunityInput>
    create: XOR<OrderCreateWithoutOpportunityInput, OrderUncheckedCreateWithoutOpportunityInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOpportunityInput, OrderUncheckedUpdateWithoutOpportunityInput>
  }

  export type OrderUpdateManyWithWhereWithoutOpportunityInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutOpportunityInput, DocumentUncheckedUpdateWithoutOpportunityInput>
    create: XOR<DocumentCreateWithoutOpportunityInput, DocumentUncheckedCreateWithoutOpportunityInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutOpportunityInput, DocumentUncheckedUpdateWithoutOpportunityInput>
  }

  export type DocumentUpdateManyWithWhereWithoutOpportunityInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: UuidFilter<"Document"> | string
    fileName?: StringFilter<"Document"> | string
    fileType?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    sizeBytes?: IntFilter<"Document"> | number
    createdAt?: DateTimeFilter<"Document"> | Date | string
    opportunityId?: UuidNullableFilter<"Document"> | string | null
    quotationId?: UuidNullableFilter<"Document"> | string | null
    orderId?: UuidNullableFilter<"Document"> | string | null
    purchaseOrderId?: UuidNullableFilter<"Document"> | string | null
    shipmentId?: UuidNullableFilter<"Document"> | string | null
    paymentId?: UuidNullableFilter<"Document"> | string | null
  }

  export type CommunicationUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutOpportunityInput, CommunicationUncheckedUpdateWithoutOpportunityInput>
    create: XOR<CommunicationCreateWithoutOpportunityInput, CommunicationUncheckedCreateWithoutOpportunityInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutOpportunityInput, CommunicationUncheckedUpdateWithoutOpportunityInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutOpportunityInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type CustomerCreateWithoutProjectsInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityCreateNestedManyWithoutCustomerInput
    communications?: CommunicationCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutProjectsInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutCustomerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutProjectsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
  }

  export type StaffUserCreateWithoutManagedProjectsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutManagedProjectsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutManagedProjectsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutManagedProjectsInput, StaffUserUncheckedCreateWithoutManagedProjectsInput>
  }

  export type StaffUserCreateWithoutMemberOfProjectsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
  }

  export type StaffUserUncheckedCreateWithoutMemberOfProjectsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
  }

  export type StaffUserCreateOrConnectWithoutMemberOfProjectsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutMemberOfProjectsInput, StaffUserUncheckedCreateWithoutMemberOfProjectsInput>
  }

  export type CustomerUpsertWithoutProjectsInput = {
    update: XOR<CustomerUpdateWithoutProjectsInput, CustomerUncheckedUpdateWithoutProjectsInput>
    create: XOR<CustomerCreateWithoutProjectsInput, CustomerUncheckedCreateWithoutProjectsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutProjectsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutProjectsInput, CustomerUncheckedUpdateWithoutProjectsInput>
  }

  export type CustomerUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityUpdateManyWithoutCustomerNestedInput
    communications?: CommunicationUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityUncheckedUpdateManyWithoutCustomerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StaffUserUpsertWithoutManagedProjectsInput = {
    update: XOR<StaffUserUpdateWithoutManagedProjectsInput, StaffUserUncheckedUpdateWithoutManagedProjectsInput>
    create: XOR<StaffUserCreateWithoutManagedProjectsInput, StaffUserUncheckedCreateWithoutManagedProjectsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutManagedProjectsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutManagedProjectsInput, StaffUserUncheckedUpdateWithoutManagedProjectsInput>
  }

  export type StaffUserUpdateWithoutManagedProjectsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutManagedProjectsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUpsertWithWhereUniqueWithoutMemberOfProjectsInput = {
    where: StaffUserWhereUniqueInput
    update: XOR<StaffUserUpdateWithoutMemberOfProjectsInput, StaffUserUncheckedUpdateWithoutMemberOfProjectsInput>
    create: XOR<StaffUserCreateWithoutMemberOfProjectsInput, StaffUserUncheckedCreateWithoutMemberOfProjectsInput>
  }

  export type StaffUserUpdateWithWhereUniqueWithoutMemberOfProjectsInput = {
    where: StaffUserWhereUniqueInput
    data: XOR<StaffUserUpdateWithoutMemberOfProjectsInput, StaffUserUncheckedUpdateWithoutMemberOfProjectsInput>
  }

  export type StaffUserUpdateManyWithWhereWithoutMemberOfProjectsInput = {
    where: StaffUserScalarWhereInput
    data: XOR<StaffUserUpdateManyMutationInput, StaffUserUncheckedUpdateManyWithoutMemberOfProjectsInput>
  }

  export type StaffUserScalarWhereInput = {
    AND?: StaffUserScalarWhereInput | StaffUserScalarWhereInput[]
    OR?: StaffUserScalarWhereInput[]
    NOT?: StaffUserScalarWhereInput | StaffUserScalarWhereInput[]
    staffId?: UuidFilter<"StaffUser"> | string
    name?: StringFilter<"StaffUser"> | string
    email?: StringFilter<"StaffUser"> | string
    designation?: StringFilter<"StaffUser"> | string
    contactNumber?: StringNullableFilter<"StaffUser"> | string | null
    createdAt?: DateTimeFilter<"StaffUser"> | Date | string
    updatedAt?: DateTimeFilter<"StaffUser"> | Date | string
  }

  export type StaffUserCreateWithoutApprovedQuotationsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutApprovedQuotationsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutApprovedQuotationsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutApprovedQuotationsInput, StaffUserUncheckedCreateWithoutApprovedQuotationsInput>
  }

  export type StaffUserCreateWithoutCreatedQuotationsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutCreatedQuotationsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutCreatedQuotationsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutCreatedQuotationsInput, StaffUserUncheckedCreateWithoutCreatedQuotationsInput>
  }

  export type StaffUserCreateWithoutUpdatedQuotationsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutUpdatedQuotationsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutUpdatedQuotationsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutUpdatedQuotationsInput, StaffUserUncheckedCreateWithoutUpdatedQuotationsInput>
  }

  export type OpportunityCreateWithoutQuotationsInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedOpportunitiesInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOpportunitiesInput
    orders?: OrderCreateNestedManyWithoutOpportunityInput
    documents?: DocumentCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutQuotationsInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    createdById: string
    updatedById: string
    orders?: OrderUncheckedCreateNestedManyWithoutOpportunityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutQuotationsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutQuotationsInput, OpportunityUncheckedCreateWithoutQuotationsInput>
  }

  export type QuoteItemCreateWithoutQuotationInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    unitCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteItemUncheckedCreateWithoutQuotationInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    unitCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteItemCreateOrConnectWithoutQuotationInput = {
    where: QuoteItemWhereUniqueInput
    create: XOR<QuoteItemCreateWithoutQuotationInput, QuoteItemUncheckedCreateWithoutQuotationInput>
  }

  export type QuoteItemCreateManyQuotationInputEnvelope = {
    data: QuoteItemCreateManyQuotationInput | QuoteItemCreateManyQuotationInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutQuotationInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutQuotationInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutQuotationInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutQuotationInput, OrderUncheckedCreateWithoutQuotationInput>
  }

  export type DocumentCreateWithoutQuotationInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutDocumentsInput
    order?: OrderCreateNestedOneWithoutDocumentsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutDocumentsInput
    shipment?: ShipmentCreateNestedOneWithoutDocumentsInput
    payment?: PaymentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutQuotationInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type DocumentCreateOrConnectWithoutQuotationInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutQuotationInput, DocumentUncheckedCreateWithoutQuotationInput>
  }

  export type DocumentCreateManyQuotationInputEnvelope = {
    data: DocumentCreateManyQuotationInput | DocumentCreateManyQuotationInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutQuotationInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutCommunicationsInput
    opportunity?: OpportunityCreateNestedOneWithoutCommunicationsInput
    order?: OrderCreateNestedOneWithoutCommunicationsInput
    loggedBy?: StaffUserCreateNestedOneWithoutLoggedCommunicationsInput
  }

  export type CommunicationUncheckedCreateWithoutQuotationInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    opportunityId?: string | null
    orderId?: string | null
    loggedByStaffId?: string | null
  }

  export type CommunicationCreateOrConnectWithoutQuotationInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutQuotationInput, CommunicationUncheckedCreateWithoutQuotationInput>
  }

  export type CommunicationCreateManyQuotationInputEnvelope = {
    data: CommunicationCreateManyQuotationInput | CommunicationCreateManyQuotationInput[]
    skipDuplicates?: boolean
  }

  export type StaffUserUpsertWithoutApprovedQuotationsInput = {
    update: XOR<StaffUserUpdateWithoutApprovedQuotationsInput, StaffUserUncheckedUpdateWithoutApprovedQuotationsInput>
    create: XOR<StaffUserCreateWithoutApprovedQuotationsInput, StaffUserUncheckedCreateWithoutApprovedQuotationsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutApprovedQuotationsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutApprovedQuotationsInput, StaffUserUncheckedUpdateWithoutApprovedQuotationsInput>
  }

  export type StaffUserUpdateWithoutApprovedQuotationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutApprovedQuotationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUpsertWithoutCreatedQuotationsInput = {
    update: XOR<StaffUserUpdateWithoutCreatedQuotationsInput, StaffUserUncheckedUpdateWithoutCreatedQuotationsInput>
    create: XOR<StaffUserCreateWithoutCreatedQuotationsInput, StaffUserUncheckedCreateWithoutCreatedQuotationsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutCreatedQuotationsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutCreatedQuotationsInput, StaffUserUncheckedUpdateWithoutCreatedQuotationsInput>
  }

  export type StaffUserUpdateWithoutCreatedQuotationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutCreatedQuotationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUpsertWithoutUpdatedQuotationsInput = {
    update: XOR<StaffUserUpdateWithoutUpdatedQuotationsInput, StaffUserUncheckedUpdateWithoutUpdatedQuotationsInput>
    create: XOR<StaffUserCreateWithoutUpdatedQuotationsInput, StaffUserUncheckedCreateWithoutUpdatedQuotationsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutUpdatedQuotationsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutUpdatedQuotationsInput, StaffUserUncheckedUpdateWithoutUpdatedQuotationsInput>
  }

  export type StaffUserUpdateWithoutUpdatedQuotationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutUpdatedQuotationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type OpportunityUpsertWithoutQuotationsInput = {
    update: XOR<OpportunityUpdateWithoutQuotationsInput, OpportunityUncheckedUpdateWithoutQuotationsInput>
    create: XOR<OpportunityCreateWithoutQuotationsInput, OpportunityUncheckedCreateWithoutQuotationsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutQuotationsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutQuotationsInput, OpportunityUncheckedUpdateWithoutQuotationsInput>
  }

  export type OpportunityUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOpportunitiesNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOpportunitiesNestedInput
    orders?: OrderUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutQuotationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type QuoteItemUpsertWithWhereUniqueWithoutQuotationInput = {
    where: QuoteItemWhereUniqueInput
    update: XOR<QuoteItemUpdateWithoutQuotationInput, QuoteItemUncheckedUpdateWithoutQuotationInput>
    create: XOR<QuoteItemCreateWithoutQuotationInput, QuoteItemUncheckedCreateWithoutQuotationInput>
  }

  export type QuoteItemUpdateWithWhereUniqueWithoutQuotationInput = {
    where: QuoteItemWhereUniqueInput
    data: XOR<QuoteItemUpdateWithoutQuotationInput, QuoteItemUncheckedUpdateWithoutQuotationInput>
  }

  export type QuoteItemUpdateManyWithWhereWithoutQuotationInput = {
    where: QuoteItemScalarWhereInput
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyWithoutQuotationInput>
  }

  export type QuoteItemScalarWhereInput = {
    AND?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
    OR?: QuoteItemScalarWhereInput[]
    NOT?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
    id?: UuidFilter<"QuoteItem"> | string
    description?: StringFilter<"QuoteItem"> | string
    quantity?: IntFilter<"QuoteItem"> | number
    unitPrice?: FloatFilter<"QuoteItem"> | number
    totalPrice?: FloatFilter<"QuoteItem"> | number
    unitCost?: FloatFilter<"QuoteItem"> | number
    totalCost?: FloatFilter<"QuoteItem"> | number
    createdAt?: DateTimeFilter<"QuoteItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteItem"> | Date | string
    quotationId?: UuidFilter<"QuoteItem"> | string
  }

  export type OrderUpsertWithoutQuotationInput = {
    update: XOR<OrderUpdateWithoutQuotationInput, OrderUncheckedUpdateWithoutQuotationInput>
    create: XOR<OrderCreateWithoutQuotationInput, OrderUncheckedCreateWithoutQuotationInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutQuotationInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutQuotationInput, OrderUncheckedUpdateWithoutQuotationInput>
  }

  export type OrderUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutQuotationInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutQuotationInput, DocumentUncheckedUpdateWithoutQuotationInput>
    create: XOR<DocumentCreateWithoutQuotationInput, DocumentUncheckedCreateWithoutQuotationInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutQuotationInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutQuotationInput, DocumentUncheckedUpdateWithoutQuotationInput>
  }

  export type DocumentUpdateManyWithWhereWithoutQuotationInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutQuotationInput>
  }

  export type CommunicationUpsertWithWhereUniqueWithoutQuotationInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutQuotationInput, CommunicationUncheckedUpdateWithoutQuotationInput>
    create: XOR<CommunicationCreateWithoutQuotationInput, CommunicationUncheckedCreateWithoutQuotationInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutQuotationInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutQuotationInput, CommunicationUncheckedUpdateWithoutQuotationInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutQuotationInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutQuotationInput>
  }

  export type QuotationCreateWithoutItemsInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: StaffUserCreateNestedOneWithoutApprovedQuotationsInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedQuotationsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedQuotationsInput
    opportunity: OpportunityCreateNestedOneWithoutQuotationsInput
    order?: OrderCreateNestedOneWithoutQuotationInput
    documents?: DocumentCreateNestedManyWithoutQuotationInput
    communications?: CommunicationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutItemsInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    order?: OrderUncheckedCreateNestedOneWithoutQuotationInput
    documents?: DocumentUncheckedCreateNestedManyWithoutQuotationInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutItemsInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
  }

  export type QuotationUpsertWithoutItemsInput = {
    update: XOR<QuotationUpdateWithoutItemsInput, QuotationUncheckedUpdateWithoutItemsInput>
    create: XOR<QuotationCreateWithoutItemsInput, QuotationUncheckedCreateWithoutItemsInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutItemsInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutItemsInput, QuotationUncheckedUpdateWithoutItemsInput>
  }

  export type QuotationUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StaffUserUpdateOneWithoutApprovedQuotationsNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutQuotationsNestedInput
    order?: OrderUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    order?: OrderUncheckedUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type StaffUserCreateWithoutCreatedOrdersInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutCreatedOrdersInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutCreatedOrdersInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutCreatedOrdersInput, StaffUserUncheckedCreateWithoutCreatedOrdersInput>
  }

  export type StaffUserCreateWithoutUpdatedOrdersInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutUpdatedOrdersInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutUpdatedOrdersInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutUpdatedOrdersInput, StaffUserUncheckedCreateWithoutUpdatedOrdersInput>
  }

  export type OpportunityCreateWithoutOrdersInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedOpportunitiesInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOpportunitiesInput
    quotations?: QuotationCreateNestedManyWithoutOpportunityInput
    documents?: DocumentCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutOrdersInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    createdById: string
    updatedById: string
    quotations?: QuotationUncheckedCreateNestedManyWithoutOpportunityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutOrdersInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutOrdersInput, OpportunityUncheckedCreateWithoutOrdersInput>
  }

  export type QuotationCreateWithoutOrderInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: StaffUserCreateNestedOneWithoutApprovedQuotationsInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedQuotationsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedQuotationsInput
    opportunity: OpportunityCreateNestedOneWithoutQuotationsInput
    items?: QuoteItemCreateNestedManyWithoutQuotationInput
    documents?: DocumentCreateNestedManyWithoutQuotationInput
    communications?: CommunicationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutOrderInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuotationInput
    documents?: DocumentUncheckedCreateNestedManyWithoutQuotationInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutOrderInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutOrderInput, QuotationUncheckedCreateWithoutOrderInput>
  }

  export type PurchaseOrderCreateWithoutOrderInput = {
    id?: string
    poRef: string
    issueDate?: Date | string
    supplier: string
    totalValue: number
    currency?: $Enums.Currency
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutOrderInput = {
    id?: string
    poRef: string
    issueDate?: Date | string
    supplier: string
    totalValue: number
    currency?: $Enums.Currency
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutOrderInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutOrderInput, PurchaseOrderUncheckedCreateWithoutOrderInput>
  }

  export type ShipmentCreateWithoutOrderInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedShipmentsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedShipmentsInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
    documents?: DocumentCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutOrderInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutOrderInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput>
  }

  export type ShipmentCreateManyOrderInputEnvelope = {
    data: ShipmentCreateManyOrderInput | ShipmentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedPaymentsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedPaymentsInput
    shipment?: ShipmentCreateNestedOneWithoutPaymentsInput
    documents?: DocumentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    shipmentId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutOrderInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutDocumentsInput
    quotation?: QuotationCreateNestedOneWithoutDocumentsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutDocumentsInput
    shipment?: ShipmentCreateNestedOneWithoutDocumentsInput
    payment?: PaymentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutOrderInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type DocumentCreateOrConnectWithoutOrderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput>
  }

  export type DocumentCreateManyOrderInputEnvelope = {
    data: DocumentCreateManyOrderInput | DocumentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutOrderInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutCommunicationsInput
    opportunity?: OpportunityCreateNestedOneWithoutCommunicationsInput
    quotation?: QuotationCreateNestedOneWithoutCommunicationsInput
    loggedBy?: StaffUserCreateNestedOneWithoutLoggedCommunicationsInput
  }

  export type CommunicationUncheckedCreateWithoutOrderInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    opportunityId?: string | null
    quotationId?: string | null
    loggedByStaffId?: string | null
  }

  export type CommunicationCreateOrConnectWithoutOrderInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutOrderInput, CommunicationUncheckedCreateWithoutOrderInput>
  }

  export type CommunicationCreateManyOrderInputEnvelope = {
    data: CommunicationCreateManyOrderInput | CommunicationCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type StaffUserUpsertWithoutCreatedOrdersInput = {
    update: XOR<StaffUserUpdateWithoutCreatedOrdersInput, StaffUserUncheckedUpdateWithoutCreatedOrdersInput>
    create: XOR<StaffUserCreateWithoutCreatedOrdersInput, StaffUserUncheckedCreateWithoutCreatedOrdersInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutCreatedOrdersInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutCreatedOrdersInput, StaffUserUncheckedUpdateWithoutCreatedOrdersInput>
  }

  export type StaffUserUpdateWithoutCreatedOrdersInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutCreatedOrdersInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUpsertWithoutUpdatedOrdersInput = {
    update: XOR<StaffUserUpdateWithoutUpdatedOrdersInput, StaffUserUncheckedUpdateWithoutUpdatedOrdersInput>
    create: XOR<StaffUserCreateWithoutUpdatedOrdersInput, StaffUserUncheckedCreateWithoutUpdatedOrdersInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutUpdatedOrdersInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutUpdatedOrdersInput, StaffUserUncheckedUpdateWithoutUpdatedOrdersInput>
  }

  export type StaffUserUpdateWithoutUpdatedOrdersInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutUpdatedOrdersInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type OpportunityUpsertWithoutOrdersInput = {
    update: XOR<OpportunityUpdateWithoutOrdersInput, OpportunityUncheckedUpdateWithoutOrdersInput>
    create: XOR<OpportunityCreateWithoutOrdersInput, OpportunityUncheckedCreateWithoutOrdersInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutOrdersInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutOrdersInput, OpportunityUncheckedUpdateWithoutOrdersInput>
  }

  export type OpportunityUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOpportunitiesNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOpportunitiesNestedInput
    quotations?: QuotationUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    quotations?: QuotationUncheckedUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type QuotationUpsertWithoutOrderInput = {
    update: XOR<QuotationUpdateWithoutOrderInput, QuotationUncheckedUpdateWithoutOrderInput>
    create: XOR<QuotationCreateWithoutOrderInput, QuotationUncheckedCreateWithoutOrderInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutOrderInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutOrderInput, QuotationUncheckedUpdateWithoutOrderInput>
  }

  export type QuotationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StaffUserUpdateOneWithoutApprovedQuotationsNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuoteItemUpdateManyWithoutQuotationNestedInput
    documents?: DocumentUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type PurchaseOrderUpsertWithoutOrderInput = {
    update: XOR<PurchaseOrderUpdateWithoutOrderInput, PurchaseOrderUncheckedUpdateWithoutOrderInput>
    create: XOR<PurchaseOrderCreateWithoutOrderInput, PurchaseOrderUncheckedCreateWithoutOrderInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutOrderInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutOrderInput, PurchaseOrderUncheckedUpdateWithoutOrderInput>
  }

  export type PurchaseOrderUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    poRef?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    poRef?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type ShipmentUpsertWithWhereUniqueWithoutOrderInput = {
    where: ShipmentWhereUniqueInput
    update: XOR<ShipmentUpdateWithoutOrderInput, ShipmentUncheckedUpdateWithoutOrderInput>
    create: XOR<ShipmentCreateWithoutOrderInput, ShipmentUncheckedCreateWithoutOrderInput>
  }

  export type ShipmentUpdateWithWhereUniqueWithoutOrderInput = {
    where: ShipmentWhereUniqueInput
    data: XOR<ShipmentUpdateWithoutOrderInput, ShipmentUncheckedUpdateWithoutOrderInput>
  }

  export type ShipmentUpdateManyWithWhereWithoutOrderInput = {
    where: ShipmentScalarWhereInput
    data: XOR<ShipmentUpdateManyMutationInput, ShipmentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutOrderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutOrderInput, DocumentUncheckedUpdateWithoutOrderInput>
    create: XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutOrderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutOrderInput, DocumentUncheckedUpdateWithoutOrderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutOrderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutOrderInput>
  }

  export type CommunicationUpsertWithWhereUniqueWithoutOrderInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutOrderInput, CommunicationUncheckedUpdateWithoutOrderInput>
    create: XOR<CommunicationCreateWithoutOrderInput, CommunicationUncheckedCreateWithoutOrderInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutOrderInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutOrderInput, CommunicationUncheckedUpdateWithoutOrderInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutOrderInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutPurchaseOrderInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    quotationId: string
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPurchaseOrderInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPurchaseOrderInput, OrderUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type DocumentCreateWithoutPurchaseOrderInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutDocumentsInput
    quotation?: QuotationCreateNestedOneWithoutDocumentsInput
    order?: OrderCreateNestedOneWithoutDocumentsInput
    shipment?: ShipmentCreateNestedOneWithoutDocumentsInput
    payment?: PaymentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type DocumentCreateOrConnectWithoutPurchaseOrderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPurchaseOrderInput, DocumentUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type DocumentCreateManyPurchaseOrderInputEnvelope = {
    data: DocumentCreateManyPurchaseOrderInput | DocumentCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutPurchaseOrderInput = {
    update: XOR<OrderUpdateWithoutPurchaseOrderInput, OrderUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<OrderCreateWithoutPurchaseOrderInput, OrderUncheckedCreateWithoutPurchaseOrderInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPurchaseOrderInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPurchaseOrderInput, OrderUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type OrderUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutPurchaseOrderInput, DocumentUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<DocumentCreateWithoutPurchaseOrderInput, DocumentUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutPurchaseOrderInput, DocumentUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type StaffUserCreateWithoutCreatedShipmentsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutCreatedShipmentsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutCreatedShipmentsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutCreatedShipmentsInput, StaffUserUncheckedCreateWithoutCreatedShipmentsInput>
  }

  export type StaffUserCreateWithoutUpdatedShipmentsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutUpdatedShipmentsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutUpdatedShipmentsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutUpdatedShipmentsInput, StaffUserUncheckedCreateWithoutUpdatedShipmentsInput>
  }

  export type OrderCreateWithoutShipmentsInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutShipmentsInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    quotationId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutShipmentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutShipmentsInput, OrderUncheckedCreateWithoutShipmentsInput>
  }

  export type PaymentCreateWithoutShipmentInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedPaymentsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
    documents?: DocumentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutShipmentInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutShipmentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput>
  }

  export type PaymentCreateManyShipmentInputEnvelope = {
    data: PaymentCreateManyShipmentInput | PaymentCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutShipmentInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutDocumentsInput
    quotation?: QuotationCreateNestedOneWithoutDocumentsInput
    order?: OrderCreateNestedOneWithoutDocumentsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutDocumentsInput
    payment?: PaymentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutShipmentInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    paymentId?: string | null
  }

  export type DocumentCreateOrConnectWithoutShipmentInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutShipmentInput, DocumentUncheckedCreateWithoutShipmentInput>
  }

  export type DocumentCreateManyShipmentInputEnvelope = {
    data: DocumentCreateManyShipmentInput | DocumentCreateManyShipmentInput[]
    skipDuplicates?: boolean
  }

  export type StaffUserUpsertWithoutCreatedShipmentsInput = {
    update: XOR<StaffUserUpdateWithoutCreatedShipmentsInput, StaffUserUncheckedUpdateWithoutCreatedShipmentsInput>
    create: XOR<StaffUserCreateWithoutCreatedShipmentsInput, StaffUserUncheckedCreateWithoutCreatedShipmentsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutCreatedShipmentsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutCreatedShipmentsInput, StaffUserUncheckedUpdateWithoutCreatedShipmentsInput>
  }

  export type StaffUserUpdateWithoutCreatedShipmentsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutCreatedShipmentsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUpsertWithoutUpdatedShipmentsInput = {
    update: XOR<StaffUserUpdateWithoutUpdatedShipmentsInput, StaffUserUncheckedUpdateWithoutUpdatedShipmentsInput>
    create: XOR<StaffUserCreateWithoutUpdatedShipmentsInput, StaffUserUncheckedCreateWithoutUpdatedShipmentsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutUpdatedShipmentsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutUpdatedShipmentsInput, StaffUserUncheckedUpdateWithoutUpdatedShipmentsInput>
  }

  export type StaffUserUpdateWithoutUpdatedShipmentsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutUpdatedShipmentsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type OrderUpsertWithoutShipmentsInput = {
    update: XOR<OrderUpdateWithoutShipmentsInput, OrderUncheckedUpdateWithoutShipmentsInput>
    create: XOR<OrderCreateWithoutShipmentsInput, OrderUncheckedCreateWithoutShipmentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutShipmentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutShipmentsInput, OrderUncheckedUpdateWithoutShipmentsInput>
  }

  export type OrderUpdateWithoutShipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutShipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutShipmentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutShipmentInput, PaymentUncheckedUpdateWithoutShipmentInput>
    create: XOR<PaymentCreateWithoutShipmentInput, PaymentUncheckedCreateWithoutShipmentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutShipmentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutShipmentInput, PaymentUncheckedUpdateWithoutShipmentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutShipmentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutShipmentInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutShipmentInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutShipmentInput, DocumentUncheckedUpdateWithoutShipmentInput>
    create: XOR<DocumentCreateWithoutShipmentInput, DocumentUncheckedCreateWithoutShipmentInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutShipmentInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutShipmentInput, DocumentUncheckedUpdateWithoutShipmentInput>
  }

  export type DocumentUpdateManyWithWhereWithoutShipmentInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutShipmentInput>
  }

  export type StaffUserCreateWithoutCreatedPaymentsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutCreatedPaymentsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutCreatedPaymentsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutCreatedPaymentsInput, StaffUserUncheckedCreateWithoutCreatedPaymentsInput>
  }

  export type StaffUserCreateWithoutUpdatedPaymentsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutUpdatedPaymentsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    loggedCommunications?: CommunicationUncheckedCreateNestedManyWithoutLoggedByInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutUpdatedPaymentsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutUpdatedPaymentsInput, StaffUserUncheckedCreateWithoutUpdatedPaymentsInput>
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    quotationId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type ShipmentCreateWithoutPaymentsInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedShipmentsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedShipmentsInput
    order: OrderCreateNestedOneWithoutShipmentsInput
    documents?: DocumentCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutPaymentsInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
    documents?: DocumentUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutPaymentsInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutPaymentsInput, ShipmentUncheckedCreateWithoutPaymentsInput>
  }

  export type DocumentCreateWithoutPaymentInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunity?: OpportunityCreateNestedOneWithoutDocumentsInput
    quotation?: QuotationCreateNestedOneWithoutDocumentsInput
    order?: OrderCreateNestedOneWithoutDocumentsInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutDocumentsInput
    shipment?: ShipmentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutPaymentInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
  }

  export type DocumentCreateOrConnectWithoutPaymentInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPaymentInput, DocumentUncheckedCreateWithoutPaymentInput>
  }

  export type DocumentCreateManyPaymentInputEnvelope = {
    data: DocumentCreateManyPaymentInput | DocumentCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type StaffUserUpsertWithoutCreatedPaymentsInput = {
    update: XOR<StaffUserUpdateWithoutCreatedPaymentsInput, StaffUserUncheckedUpdateWithoutCreatedPaymentsInput>
    create: XOR<StaffUserCreateWithoutCreatedPaymentsInput, StaffUserUncheckedCreateWithoutCreatedPaymentsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutCreatedPaymentsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutCreatedPaymentsInput, StaffUserUncheckedUpdateWithoutCreatedPaymentsInput>
  }

  export type StaffUserUpdateWithoutCreatedPaymentsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutCreatedPaymentsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUpsertWithoutUpdatedPaymentsInput = {
    update: XOR<StaffUserUpdateWithoutUpdatedPaymentsInput, StaffUserUncheckedUpdateWithoutUpdatedPaymentsInput>
    create: XOR<StaffUserCreateWithoutUpdatedPaymentsInput, StaffUserUncheckedCreateWithoutUpdatedPaymentsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutUpdatedPaymentsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutUpdatedPaymentsInput, StaffUserUncheckedUpdateWithoutUpdatedPaymentsInput>
  }

  export type StaffUserUpdateWithoutUpdatedPaymentsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutUpdatedPaymentsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ShipmentUpsertWithoutPaymentsInput = {
    update: XOR<ShipmentUpdateWithoutPaymentsInput, ShipmentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ShipmentCreateWithoutPaymentsInput, ShipmentUncheckedCreateWithoutPaymentsInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutPaymentsInput, ShipmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type ShipmentUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedShipmentsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedShipmentsNestedInput
    order?: OrderUpdateOneRequiredWithoutShipmentsNestedInput
    documents?: DocumentUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutPaymentInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutPaymentInput, DocumentUncheckedUpdateWithoutPaymentInput>
    create: XOR<DocumentCreateWithoutPaymentInput, DocumentUncheckedCreateWithoutPaymentInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutPaymentInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutPaymentInput, DocumentUncheckedUpdateWithoutPaymentInput>
  }

  export type DocumentUpdateManyWithWhereWithoutPaymentInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type OpportunityCreateWithoutDocumentsInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedOpportunitiesInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOpportunitiesInput
    quotations?: QuotationCreateNestedManyWithoutOpportunityInput
    orders?: OrderCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutDocumentsInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    createdById: string
    updatedById: string
    quotations?: QuotationUncheckedCreateNestedManyWithoutOpportunityInput
    orders?: OrderUncheckedCreateNestedManyWithoutOpportunityInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutDocumentsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutDocumentsInput, OpportunityUncheckedCreateWithoutDocumentsInput>
  }

  export type QuotationCreateWithoutDocumentsInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: StaffUserCreateNestedOneWithoutApprovedQuotationsInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedQuotationsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedQuotationsInput
    opportunity: OpportunityCreateNestedOneWithoutQuotationsInput
    items?: QuoteItemCreateNestedManyWithoutQuotationInput
    order?: OrderCreateNestedOneWithoutQuotationInput
    communications?: CommunicationCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuotationInput
    order?: OrderUncheckedCreateNestedOneWithoutQuotationInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutDocumentsInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutDocumentsInput, QuotationUncheckedCreateWithoutDocumentsInput>
  }

  export type OrderCreateWithoutDocumentsInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    communications?: CommunicationCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDocumentsInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    quotationId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDocumentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDocumentsInput, OrderUncheckedCreateWithoutDocumentsInput>
  }

  export type PurchaseOrderCreateWithoutDocumentsInput = {
    id?: string
    poRef: string
    issueDate?: Date | string
    supplier: string
    totalValue: number
    currency?: $Enums.Currency
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutDocumentsInput = {
    id?: string
    poRef: string
    issueDate?: Date | string
    supplier: string
    totalValue: number
    currency?: $Enums.Currency
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: string
  }

  export type PurchaseOrderCreateOrConnectWithoutDocumentsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutDocumentsInput, PurchaseOrderUncheckedCreateWithoutDocumentsInput>
  }

  export type ShipmentCreateWithoutDocumentsInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedShipmentsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedShipmentsInput
    order: OrderCreateNestedOneWithoutShipmentsInput
    payments?: PaymentCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentUncheckedCreateWithoutDocumentsInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
    payments?: PaymentUncheckedCreateNestedManyWithoutShipmentInput
  }

  export type ShipmentCreateOrConnectWithoutDocumentsInput = {
    where: ShipmentWhereUniqueInput
    create: XOR<ShipmentCreateWithoutDocumentsInput, ShipmentUncheckedCreateWithoutDocumentsInput>
  }

  export type PaymentCreateWithoutDocumentsInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedPaymentsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedPaymentsInput
    order: OrderCreateNestedOneWithoutPaymentsInput
    shipment?: ShipmentCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutDocumentsInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
    shipmentId?: string | null
  }

  export type PaymentCreateOrConnectWithoutDocumentsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutDocumentsInput, PaymentUncheckedCreateWithoutDocumentsInput>
  }

  export type OpportunityUpsertWithoutDocumentsInput = {
    update: XOR<OpportunityUpdateWithoutDocumentsInput, OpportunityUncheckedUpdateWithoutDocumentsInput>
    create: XOR<OpportunityCreateWithoutDocumentsInput, OpportunityUncheckedCreateWithoutDocumentsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutDocumentsInput, OpportunityUncheckedUpdateWithoutDocumentsInput>
  }

  export type OpportunityUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOpportunitiesNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOpportunitiesNestedInput
    quotations?: QuotationUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    quotations?: QuotationUncheckedUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type QuotationUpsertWithoutDocumentsInput = {
    update: XOR<QuotationUpdateWithoutDocumentsInput, QuotationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<QuotationCreateWithoutDocumentsInput, QuotationUncheckedCreateWithoutDocumentsInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutDocumentsInput, QuotationUncheckedUpdateWithoutDocumentsInput>
  }

  export type QuotationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StaffUserUpdateOneWithoutApprovedQuotationsNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuoteItemUpdateManyWithoutQuotationNestedInput
    order?: OrderUpdateOneWithoutQuotationNestedInput
    communications?: CommunicationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput
    order?: OrderUncheckedUpdateOneWithoutQuotationNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type OrderUpsertWithoutDocumentsInput = {
    update: XOR<OrderUpdateWithoutDocumentsInput, OrderUncheckedUpdateWithoutDocumentsInput>
    create: XOR<OrderCreateWithoutDocumentsInput, OrderUncheckedCreateWithoutDocumentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDocumentsInput, OrderUncheckedUpdateWithoutDocumentsInput>
  }

  export type OrderUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PurchaseOrderUpsertWithoutDocumentsInput = {
    update: XOR<PurchaseOrderUpdateWithoutDocumentsInput, PurchaseOrderUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PurchaseOrderCreateWithoutDocumentsInput, PurchaseOrderUncheckedCreateWithoutDocumentsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutDocumentsInput, PurchaseOrderUncheckedUpdateWithoutDocumentsInput>
  }

  export type PurchaseOrderUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poRef?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poRef?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StringFieldUpdateOperationsInput | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type ShipmentUpsertWithoutDocumentsInput = {
    update: XOR<ShipmentUpdateWithoutDocumentsInput, ShipmentUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ShipmentCreateWithoutDocumentsInput, ShipmentUncheckedCreateWithoutDocumentsInput>
    where?: ShipmentWhereInput
  }

  export type ShipmentUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ShipmentWhereInput
    data: XOR<ShipmentUpdateWithoutDocumentsInput, ShipmentUncheckedUpdateWithoutDocumentsInput>
  }

  export type ShipmentUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedShipmentsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedShipmentsNestedInput
    order?: OrderUpdateOneRequiredWithoutShipmentsNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type PaymentUpsertWithoutDocumentsInput = {
    update: XOR<PaymentUpdateWithoutDocumentsInput, PaymentUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PaymentCreateWithoutDocumentsInput, PaymentUncheckedCreateWithoutDocumentsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutDocumentsInput, PaymentUncheckedUpdateWithoutDocumentsInput>
  }

  export type PaymentUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedPaymentsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    shipment?: ShipmentUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateWithoutCommunicationsInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityCreateNestedManyWithoutCustomerInput
    projects?: ProjectCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    cid: string
    customerType: string
    businessName: string
    salutation?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    address?: string | null
    currency?: $Enums.Currency
    gstin?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutCustomerInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCommunicationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCommunicationsInput, CustomerUncheckedCreateWithoutCommunicationsInput>
  }

  export type OpportunityCreateWithoutCommunicationsInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutOpportunitiesInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedOpportunitiesInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOpportunitiesInput
    quotations?: QuotationCreateNestedManyWithoutOpportunityInput
    orders?: OrderCreateNestedManyWithoutOpportunityInput
    documents?: DocumentCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    createdById: string
    updatedById: string
    quotations?: QuotationUncheckedCreateNestedManyWithoutOpportunityInput
    orders?: OrderUncheckedCreateNestedManyWithoutOpportunityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutCommunicationsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutCommunicationsInput, OpportunityUncheckedCreateWithoutCommunicationsInput>
  }

  export type QuotationCreateWithoutCommunicationsInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvedBy?: StaffUserCreateNestedOneWithoutApprovedQuotationsInput
    createdBy: StaffUserCreateNestedOneWithoutCreatedQuotationsInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedQuotationsInput
    opportunity: OpportunityCreateNestedOneWithoutQuotationsInput
    items?: QuoteItemCreateNestedManyWithoutQuotationInput
    order?: OrderCreateNestedOneWithoutQuotationInput
    documents?: DocumentCreateNestedManyWithoutQuotationInput
  }

  export type QuotationUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuotationInput
    order?: OrderUncheckedCreateNestedOneWithoutQuotationInput
    documents?: DocumentUncheckedCreateNestedManyWithoutQuotationInput
  }

  export type QuotationCreateOrConnectWithoutCommunicationsInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutCommunicationsInput, QuotationUncheckedCreateWithoutCommunicationsInput>
  }

  export type OrderCreateWithoutCommunicationsInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: StaffUserCreateNestedOneWithoutCreatedOrdersInput
    updatedBy: StaffUserCreateNestedOneWithoutUpdatedOrdersInput
    opportunity: OpportunityCreateNestedOneWithoutOrdersInput
    quotation: QuotationCreateNestedOneWithoutOrderInput
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutOrderInput
    shipments?: ShipmentCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    documents?: DocumentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
    quotationId: string
    purchaseOrder?: PurchaseOrderUncheckedCreateNestedOneWithoutOrderInput
    shipments?: ShipmentUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCommunicationsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCommunicationsInput, OrderUncheckedCreateWithoutCommunicationsInput>
  }

  export type StaffUserCreateWithoutLoggedCommunicationsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskCreateNestedManyWithoutAssignedUserInput
    managedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserUncheckedCreateWithoutLoggedCommunicationsInput = {
    staffId?: string
    name: string
    email: string
    designation: string
    contactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdOpportunities?: OpportunityUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOpportunities?: OpportunityUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQuotations?: QuotationUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQuotations?: QuotationUncheckedCreateNestedManyWithoutUpdatedByInput
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    updatedOrders?: OrderUncheckedCreateNestedManyWithoutUpdatedByInput
    createdShipments?: ShipmentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedShipments?: ShipmentUncheckedCreateNestedManyWithoutUpdatedByInput
    createdPayments?: PaymentUncheckedCreateNestedManyWithoutCreatedByInput
    updatedPayments?: PaymentUncheckedCreateNestedManyWithoutUpdatedByInput
    approvedQuotations?: QuotationUncheckedCreateNestedManyWithoutApprovedByInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssignedUserInput
    managedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    memberOfProjects?: ProjectUncheckedCreateNestedManyWithoutTeamMembersInput
  }

  export type StaffUserCreateOrConnectWithoutLoggedCommunicationsInput = {
    where: StaffUserWhereUniqueInput
    create: XOR<StaffUserCreateWithoutLoggedCommunicationsInput, StaffUserUncheckedCreateWithoutLoggedCommunicationsInput>
  }

  export type CustomerUpsertWithoutCommunicationsInput = {
    update: XOR<CustomerUpdateWithoutCommunicationsInput, CustomerUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<CustomerCreateWithoutCommunicationsInput, CustomerUncheckedCreateWithoutCommunicationsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCommunicationsInput, CustomerUncheckedUpdateWithoutCommunicationsInput>
  }

  export type CustomerUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    businessName?: StringFieldUpdateOperationsInput | string
    salutation?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityUncheckedUpdateManyWithoutCustomerNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OpportunityUpsertWithoutCommunicationsInput = {
    update: XOR<OpportunityUpdateWithoutCommunicationsInput, OpportunityUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<OpportunityCreateWithoutCommunicationsInput, OpportunityUncheckedCreateWithoutCommunicationsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutCommunicationsInput, OpportunityUncheckedUpdateWithoutCommunicationsInput>
  }

  export type OpportunityUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOpportunitiesNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOpportunitiesNestedInput
    quotations?: QuotationUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    quotations?: QuotationUncheckedUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type QuotationUpsertWithoutCommunicationsInput = {
    update: XOR<QuotationUpdateWithoutCommunicationsInput, QuotationUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<QuotationCreateWithoutCommunicationsInput, QuotationUncheckedCreateWithoutCommunicationsInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutCommunicationsInput, QuotationUncheckedUpdateWithoutCommunicationsInput>
  }

  export type QuotationUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StaffUserUpdateOneWithoutApprovedQuotationsNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuoteItemUpdateManyWithoutQuotationNestedInput
    order?: OrderUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput
    order?: OrderUncheckedUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type OrderUpsertWithoutCommunicationsInput = {
    update: XOR<OrderUpdateWithoutCommunicationsInput, OrderUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<OrderCreateWithoutCommunicationsInput, OrderUncheckedCreateWithoutCommunicationsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutCommunicationsInput, OrderUncheckedUpdateWithoutCommunicationsInput>
  }

  export type OrderUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type StaffUserUpsertWithoutLoggedCommunicationsInput = {
    update: XOR<StaffUserUpdateWithoutLoggedCommunicationsInput, StaffUserUncheckedUpdateWithoutLoggedCommunicationsInput>
    create: XOR<StaffUserCreateWithoutLoggedCommunicationsInput, StaffUserUncheckedCreateWithoutLoggedCommunicationsInput>
    where?: StaffUserWhereInput
  }

  export type StaffUserUpdateToOneWithWhereWithoutLoggedCommunicationsInput = {
    where?: StaffUserWhereInput
    data: XOR<StaffUserUpdateWithoutLoggedCommunicationsInput, StaffUserUncheckedUpdateWithoutLoggedCommunicationsInput>
  }

  export type StaffUserUpdateWithoutLoggedCommunicationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUpdateManyWithoutTeamMembersNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutLoggedCommunicationsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    memberOfProjects?: ProjectUncheckedUpdateManyWithoutTeamMembersNestedInput
  }

  export type OpportunityCreateManyCreatedByInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    updatedById: string
  }

  export type OpportunityCreateManyUpdatedByInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
    createdById: string
  }

  export type QuotationCreateManyCreatedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    opportunityId: string
  }

  export type QuotationCreateManyUpdatedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    opportunityId: string
  }

  export type OrderCreateManyCreatedByInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    opportunityId: string
    quotationId: string
  }

  export type OrderCreateManyUpdatedByInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    opportunityId: string
    quotationId: string
  }

  export type ShipmentCreateManyCreatedByInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    orderId: string
  }

  export type ShipmentCreateManyUpdatedByInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    orderId: string
  }

  export type PaymentCreateManyCreatedByInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById: string
    orderId: string
    shipmentId?: string | null
  }

  export type PaymentCreateManyUpdatedByInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    orderId: string
    shipmentId?: string | null
  }

  export type QuotationCreateManyApprovedByInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    opportunityId: string
  }

  export type TaskCreateManyAssignedUserInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationCreateManyLoggedByInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
  }

  export type ProjectCreateManyProjectManagerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId: string
  }

  export type OpportunityUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOpportunitiesNestedInput
    quotations?: QuotationUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    quotations?: QuotationUncheckedUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
  }

  export type OpportunityUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutOpportunitiesNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOpportunitiesNestedInput
    quotations?: QuotationUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    quotations?: QuotationUncheckedUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type QuotationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StaffUserUpdateOneWithoutApprovedQuotationsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuoteItemUpdateManyWithoutQuotationNestedInput
    order?: OrderUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput
    order?: OrderUncheckedUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type QuotationUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StaffUserUpdateOneWithoutApprovedQuotationsNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuoteItemUpdateManyWithoutQuotationNestedInput
    order?: OrderUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput
    order?: OrderUncheckedUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
  }

  export type ShipmentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedShipmentsNestedInput
    order?: OrderUpdateOneRequiredWithoutShipmentsNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    documents?: DocumentUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type ShipmentUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedShipmentsNestedInput
    order?: OrderUpdateOneRequiredWithoutShipmentsNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    documents?: DocumentUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    shipment?: ShipmentUpdateOneWithoutPaymentsNestedInput
    documents?: DocumentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    shipment?: ShipmentUpdateOneWithoutPaymentsNestedInput
    documents?: DocumentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput
    opportunity?: OpportunityUpdateOneRequiredWithoutQuotationsNestedInput
    items?: QuoteItemUpdateManyWithoutQuotationNestedInput
    order?: OrderUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput
    order?: OrderUncheckedUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUpdateWithoutLoggedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutCommunicationsNestedInput
    opportunity?: OpportunityUpdateOneWithoutCommunicationsNestedInput
    quotation?: QuotationUpdateOneWithoutCommunicationsNestedInput
    order?: OrderUpdateOneWithoutCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutLoggedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUncheckedUpdateManyWithoutLoggedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutProjectManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    teamMembers?: StaffUserUpdateManyWithoutMemberOfProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    teamMembers?: StaffUserUncheckedUpdateManyWithoutMemberOfProjectsNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProjectsNestedInput
    projectManager?: StaffUserUpdateOneWithoutManagedProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUncheckedUpdateManyWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpportunityCreateManyCustomerInput = {
    id?: string
    oppRef: string
    title: string
    status?: $Enums.OpportunityStatus
    value: number
    currency?: $Enums.Currency
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
  }

  export type ProjectCreateManyCustomerInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.ProjectStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectManagerId?: string | null
  }

  export type CommunicationCreateManyCustomerInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    loggedByStaffId?: string | null
  }

  export type OpportunityUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOpportunitiesNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOpportunitiesNestedInput
    quotations?: QuotationUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    quotations?: QuotationUncheckedUpdateManyWithoutOpportunityNestedInput
    orders?: OrderUncheckedUpdateManyWithoutOpportunityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOpportunityNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    oppRef?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    value?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectManager?: StaffUserUpdateOneWithoutManagedProjectsNestedInput
    teamMembers?: StaffUserUpdateManyWithoutMemberOfProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    teamMembers?: StaffUserUncheckedUpdateManyWithoutMemberOfProjectsNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutCommunicationsNestedInput
    quotation?: QuotationUpdateOneWithoutCommunicationsNestedInput
    order?: OrderUpdateOneWithoutCommunicationsNestedInput
    loggedBy?: StaffUserUpdateOneWithoutLoggedCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuotationCreateManyOpportunityInput = {
    id?: string
    quoteRef: string
    revision?: number
    status?: $Enums.QuotationStatus
    currency?: $Enums.Currency
    fxRate?: number
    totalCost?: number
    markupPercent?: number
    insurancePercent?: number
    financeCharge?: number
    subtotal?: number
    vatPercent?: number
    totalWithVAT?: number
    profitMarginBHD?: number
    fxGain?: number | null
    validUntil: Date | string
    paymentTerms?: string | null
    deliveryTerms?: string | null
    expectedDeliveryDate?: Date | string | null
    marginApprovalPopup?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
  }

  export type OrderCreateManyOpportunityInput = {
    id?: string
    orderRef: string
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    totalValue: number
    currency?: $Enums.Currency
    expectedDeliveryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    quotationId: string
  }

  export type DocumentCreateManyOpportunityInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    quotationId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type CommunicationCreateManyOpportunityInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    quotationId?: string | null
    orderId?: string | null
    loggedByStaffId?: string | null
  }

  export type QuotationUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedBy?: StaffUserUpdateOneWithoutApprovedQuotationsNestedInput
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedQuotationsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedQuotationsNestedInput
    items?: QuoteItemUpdateManyWithoutQuotationNestedInput
    order?: OrderUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuotationNestedInput
    order?: OrderUncheckedUpdateOneWithoutQuotationNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutQuotationNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteRef?: StringFieldUpdateOperationsInput | string
    revision?: IntFieldUpdateOperationsInput | number
    status?: EnumQuotationStatusFieldUpdateOperationsInput | $Enums.QuotationStatus
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    fxRate?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    markupPercent?: FloatFieldUpdateOperationsInput | number
    insurancePercent?: FloatFieldUpdateOperationsInput | number
    financeCharge?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    vatPercent?: FloatFieldUpdateOperationsInput | number
    totalWithVAT?: FloatFieldUpdateOperationsInput | number
    profitMarginBHD?: FloatFieldUpdateOperationsInput | number
    fxGain?: NullableFloatFieldUpdateOperationsInput | number | null
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTerms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    marginApprovalPopup?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedOrdersNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedOrdersNestedInput
    quotation?: QuotationUpdateOneRequiredWithoutOrderNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    documents?: DocumentUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
    purchaseOrder?: PurchaseOrderUncheckedUpdateOneWithoutOrderNestedInput
    shipments?: ShipmentUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderRef?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalValue?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    quotationId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotation?: QuotationUpdateOneWithoutDocumentsNestedInput
    order?: OrderUpdateOneWithoutDocumentsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutDocumentsNestedInput
    shipment?: ShipmentUpdateOneWithoutDocumentsNestedInput
    payment?: PaymentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutCommunicationsNestedInput
    quotation?: QuotationUpdateOneWithoutCommunicationsNestedInput
    order?: OrderUpdateOneWithoutCommunicationsNestedInput
    loggedBy?: StaffUserUpdateOneWithoutLoggedCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUncheckedUpdateManyWithoutOpportunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaffUserUpdateWithoutMemberOfProjectsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
  }

  export type StaffUserUncheckedUpdateWithoutMemberOfProjectsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOpportunities?: OpportunityUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOpportunities?: OpportunityUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQuotations?: QuotationUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQuotations?: QuotationUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedOrders?: OrderUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdShipments?: ShipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedShipments?: ShipmentUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdPayments?: PaymentUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedPayments?: PaymentUncheckedUpdateManyWithoutUpdatedByNestedInput
    approvedQuotations?: QuotationUncheckedUpdateManyWithoutApprovedByNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssignedUserNestedInput
    loggedCommunications?: CommunicationUncheckedUpdateManyWithoutLoggedByNestedInput
    managedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
  }

  export type StaffUserUncheckedUpdateManyWithoutMemberOfProjectsInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemCreateManyQuotationInput = {
    id?: string
    description: string
    quantity: number
    unitPrice: number
    totalPrice: number
    unitCost: number
    totalCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyQuotationInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type CommunicationCreateManyQuotationInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    opportunityId?: string | null
    orderId?: string | null
    loggedByStaffId?: string | null
  }

  export type QuoteItemUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemUncheckedUpdateManyWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    unitCost?: FloatFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutDocumentsNestedInput
    order?: OrderUpdateOneWithoutDocumentsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutDocumentsNestedInput
    shipment?: ShipmentUpdateOneWithoutDocumentsNestedInput
    payment?: PaymentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutCommunicationsNestedInput
    opportunity?: OpportunityUpdateOneWithoutCommunicationsNestedInput
    order?: OrderUpdateOneWithoutCommunicationsNestedInput
    loggedBy?: StaffUserUpdateOneWithoutLoggedCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUncheckedUpdateManyWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShipmentCreateManyOrderInput = {
    id?: string
    shipmentRef: string
    status?: $Enums.ShipmentStatus
    trackingNumber?: string | null
    carrier?: string | null
    shippedOn?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    actualShipmentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    shipmentId?: string | null
  }

  export type DocumentCreateManyOrderInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type CommunicationCreateManyOrderInput = {
    id?: string
    type: $Enums.CommunicationType
    direction: $Enums.CommunicationDirection
    content: string
    subject?: string | null
    sender: string
    recipient?: string | null
    timestamp: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerId?: string | null
    opportunityId?: string | null
    quotationId?: string | null
    loggedByStaffId?: string | null
  }

  export type ShipmentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedShipmentsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedShipmentsNestedInput
    payments?: PaymentUpdateManyWithoutShipmentNestedInput
    documents?: DocumentUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    payments?: PaymentUncheckedUpdateManyWithoutShipmentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutShipmentNestedInput
  }

  export type ShipmentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    shipmentRef?: StringFieldUpdateOperationsInput | string
    status?: EnumShipmentStatusFieldUpdateOperationsInput | $Enums.ShipmentStatus
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carrier?: NullableStringFieldUpdateOperationsInput | string | null
    shippedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualShipmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedPaymentsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedPaymentsNestedInput
    shipment?: ShipmentUpdateOneWithoutPaymentsNestedInput
    documents?: DocumentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutDocumentsNestedInput
    quotation?: QuotationUpdateOneWithoutDocumentsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutDocumentsNestedInput
    shipment?: ShipmentUpdateOneWithoutDocumentsNestedInput
    payment?: PaymentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutCommunicationsNestedInput
    opportunity?: OpportunityUpdateOneWithoutCommunicationsNestedInput
    quotation?: QuotationUpdateOneWithoutCommunicationsNestedInput
    loggedBy?: StaffUserUpdateOneWithoutLoggedCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCommunicationTypeFieldUpdateOperationsInput | $Enums.CommunicationType
    direction?: EnumCommunicationDirectionFieldUpdateOperationsInput | $Enums.CommunicationDirection
    content?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    sender?: StringFieldUpdateOperationsInput | string
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    loggedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyPurchaseOrderInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    shipmentId?: string | null
    paymentId?: string | null
  }

  export type DocumentUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutDocumentsNestedInput
    quotation?: QuotationUpdateOneWithoutDocumentsNestedInput
    order?: OrderUpdateOneWithoutDocumentsNestedInput
    shipment?: ShipmentUpdateOneWithoutDocumentsNestedInput
    payment?: PaymentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyShipmentInput = {
    id?: string
    paymentRef: string
    amount: number
    currency?: $Enums.Currency
    paymentMethod: string
    status?: $Enums.PaymentStatus
    paymentDate?: Date | string
    paymentReceivedOn?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    updatedById: string
    orderId: string
  }

  export type DocumentCreateManyShipmentInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    paymentId?: string | null
  }

  export type PaymentUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StaffUserUpdateOneRequiredWithoutCreatedPaymentsNestedInput
    updatedBy?: StaffUserUpdateOneRequiredWithoutUpdatedPaymentsNestedInput
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
    documents?: DocumentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    documents?: DocumentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRef?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    paymentMethod?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentReceivedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutDocumentsNestedInput
    quotation?: QuotationUpdateOneWithoutDocumentsNestedInput
    order?: OrderUpdateOneWithoutDocumentsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutDocumentsNestedInput
    payment?: PaymentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutShipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyPaymentInput = {
    id?: string
    fileName: string
    fileType: string
    url: string
    sizeBytes: number
    createdAt?: Date | string
    opportunityId?: string | null
    quotationId?: string | null
    orderId?: string | null
    purchaseOrderId?: string | null
    shipmentId?: string | null
  }

  export type DocumentUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneWithoutDocumentsNestedInput
    quotation?: QuotationUpdateOneWithoutDocumentsNestedInput
    order?: OrderUpdateOneWithoutDocumentsNestedInput
    purchaseOrder?: PurchaseOrderUpdateOneWithoutDocumentsNestedInput
    shipment?: ShipmentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunityId?: NullableStringFieldUpdateOperationsInput | string | null
    quotationId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    shipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}